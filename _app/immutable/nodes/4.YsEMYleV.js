import"../chunks/DsnmJJEf.js";import{s as Y,d as me,a as fe}from"../chunks/CQ7OeVSD.js";import{p as ie,f as x,s as I,d as b,r as _,b as v,c as ce,a as Z,w as ee,x as r,y as z,z as P,t as X,D as Ie,v as _e,$ as Se,S as J,T as Ce,U as ae}from"../chunks/Du57CbYy.js";import{i as y,s as we,a as ye}from"../chunks/BgTyvlfH.js";import{r as de,l as be}from"../chunks/C7pI9irj.js";import{U as G,b as le,e as oe,i as re,N as Q,E as te,u as xe,R as Te,P as Ee,h as Re,j as ke,k as W}from"../chunks/D0f_mMde.js";import{E as Pe,C as De}from"../chunks/kpbFuTU_.js";import{h as Ue}from"../chunks/B6c_pe_a.js";const Ne=!0,ot=Object.freeze(Object.defineProperty({__proto__:null,prerender:Ne},Symbol.toStringTag,{value:"Module"}));var $e=x("<p>The graph doesn't contain a Hamiltonian cycle.</p>"),Le=x("<li> </li>"),Oe=x("<ol></ol>"),Ae=x("<span><!> </span>"),He=x("<div></div>"),Fe=x('<div class="controls"><input type="checkbox" name="showAsListCheckbox"/> <label for="showAsListCheckbox">Show as list</label></div> <!>',1),Me=x("<main><h2>CertRenderer TSP</h2> <!></main>");function je(U,n){ie(n,!0);let e=z(!0);var m=Me(),R=I(b(m),2);{var d=f=>{var p=$e();v(f,p)},g=f=>{var p=Fe(),C=Z(p),o=b(C);de(o),ee(2),_(C);var M=I(C,2);{var q=w=>{var E=Oe();oe(E,21,()=>n.cert.path,re,(N,$)=>{var T=Le(),L=b(T,!0);_(T),X(()=>Y(L,r($).id)),v(N,T)}),_(E),v(w,E)},B=w=>{var E=He();oe(E,21,()=>n.cert.path,re,(N,$,T)=>{var L=Ae(),j=b(L);Ue(j,()=>T!=0?"&ThinSpace;&LongRightArrow;&ThinSpace;":"");var K=I(j);_(L),X(()=>Y(K,` ${r($).id??""}`)),v(N,L)}),_(E),v(w,E)};y(M,w=>{r(e)?w(q):w(B,!1)})}le(o,()=>r(e),w=>P(e,w)),v(f,p)};y(R,f=>{n.cert==G?f(d):f(g,!1)})}_(m),v(U,m),ce()}class We{path;constructor(n){this.path=n}}class ze{decode(n,e){return new We(e.path)}}class Ge{inInstance;nodeCount;constructor(n){this.inInstance=n,this.nodeCount=this.inInstance.nodes.length}copyOver(n){const e=[];return e.push({id:"copy-over",title:"Copy over the original graph",description:"",mapping:{},inSnapshot:this.inInstance.copy(),outSnapshot:n}),{graph:n,steps:e}}assignWeightsToExisting(n){const e=[];return n.edges.forEach(m=>{m.weight=1,m.classes+=" solid"}),e.push({id:"assign-weight-1",title:"Assign weights to existing edges",description:`
                <p>
                    For each edge that was in the original graph now assign the weight 1.
                </p>
            `,mapping:{},inSnapshot:this.inInstance.copy(),outSnapshot:n}),{graph:n,steps:e}}addMissingEdges(n){const e=[],m=new Set(this.inInstance.edges.map(d=>d.id)),R=this.inInstance.nodes.map(d=>(n.addNode(d),d.id.slice(Q.length)));for(let d=0;d<n.nodes.length;d++)for(let g=d+1;g<n.nodes.length;g++){const f=R[d],p=R[g],C=te+`${f}-${p}`,o=te+`${p}-${f}`;m.has(C)||m.has(o)||n.addEdge({id:C,from:Q+f,to:Q+p,weight:2,classes:"muted"})}return e.push({id:"add-missing-edges",title:"Add missing edges",description:`
                <p>
                    Connect all the nodes that weren't connect before by a new edge and assign a weight of 2 to this new edge.
                </p>
            `,mapping:{},inSnapshot:this.inInstance.copy(),outSnapshot:n}),{graph:n,steps:e}}reduce(){const n=[];n.push({id:"reduce-hcircuit-to-tsp-1",title:"Create complete graph",description:`
                <p> 
                    Take all of the nodes from the original graph and add an edge between each of them (make a complete graph).
                    For every edge that exists in the original instance, assign a weight of 1.
                    Otherwise assign some weight larger than 1.
                </p>
                <p>
                    There is ${this.nodeCount} nodes, 
                    which means there will be (${this.nodeCount} * ${this.nodeCount-1}) / 2 = ${this.nodeCount*(this.nodeCount-1)/2} edges, 
                    for it to be complete.
                </p>
                <p>
                    Now this problem can expressed by a decision question:
                    Is there a hamiltonian cycle such that the cost of the traversal is less than or equal to ${this.nodeCount}?
                </p>
            `,inSnapshot:this.inInstance.copy(),mapping:{}});const e=this.copyOver(this.inInstance.copy());n.push(...e.steps);const m=this.assignWeightsToExisting(e.graph.copy());n.push(...m.steps);const R=this.addMissingEdges(m.graph.copy());return n.push(...R.steps),{outInstance:R.graph,steps:n}}}var Xe=x('<meta name="description" content="Reduction from HCIRCUIT to TSP"/>'),qe=(U,n)=>n(),Be=x("<div><!></div> <!> <div><!></div>",1),Ke=x("<span>There are no steps to step through.</span>"),Ve=x('<div class="panes"><div><!> <!></div> <div><!> <!></div></div>'),Je=x('<main><h1>HCIRCUIT to TSP reduction</h1> <!> <div class="controls"><button>Reduce</button> <button><!></button> <input type="checkbox" name="showStepperCheckbox"/> <label for="showStepperCheckbox">Show steps</label></div> <!> <!></main>');function rt(U,n){ie(n,!0);const e=()=>we(g,"$redStore",m),[m,R]=ye();let d=xe(be.LS_HCIRCUIT_TSP,new Te),g=d.value;console.debug("input instance:",e().inInstance);let f=z(!1),p=z(!1),C=z(""),o=null;function M(t){o&&(o.terminate(),o=null,P(p,!1),P(C,"Solving cancelled â€” formula changed.")),g.update(s=>(s.reset(),s.setInInstance(t),d.save(),s))}function q(){if(e().inInstance){const t=new Ge(e().inInstance),{outInstance:s,steps:l}=t.reduce();g.update(a=>(a.setSteps(l),a.setOutInstance(s),d.save(),a))}}async function B(){let{inCert:t,outInstance:s,outCert:l}=e();if(!(!s||l)){P(p,!0),P(C,"Solving TSP..."),o&&(o.terminate(),o=null);try{const a=new Worker(new URL(""+new URL("../workers/WorkerTSPSolver-BcVBw9a7.js",import.meta.url).href,import.meta.url),{type:"module"});o=a;const A=new Promise((h,k)=>{a.onmessage=u=>{a===o&&(a.terminate(),o=null,h(u.data))},a.onerror=u=>{a===o&&(a.terminate(),o=null,k(u))}});if(a.postMessage(s.toSerializedString()),l=await A,!o&&!r(p))return;if(l==G)g.update(h=>(h.inCert=G,h.outCert=G,h));else{const h=s,k=l.path;h.edges.forEach(i=>i.classes+=" solved");const u=i=>i.slice(i.search(Ee)+1);for(let i=0;i<k.length-1;i++){const H=u(k[i].id),F=u(k[i+1].id),c=te+`${H}-${F}`,O=h.edges.find(V=>V.id==c);O&&(h.removeEdge(O),O.classes+=" used",h.addEdge(O))}t=new ze().decode(h,l),g.update(i=>(i.inCert=t,i.outCert=l,i.outInstance=h,i))}d.save()}catch(a){console.error("Error during solving:",a),P(C,"An error occurred while solving.")}finally{P(p,!1),P(C,""),o=null}}}Ie(()=>{g.update(t=>(t.resetStepIndex(),t))}),fe(()=>{o&&(o.terminate(),o=null)});var w=Je();_e(t=>{var s=Xe();Se.title="HCIRCUIT to TSP",v(t,s)});var E=I(b(w),2);Pe(E,{get graph(){return e().inInstance},onChange:t=>M(t),onWrongFormat:t=>alert("From graph editor: "+t)});var N=I(E,2),$=b(N);$.__click=q;var T=I($,2);T.__click=[qe,B];var L=b(T);{var j=t=>{var s=J("Solving...");v(t,s)},K=t=>{var s=J("Solve");v(t,s)};y(L,t=>{r(p)?t(j):t(K,!1)})}_(T);var ne=I(T,2);de(ne),ee(2),_(N);var se=I(N,2);{var pe=t=>{Re(t,{children:(s,l)=>{ee();var a=J();X(()=>Y(a,r(C))),v(s,a)}})};y(se,t=>{r(p)&&t(pe)})}var he=I(se,2);{var ue=t=>{const s=ae(()=>e().steps),l=ae(()=>e().stepIndex);var a=Ce(),A=Z(a);{var h=u=>{var D=Be(),i=Z(D),H=b(i);{var F=S=>{W(S,{get graph(){return r(s)[r(l)].inSnapshot},style:"UNDIRECTED",layout:"circle"})};y(H,S=>{r(l)<r(s).length&&r(s)[r(l)].inSnapshot&&!r(s)[r(l)].inSnapshot.empty()&&S(F)})}_(i);var c=I(i,2);ke(c,{get steps(){return e().steps},get stepIndex(){return e().stepIndex},onPrevClick:()=>{g.update(S=>(S.prevStep(),S)),d.save()},onNextClick:()=>{g.update(S=>(S.nextStep(),S)),d.save()}});var O=I(c,2),V=b(O);{var ge=S=>{W(S,{get graph(){return e().steps[e().stepIndex].outSnapshot},style:"TSP",layout:"circle"})};y(V,S=>{e().stepIndex<e().steps.length&&e().steps[e().stepIndex].outSnapshot&&S(ge)})}_(O),v(u,D)},k=u=>{var D=Ke();v(u,D)};y(A,u=>{r(s).length?u(h):u(k,!1)})}v(t,a)},ve=t=>{var s=Ve(),l=b(s),a=b(l);{var A=c=>{W(c,{get graph(){return e().inInstance},style:"UNDIRECTED",layout:"circle"})};y(a,c=>{e().inInstance&&!e().inInstance.empty()&&c(A)})}var h=I(a,2);{var k=c=>{De(c,{get cert(){return e().inCert}})};y(h,c=>{e().inCert&&c(k)})}_(l);var u=I(l,2),D=b(u);{var i=c=>{W(c,{get graph(){return e().outInstance},style:"TSP",layout:"circle"})};y(D,c=>{e().outInstance&&!e().outInstance.empty()&&c(i)})}var H=I(D,2);{var F=c=>{je(c,{get cert(){return e().outCert}})};y(H,c=>{e().outCert&&c(F)})}_(u),_(s),v(t,s)};y(he,t=>{r(f)?t(ue):t(ve,!1)})}_(w),X((t,s)=>{$.disabled=t,T.disabled=s},[()=>!e().hasInInstance()||e().hasOutInstance()||r(p),()=>!e().hasInstances()||e().hasOutCertificate()||r(p)]),le(ne,()=>r(f),t=>P(f,t)),v(U,w),ce(),R()}me(["click"]);export{rt as component,ot as universal};
