import"../chunks/DsnmJJEf.js";import{s as ee,d as ce,o as Ce,b as Se}from"../chunks/Bo11bpx7.js";import{p as te,f as w,s as C,d as y,r as E,b as S,c as ne,t as K,E as c,am as W,ac as Ee,z as de,a6 as b,ar as xe,v as Re,$ as ye,w as re,aq as V,ao as be,a as oe,ap as ie}from"../chunks/PeP0X5zg.js";import{i as D,s as De,a as we}from"../chunks/CUh4lIsF.js";import{l as Pe,r as Te}from"../chunks/ClOwQNov.js";import{U as q,e as le,i as pe,D as Ne,G as Z,b as ke,a as He,N as O,c as U,d as M,f as I,C as Oe,E as $,u as Ue,R as Me,g as $e,P as Le,S as Fe,h as je,j as z,k as Ge}from"../chunks/0vJgUQ3d.js";const Ye=!0,ut=Object.freeze(Object.defineProperty({__proto__:null,prerender:Ye},Symbol.toStringTag,{value:"Module"}));var Xe=w("<p>The graph doesn't contain a Hamiltonian circuit.</p>"),Ae=w("<li> </li>"),We=w("<ul></ul>"),ze=w("<main><h2>CertRenderer HCIRCUIT</h2> <!></main>");function qe(P,n){te(n,!0);var e=ze(),r=C(y(e),2);{var i=s=>{var v=Xe();S(s,v)},a=s=>{var v=We();le(v,21,()=>n.cert.path,pe,(h,x)=>{var d=Ae(),_=y(d,!0);E(d),K(()=>ee(_,c(x).id)),S(h,d)}),E(v),S(s,v)};D(r,s=>{n.cert==q?s(i):s(a,!1)})}E(e),S(P,e),ne()}function Ke(P,n,e,r,i){b(n,e[c(r)],!0),i()}var Be=w("<option> </option>"),Je=w('<main class="graph-editor"><h2>Graph Editor</h2> <textarea class="svelte-9bcj7i"></textarea> <select><option>--Choose a demo--</option><!></select></main>');function Qe(P,n){te(n,!0);let e=W(Ee(n.graph?.asString()??""));Ce(()=>{console.debug("editor text:",n.graph?.asString(),c(e))});let r=W("");const i=Ne.getTextInputs(Z);function a(){const _=Z.fromString(c(e));if(typeof _=="string"){n.onWrongFormat(_);return}n.onChange(_)}de(()=>{n.graph&&b(e,n.graph.asString(),!0)});var s=Je(),v=C(y(s),2);xe(v),v.__change=a;var h=C(v,2);h.__change=[Ke,e,i,r,a];var x=y(h);x.value=x.__value="";var d=C(x);le(d,17,()=>Object.keys(i),pe,(_,L)=>{var k=Be(),F=y(k,!0);E(k);var j={};K(()=>{ee(F,c(L)),j!==(j=c(L))&&(k.value=(k.__value=c(L))??"")}),S(_,k)}),E(h),E(s),ke(v,()=>c(e),_=>b(e,_)),He(h,()=>c(r),_=>b(r,_)),S(P,s),ne()}ce(["change"]);class Ve{decode(n,e){console.debug(e.path);const r=new Array;e.path.forEach(s=>{const v=s.id.lastIndexOf(O),h=s.id.lastIndexOf(U),x=s.id.lastIndexOf(M),d=Math.max(v,h,x),_=s.id.slice(I.length,d);r.push(_)});const i=new Array;let a;for(let s=0;s<r.length;s++)a!=r[s]&&(a=r[s],i.push({id:I+a}));return new Oe(i)}}class Ze{inInstance;nodeDist=80;tripletDist=6*this.nodeDist;nodeCount;circum;radius;radStep;startRot;constructor(n){if(n.empty())throw new Error("Reducer doesn't accept empty graphs (Graph with node nodes).");this.inInstance=n,this.nodeCount=n.nodes.length,this.circum=this.tripletDist*this.nodeCount,this.radius=this.circum/(2*Math.PI),this.radStep=2*Math.PI/this.nodeCount,this.startRot=.5*Math.PI}reduce(){const n=[],e=this.createNodeTriplets();n.push(...e.steps);const r=this.connectEdges(e.graph.copy());return n.push(...r.steps),{outInstance:r.graph,steps:n}}stripPrefix(n,e){return n.slice(e.length)}connectEdges(n){const e=[];return this.inInstance.edges.forEach(r=>{const i=r.from.slice(I.length)+M,a=r.to.slice(I.length)+O;n.addEdge({id:$+`${i}-${a}`,from:I+i,to:I+a})}),e.push({id:"connect-edges",title:"Connect edges",description:`
                <p> 
                    For every original edge from node <i>a</i> to node <i>b</i>,
                    connect the node <i>a_out</i> with the node <i>b_in</i>.
                </p>
                <p>
                    In this particular case, add these edges:
                    <ul>
                        ${this.inInstance.edges.map(r=>{const i=this.stripPrefix(r.from,$)+M,a=this.stripPrefix(r.to,$)+O;return`
                                <li> 
                                    (${i}, ${a})
                                </li>
                            `}).join("")}
                    </ul>
                </p>
            `,inSnapshot:this.inInstance.copy(),outSnapshot:n.copy(),mapping:{}}),{graph:n,steps:e}}createNodeTriplets(){const n=[],e=new Z;return this.inInstance.nodes.forEach((r,i)=>{const a=r.id.slice(I.length),s={x:this.radius*Math.cos(i*this.radStep-this.startRot-.2*this.radStep),y:this.radius*Math.sin(i*this.radStep-this.startRot-.2*this.radStep)},v={x:this.radius*Math.cos(i*this.radStep-this.startRot),y:this.radius*Math.sin(i*this.radStep-this.startRot)},h={x:this.radius*Math.cos(i*this.radStep-this.startRot+.2*this.radStep),y:this.radius*Math.sin(i*this.radStep-this.startRot+.2*this.radStep)};e.addNode({id:I+a+O,position:s,classes:r.classes}),e.addNode({id:I+a+U,position:v,classes:r.classes}),e.addNode({id:I+a+M,position:h,classes:r.classes}),e.addEdge({id:$+`${a}${O}-${a}${U}`,from:I+a+O,to:I+a+U}),e.addEdge({id:$+`${a}${M}-${a}${U}`,from:I+a+M,to:I+a+U})}),n.push({id:"create-node-triplets",title:"Create node triplets",description:`
                <p> 
                    For each node in the original graph,
                    create three nodes that represent:
                    <ul>
                        <li>
                            an in-coming node
                        </li>
                        <li>
                            a gap node
                        </li>
                        <li>
                            and an out-going node
                        </li>
                    </ul>
                </p>
                <p>
                    Connect the in-coming node with the gap-node and the gap-node with the out-going node.
                </p>
                <p>
                    For this particular graph there will be ${this.nodeCount} node ${this.nodeCount==1?"triplet":"triplets"}.
                    ${this.nodeCount==1?"The triplet is:":"The triplets are:"}
                    <ul>  
                        ${this.inInstance.nodes.map(r=>{const i=r.id.slice(I.length);return`
                                <li>
                                    ${i} - (${i+O}, ${i+U}, ${i+M})
                                </li>
                            `}).join("")}
                    </ul>
                </p>
            `,inSnapshot:this.inInstance.copy(),outSnapshot:e.copy(),mapping:{}}),{graph:e,steps:n}}}var et=w('<meta name="description" content="Reduction from HCYCLE to HCIRCUIT"/>'),tt=(P,n)=>n(),nt=w("<div><!></div> <!> <div><!></div>",1),at=w("<span>There are no steps to step through.</span>"),st=w('<div class="panes"><div><!> <!></div> <div><!> <!></div></div>'),rt=w('<main><h1>HCYCLE to HCIRCUIT reduction</h1> <p class="reminder"><i>Removes duplicate entires automatically</i></p> <!> <div class="controls"><button>Reduce</button> <button><!></button> <input type="checkbox" name="showStepperCheckbox"/> <label for="showStepperCheckbox">Show steps</label></div> <!> <!></main>');function ht(P,n){te(n,!0);const e=()=>De(s,"$redStore",r),[r,i]=we();let a=Ue(Pe.LS_HCYCLE_HCIRCUIT,new Me),s=a.value;console.debug("input instance:",e().inInstance);let v=W(!1),h=W(!1),x=W(""),d=null;function _(t){console.debug("onEditorChange"),d&&(d.terminate(),d=null,b(h,!1),b(x,"Solving cancelled â€” formula changed.")),s.update(o=>(o.reset(),o.setInInstance(t),o)),a.save()}function L(){if(e().inInstance){const t=new Ze(e().inInstance),{outInstance:o,steps:g}=t.reduce();console.debug(o),s.update(l=>(l.setSteps(g),l.setOutInstance(o),l)),console.debug(e()),a.save()}}async function k(){let{inCert:t,outInstance:o,outCert:g}=e();if(!(!o||g)){b(h,!0),b(x,"Solving Hamiltonian circuit..."),d&&(d.terminate(),d=null);try{const l=new Worker(new URL(""+new URL("../workers/WorkerHCIRCUITSolver-DanNj_pj.js",import.meta.url).href,import.meta.url),{type:"module"});d=l;const Y=new Promise((m,T)=>{l.onmessage=f=>{l===d&&(l.terminate(),d=null,m(f.data))},l.onerror=f=>{l===d&&(l.terminate(),d=null,T(f))}});if(l.postMessage(o.toSerializedString()),g=await Y,!d&&!c(h))return;if(g==q)s.update(m=>(m.inCert=q,m.outCert=q,m));else{const m=o,T=g.path;m.edges.forEach(p=>p.classes+=" solved");const f=p=>p.slice(p.search(Le)+1);for(let p=0;p<T.length-1;p++){const X=f(T[p].id),A=f(T[p+1].id),u=$+`${X}-${A}`,H=m.edges.find(Q=>Q.id==u);H&&(m.removeEdge(H),H.classes+=" used",m.addEdge(H))}t=new Ve().decode(m,g),s.update(p=>(p.inCert=t,p.outCert=g,p.outInstance=m,p))}a.save()}catch(l){console.error("Error during solving:",l),b(x,"An error occurred while solving.")}finally{b(h,!1),b(x,""),d=null}}}de(()=>{s.update(t=>(t.resetStepIndex(),t))}),Se(()=>{d&&(d.terminate(),d=null)});var F=rt();Re(t=>{var o=et();ye.title="HCYCLE to HCIRCUIT",S(t,o)});var j=C(y(F),4);Qe(j,{get graph(){return e().inInstance},onChange:t=>_(t),onWrongFormat:t=>alert("From graph editor: "+t)});var B=C(j,2),J=y(B);J.__click=L;var G=C(J,2);G.__click=[tt,k];var ue=y(G);{var he=t=>{var o=V("Solving...");S(t,o)},ve=t=>{var o=V("Solve");S(t,o)};D(ue,t=>{c(h)?t(he):t(ve,!1)})}E(G);var ae=C(G,2);Te(ae),re(2),E(B);var se=C(B,2);{var ge=t=>{Fe(t,{children:(o,g)=>{re();var l=V();K(()=>ee(l,c(x))),S(o,l)}})};D(se,t=>{c(h)&&t(ge)})}var me=C(se,2);{var fe=t=>{const o=ie(()=>e().steps),g=ie(()=>e().stepIndex);var l=be(),Y=oe(l);{var m=f=>{var N=nt(),p=oe(N),X=y(p);{var A=R=>{z(R,{get graph(){return c(o)[c(g)].inSnapshot},style:"DIRECTED",layout:"circle"})};D(X,R=>{c(g)<c(o).length&&c(o)[c(g)].inSnapshot&&!c(o)[c(g)].inSnapshot.empty()&&R(A)})}E(p);var u=C(p,2);je(u,{get steps(){return e().steps},get stepIndex(){return e().stepIndex},onPrevClick:()=>{s.update(R=>(R.prevStep(),R)),a.save()},onNextClick:()=>{s.update(R=>(R.nextStep(),R)),a.save()}});var H=C(u,2),Q=y(H);{var Ie=R=>{z(R,{get graph(){return e().steps[e().stepIndex].outSnapshot},style:"UNDIRECTED",layout:"preset"})};D(Q,R=>{e().stepIndex<e().steps.length&&e().steps[e().stepIndex].outSnapshot&&R(Ie)})}E(H),S(f,N)},T=f=>{var N=at();S(f,N)};D(Y,f=>{c(o).length?f(m):f(T,!1)})}S(t,l)},_e=t=>{var o=st(),g=y(o),l=y(g);{var Y=u=>{z(u,{get graph(){return e().inInstance},style:"DIRECTED",layout:"circle"})};D(l,u=>{e().inInstance&&!e().inInstance.empty()&&u(Y)})}var m=C(l,2);{var T=u=>{Ge(u,{get cert(){return e().inCert}})};D(m,u=>{e().inCert&&u(T)})}E(g);var f=C(g,2),N=y(f);{var p=u=>{z(u,{get graph(){return e().outInstance},style:"UNDIRECTED",layout:"preset"})};D(N,u=>{e().outInstance&&!e().outInstance.empty()&&u(p)})}var X=C(N,2);{var A=u=>{qe(u,{get cert(){return e().outCert}})};D(X,u=>{e().outCert&&u(A)})}E(f),E(o),S(t,o)};D(me,t=>{c(v)?t(fe):t(_e,!1)})}E(F),K((t,o)=>{J.disabled=t,G.disabled=o},[()=>!e().hasInInstance()||e().hasOutInstance()||c(h),()=>!e().hasInstances()||e().hasOutCertificate()||c(h)]),$e(ae,()=>c(v),t=>b(v,t)),S(P,F),ne(),i()}ce(["click"]);export{ht as component,ut as universal};
