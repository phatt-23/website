import"../chunks/DsnmJJEf.js";import"../chunks/DVXSbgSC.js";import{p as de,f as b,s as l,d as m,r as g,b as i,c as pe,a as D,K as M,m as u,L as be,M as Se,t as H,J as fe,$ as _e,u as ne,am as $,an as ye,ac as ae}from"../chunks/0h0eovDe.js";import{s as Q,d as we}from"../chunks/BeBJMhcX.js";import{i as C,s as K,a as Ae,b as xe,c as Re}from"../chunks/E6MyXn9j.js";import{r as le,l as Te}from"../chunks/CSnGU0Cu.js";import{U as q,b as ge,e as oe,i as re,S as Be,R as Ee,E as ie,u as Ze,a as Ue,c as Fe,d as Ge,f as ze}from"../chunks/DCk9rHG9.js";import{i as Ne}from"../chunks/DaAev7kg.js";import{E as Pe,R as Xe,C as ke}from"../chunks/Bs7IJ1ml.js";import{h as Ke}from"../chunks/Bp5AzgID.js";import{R as j}from"../chunks/YqW4Rh_A.js";const He=!0,ut=Object.freeze(Object.defineProperty({__proto__:null,prerender:He},Symbol.toStringTag,{value:"Module"}));var Oe=b("<p>The graph doesn't contain a Hamiltonian cycle with the given cost.</p>"),Le=b("<li> </li>"),Ve=b("<ol></ol>"),We=b("<span><!> </span>"),Ye=b("<div></div>"),Je=b('<div class="controls"><input type="checkbox" name="showAsListCheckbox"/> <label for="showAsListCheckbox">Show as list</label></div> <!>',1),$e=b("<main><h2>CertRenderer TSP</h2> <!></main>");function je(_,s){de(s,!0);let e=be(!0);var a=$e(),c=l(m(a),2);{var o=I=>{var p=Oe();i(I,p)},h=I=>{var p=Je(),d=D(p),Z=m(d);le(Z),M(2),g(d);var X=l(d,2);{var O=y=>{var A=Ve();oe(A,21,()=>s.cert.path,re,(F,z)=>{var x=Le(),R=m(x,!0);g(x),H(()=>Q(R,u(z).id)),i(F,x)}),g(A),i(y,A)},L=y=>{var A=Ye();oe(A,21,()=>s.cert.path,re,(F,z,x)=>{var R=We(),U=m(R);Ke(U,()=>x!=0?"&ThinSpace;&LongRightArrow;&ThinSpace;":"");var V=l(U);g(R),H(()=>Q(V,` ${u(z).id??""}`)),i(F,R)}),g(A),i(y,A)};C(X,y=>{u(e)?y(O):y(L,!1)})}ge(Z,()=>u(e),y=>Se(e,y)),i(I,p)};C(c,I=>{s.cert==q?I(o):I(h,!1)})}g(a),i(_,a),pe()}var De=Object.getOwnPropertyDescriptor,Me=(_,s,e,a)=>{for(var c=a>1?void 0:a?De(s,e):s,o=_.length-1,h;o>=0;o--)(h=_[o])&&(c=h(c)||c);return c};let ee=class{path;constructor(_){this.path=_}};ee=Me([Be.SerializableClass()],ee);class ce{decode(s,e){return new ee(e.path)}}class Qe extends Ee{nodeCount;constructor(s){super(s),this.nodeCount=this.inInstance.nodes.length}copyOver(s){const e=[];return e.push({id:"copy-over",title:"Copy over the original graph",description:"",mapping:{},inSnapshot:this.inInstance.copy(),outSnapshot:s}),{graph:s,steps:e}}assignWeightsToExisting(s){const e=[];return s.edges.forEach(a=>{a.weight=1,a.classes+=" solid"}),e.push({id:"assign-weight-1",title:"Assign weights to existing edges",description:`
                <p>
                    For each edge that was in the original graph now assign the weight 1.
                </p>
            `,mapping:{},inSnapshot:this.inInstance.copy(),outSnapshot:s}),{graph:s,steps:e}}addMissingEdges(s){const e=[],a=new Set(this.inInstance.edges.map(o=>o.id));console.debug("idgeIds.values()",[...a.values()]);const c=this.inInstance.nodes.map(o=>(s.addNode(o),o.id));for(let o=0;o<s.nodes.length;o++)for(let h=o+1;h<s.nodes.length;h++){const I=c[o],p=c[h],d=ie+`${I}-${p}`,Z=ie+`${p}-${I}`,X=a.has(d)||a.has(Z);console.debug("check existence of",d,Z),X||s.addEdge({id:d,from:I,to:p,weight:2,classes:"muted"})}return e.push({id:"add-missing-edges",title:"Add missing edges",description:`
                <p>
                    Connect all the nodes that weren't connect before by a new edge and assign a weight of 2 to this new edge.
                </p>
            `,mapping:{},inSnapshot:this.inInstance.copy(),outSnapshot:s}),{graph:s,steps:e}}doReduce(){const s=[];s.push({id:"reduce-hcircuit-to-tsp-1",title:"Create complete graph",description:`
                <p> 
                    Take all of the nodes from the original graph and add an edge between each of them (make a complete graph).
                    For every edge that exists in the original instance, assign a weight of 1.
                    Otherwise assign some weight larger than 1.
                </p>
                <p>
                    There is ${this.nodeCount} nodes, 
                    which means there will be (${this.nodeCount} * ${this.nodeCount-1}) / 2 = ${this.nodeCount*(this.nodeCount-1)/2} edges, 
                    for it to be complete.
                </p>
                <p>
                    Now this problem can expressed by a decision question:
                    Is there a hamiltonian cycle such that the cost of the traversal is less than or equal to ${this.nodeCount}?
                </p>
            `,inSnapshot:this.inInstance.copy(),mapping:{}});const e=this.copyOver(this.inInstance.copy());s.push(...e.steps);const a=this.assignWeightsToExisting(e.graph.copy());s.push(...a.steps);const c=this.addMissingEdges(a.graph.copy());return s.push(...c.steps),{outInstance:c.graph,steps:s}}}var qe=b('<meta name="description" content="Reduction from HCIRCUIT to TSP"/>'),et=b("<div><!></div> <!> <div><!></div>",1),tt=b("<span>There are no steps to step through.</span>"),st=b('<div class="panes"><div><!> <!></div> <div><!> <!></div></div>'),nt=b('<main><h1>HCIRCUIT to TSP reduction</h1> <!> <div class="controls"><button>Reduce</button> <button><!></button> <input type="checkbox" name="showStepperCheckbox"/> <label for="showStepperCheckbox">Show steps</label></div> <!> <!></main>');function It(_,s){de(s,!1);const e=()=>K(d,"$redStore",h),a=()=>K(X,"$isSolving",h),c=()=>K(Z,"$showStepper",h),o=()=>K(O,"$solveMessage",h),[h,I]=Ae();let p=Ze(Te.LS_HCIRCUIT_TSP,new Ue),{redStore:d,showStepper:Z,isSolving:X,solveMessage:O,editorChanged:L,reduce:y,solve:A}=Fe({storage:p,workerUrl:new URL("data:video/mp2t;base64,Ly8gQ3JlYXRlZCBieSBwaGF0dC0yMyBvbiAyMS8xMC8yMDI1CgppbXBvcnQgeyBVbnNvbHZhYmxlIH0gZnJvbSAiJGxpYi9jb3JlL1Vuc29sdmFibGUiOwppbXBvcnQgeyBHcmFwaCB9IGZyb20gIiRsaWIvaW5zdGFuY2UvR3JhcGgiOwppbXBvcnQgeyBTb2x2ZXJUU1AgfSBmcm9tICIkbGliL3NvbHZlL1NvbHZlclRTUCI7CgpzZWxmLm9ubWVzc2FnZSA9IGFzeW5jIChlKSA9PiB7CiAgICBjb25zb2xlLmRlYnVnKCdXb3JrZXJUU1BTb2x2ZXI6Om9ubWVzc2FnZScpOwoKICAgIHRyeSB7CiAgICAgICAgY29uc3Qgc2VyaWFsaXplZEdyYXBoOiBzdHJpbmcgPSBlLmRhdGEuZ3JhcGg7CiAgICAgICAgY29uc3QgbWF4Q29zdDogbnVtYmVyID0gZS5kYXRhLm1heENvc3Q7CgogICAgICAgIGNvbnNvbGUuZGVidWcoc2VyaWFsaXplZEdyYXBoKTsKICAgICAgICBjb25zb2xlLmRlYnVnKG1heENvc3QpOwoKICAgICAgICBjb25zdCBpbnN0YW5jZTogR3JhcGggPSBHcmFwaC5mcm9tU2VyaWFsaXplZFN0cmluZyhzZXJpYWxpemVkR3JhcGgpOwoKICAgICAgICBjb25zdCBzb2x2ZXIgPSBuZXcgU29sdmVyVFNQKGluc3RhbmNlLCBtYXhDb3N0KTsKICAgICAgICBjb25zdCByZXN1bHQgPSBzb2x2ZXIuc29sdmUoKTsKCiAgICAgICAgcG9zdE1lc3NhZ2UocmVzdWx0IHx8IFVuc29sdmFibGUpOwogICAgfQogICAgY2F0Y2ggKGUpIHsKICAgICAgICBwb3N0TWVzc2FnZSh7CiAgICAgICAgICAgIGVycm9yOiB0cnVlLAogICAgICAgICAgICBtZXNzYWdlOiBlIGluc3RhbmNlb2YgRXJyb3IgPyBlLm1lc3NhZ2UgOiBTdHJpbmcoZSkKICAgICAgICB9KTsKICAgIH0KfTsK",import.meta.url),createWorkerMessage:t=>({graph:t.toSerializedString(),maxCost:t.nodes.length}),reducerFactory:t=>new Qe(t),decoderFactory:()=>new ce,onSolveFinished:(t,n)=>{if(n==q){Re(d,ne(e).inCert=q,ne(e));return}const S=new ce().decode(t,n),N=e().inInstance;N.labelSolved({path:S.path,directed:!1}),t.labelSolved({path:n.path,directed:!1}),d.update(T=>(T.inInstance=N,T.inCert=S,T.outCert=n,T.outInstance=t,T))}});Ne();var F=nt();fe(t=>{var n=qe();_e.title="HCIRCUIT to TSP",i(t,n)});var z=l(m(F),2);Pe(z,{get graph(){return e().inInstance},onChange:t=>L(t),onWrongFormat:t=>alert("From graph editor: "+t)});var x=l(z,2),R=m(x);R.__click=y;var U=l(R,2);U.__click=A;var V=m(U);{var he=t=>{var n=$("Solving...");i(t,n)},ve=t=>{var n=$("Solve");i(t,n)};C(V,t=>{a()?t(he):t(ve,!1)})}g(U);var te=l(U,2);le(te),M(2),g(x);var se=l(x,2);{var ue=t=>{Ge(t,{children:(n,w)=>{M();var S=$();H(()=>Q(S,o())),i(n,S)}})};C(se,t=>{a()&&t(ue)})}var Ie=l(se,2);{var Ce=t=>{const n=ae(()=>e().steps),w=ae(()=>e().stepIndex);var S=ye(),N=D(S);{var T=B=>{var G=et(),k=D(G),Y=m(k);{var J=v=>{j(v,{get graph(){return u(n)[u(w)].inSnapshot},style:"UNDIRECTED",layout:"circle"})};C(Y,v=>{u(w)<u(n).length&&u(n)[u(w)].inSnapshot&&!u(n)[u(w)].inSnapshot.isEmpty()&&v(J)})}g(k);var r=l(k,2);ze(r,{get steps(){return e().steps},get stepIndex(){return e().stepIndex},onPrevClick:()=>{d.update(v=>(v.prevStep(),v)),p.save()},onNextClick:()=>{d.update(v=>(v.nextStep(),v)),p.save()}});var P=l(r,2),f=m(P);{var E=v=>{j(v,{get graph(){return e().steps[e().stepIndex].outSnapshot},style:"TSP",layout:"circle"})};C(f,v=>{e().stepIndex<e().steps.length&&e().steps[e().stepIndex].outSnapshot&&v(E)})}g(P),i(B,G)},W=B=>{var G=tt();i(B,G)};C(N,B=>{u(n).length?B(T):B(W,!1)})}i(t,S)},me=t=>{var n=st(),w=m(n),S=m(w);{var N=r=>{Xe(r,{get graph(){return e().inInstance},style:"UNDIRECTED",layout:"circle",onAddEdge:P=>{d.update(f=>{let E=f.inInstance;return E.addEdge(P),E.unlabelSolved(),f.reset(),f.setInInstance(E),f}),p.save()},onRemoveEdge:P=>{d.update(f=>{let E=f.inInstance;return E.removeEdgeById(P.id()),E.unlabelSolved(),f.reset(),f.setInInstance(E),f}),p.save()}})};C(S,r=>{e().inInstance&&!e().inInstance.isEmpty()&&r(N)})}var T=l(S,2);{var W=r=>{ke(r,{get cert(){return e().inCert}})};C(T,r=>{e().inCert&&r(W)})}g(w);var B=l(w,2),G=m(B);{var k=r=>{j(r,{get graph(){return e().outInstance},style:"TSP",layout:"circle"})};C(G,r=>{e().outInstance&&!e().outInstance.isEmpty()&&r(k)})}var Y=l(G,2);{var J=r=>{je(r,{get cert(){return e().outCert}})};C(Y,r=>{e().outCert&&r(J)})}g(B),g(n),i(t,n)};C(Ie,t=>{c()?t(Ce):t(me,!1)})}g(F),H((t,n)=>{R.disabled=t,U.disabled=n},[()=>!e().hasInInstance()||e().hasOutInstance()||a(),()=>!e().hasInstances()||e().hasOutCertificate()||a()]),ge(te,c,t=>xe(Z,t)),i(_,F),pe(),I()}we(["click"]);export{It as component,ut as universal};
