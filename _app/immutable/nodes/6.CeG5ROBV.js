import"../chunks/DsnmJJEf.js";import"../chunks/7c8ahxPy.js";import{p as ce,f as I,s as l,d as S,r as h,b as i,c as pe,a as V,K as Y,m as g,L as Se,M as Ie,t as j,J as Ce,$ as be,u as ne,an as X,ao as we,ac as ae}from"../chunks/BHy43uIv.js";import{s as Z,d as ye}from"../chunks/Bo-e_C1i.js";import{i as _,s as A,a as xe,b as Re,c as Te}from"../chunks/lPMcd3W4.js";import{r as le,l as Ee}from"../chunks/hAUU4et8.js";import{U as ee,b as he,e as oe,i as re,S as ke,R as Pe,E as ie,u as $e,l as Ue,m as We,n as Fe,W as Oe,o as De,p as Le}from"../chunks/4Tn6J3At.js";import{i as He}from"../chunks/Bic1S2_H.js";import{E as Me,R as Ae,C as je}from"../chunks/CoHqDsmR.js";import{h as Ne}from"../chunks/_9mKL30m.js";import{R as Q}from"../chunks/eBivCHW5.js";const qe=!0,_t=Object.freeze(Object.defineProperty({__proto__:null,prerender:qe},Symbol.toStringTag,{value:"Module"}));var ze=I("<p>The graph doesn't contain a Hamiltonian cycle with the given cost.</p>"),Ge=I("<li> </li>"),Be=I("<ol></ol>"),Je=I("<span><!> </span>"),Ke=I("<div></div>"),Xe=I('<div class="controls"><input type="checkbox" name="showAsListCheckbox"/> <label for="showAsListCheckbox">Show as list</label></div> <!>',1),Qe=I("<main><h2>CertRenderer TSP</h2> <!></main>");function Ve(m,s){ce(s,!0);let e=Se(!0);var a=Qe(),d=l(S(a),2);{var o=f=>{var p=ze();i(f,p)},v=f=>{var p=Xe(),c=V(p),$=S(c);le($),Y(2),h(c);var H=l(c,2);{var q=w=>{var x=Be();oe(x,21,()=>s.cert.path,re,(W,O)=>{var R=Ge(),T=S(R,!0);h(R),j(()=>Z(T,g(O).id)),i(W,R)}),h(x),i(w,x)},z=w=>{var x=Ke();oe(x,21,()=>s.cert.path,re,(W,O,R)=>{var T=Je(),U=S(T);Ne(U,()=>R!=0?"&ThinSpace;&LongRightArrow;&ThinSpace;":"");var G=l(U);h(T),j(()=>Z(G,` ${g(O).id??""}`)),i(W,T)}),h(x),i(w,x)};_(H,w=>{g(e)?w(q):w(z,!1)})}he($,()=>g(e),w=>Ie(e,w)),i(f,p)};_(d,f=>{s.cert==ee?f(o):f(v,!1)})}h(a),i(m,a),pe()}var Ye=Object.getOwnPropertyDescriptor,Ze=(m,s,e,a)=>{for(var d=a>1?void 0:a?Ye(s,e):s,o=m.length-1,v;o>=0;o--)(v=m[o])&&(d=v(d)||d);return d};let N=class{path;constructor(m){this.path=m}};N=Ze([ke.SerializableClass()],N);class de{decode(s,e){return new N(e.path)}}class et extends Pe{nodeCount;constructor(s){super(s),this.nodeCount=this.inInstance.nodes.length}copyOver(s){const e=[];return e.push({id:"copy-over",title:"Copy over the original graph",description:"",mapping:{},inSnapshot:this.inInstance.copy(),outSnapshot:s}),{graph:s,steps:e}}assignWeightsToExisting(s){const e=[];return s.edges.forEach(a=>{a.weight=1,a.classes+=" solid"}),e.push({id:"assign-weight-1",title:"Assign weights to existing edges",description:`
                <p>
                    For each edge that was in the original graph now assign the weight 1.
                </p>
            `,mapping:{},inSnapshot:this.inInstance.copy(),outSnapshot:s}),{graph:s,steps:e}}addMissingEdges(s){const e=[],a=new Set(this.inInstance.edges.map(o=>o.id));console.debug("idgeIds.values()",[...a.values()]);const d=this.inInstance.nodes.map(o=>(s.addNode(o),o.id));for(let o=0;o<s.nodes.length;o++)for(let v=o+1;v<s.nodes.length;v++){const f=d[o],p=d[v],c=ie+`${f}-${p}`,$=ie+`${p}-${f}`,H=a.has(c)||a.has($);console.debug("check existence of",c,$),H||s.addEdge({id:c,from:f,to:p,weight:2,classes:"muted"})}return e.push({id:"add-missing-edges",title:"Add missing edges",description:`
                <p>
                    Connect all the nodes that weren't connect before by a new edge and assign a weight of 2 to this new edge.
                </p>
            `,mapping:{},inSnapshot:this.inInstance.copy(),outSnapshot:s}),{graph:s,steps:e}}doReduce(){const s=[];s.push({id:"reduce-hcircuit-to-tsp-1",title:"Create complete graph",description:`
                <p> 
                    Take all of the nodes from the original graph and add an edge between each of them (make a complete graph).
                    For every edge that exists in the original instance, assign a weight of 1.
                    Otherwise assign some weight larger than 1.
                </p>
                <p>
                    There is ${this.nodeCount} nodes, 
                    which means there will be (${this.nodeCount} * ${this.nodeCount-1}) / 2 = ${this.nodeCount*(this.nodeCount-1)/2} edges, 
                    for it to be complete.
                </p>
                <p>
                    Now this problem can expressed by a decision question:
                    Is there a hamiltonian cycle such that the cost of the traversal is less than or equal to ${this.nodeCount}?
                </p>
            `,inSnapshot:this.inInstance.copy(),mapping:{}});const e=this.copyOver(this.inInstance.copy());s.push(...e.steps);const a=this.assignWeightsToExisting(e.graph.copy());s.push(...a.steps);const d=this.addMissingEdges(a.graph.copy());return s.push(...d.steps),{outInstance:d.graph,steps:s}}}function tt(m){return new Worker(""+new URL("../workers/WorkerTSPSolver-ByFdJdTp.js",import.meta.url).href,{name:m?.name})}var st=I('<meta name="description" content="Reduction from HCIRCUIT to TSP"/>'),nt=I("<div><!></div> <!> <div><!></div>",1),at=I("<span>There are no steps to step through.</span>"),ot=I('<div class="panes"><div><!> <!></div> <div><!> <!></div></div>'),rt=I('<main><h1>HCIRCUIT to TSP reduction</h1> <!> <div class="controls"><button>Reduce</button> <button><!></button> <input type="checkbox" name="showStepperCheckbox"/> <label for="showStepperCheckbox">Show steps</label></div> <!> <!></main>');function St(m,s){ce(s,!1);const e=()=>A(c,"$redStore",v),a=()=>A(H,"$isSolving",v),d=()=>A($,"$showStepper",v),o=()=>A(q,"$solveMessage",v),[v,f]=xe();let p=$e(Ee.LS_HCIRCUIT_TSP,new Ue),{redStore:c,showStepper:$,isSolving:H,solveMessage:q,editorChanged:z,reduce:w,solve:x}=We({storage:p,workerFactory:()=>new tt,reducerFactory:t=>new et(t),decoderFactory:()=>new de,createWorkerRequest:t=>({graph:t.toSerializedString(),maxCost:t.nodes.length}),resolveWorkerResponse:t=>{const n=t;return Fe(n.type==Oe.RESULT),new N(n.path)},onSolveFinished:(t,n)=>{if(n==ee){Te(c,ne(e).inCert=ee,ne(e));return}const C=new de().decode(t,n),D=e().inInstance;D.labelSolved({path:C.path,directed:!1}),t.labelSolved({path:n.path,directed:!1}),c.update(E=>(E.inInstance=D,E.inCert=C,E.outCert=n,E.outInstance=t,E))}});He();var W=rt();Ce(t=>{var n=st();be.title="HCIRCUIT to TSP",i(t,n)});var O=l(S(W),2);Me(O,{get graph(){return e().inInstance},onChange:t=>z(t),onWrongFormat:t=>alert("From graph editor: "+t)});var R=l(O,2),T=S(R);T.__click=w;var U=l(T,2);U.__click=x;var G=S(U);{var ve=t=>{var n=X("Solving...");i(t,n)},ue=t=>{var n=X("Solve");i(t,n)};_(G,t=>{a()?t(ve):t(ue,!1)})}h(U);var te=l(U,2);le(te),Y(2),h(R);var se=l(R,2);{var ge=t=>{De(t,{children:(n,y)=>{Y();var C=X();j(()=>Z(C,o())),i(n,C)}})};_(se,t=>{a()&&t(ge)})}var me=l(se,2);{var fe=t=>{const n=ae(()=>e().steps),y=ae(()=>e().stepIndex);var C=we(),D=V(C);{var E=k=>{var F=nt(),M=V(F),J=S(M);{var K=u=>{Q(u,{get graph(){return g(n)[g(y)].inSnapshot},style:"UNDIRECTED",layout:"circle"})};_(J,u=>{g(y)<g(n).length&&g(n)[g(y)].inSnapshot&&!g(n)[g(y)].inSnapshot.isEmpty()&&u(K)})}h(M);var r=l(M,2);Le(r,{get steps(){return e().steps},get stepIndex(){return e().stepIndex},onPrevClick:()=>{c.update(u=>(u.prevStep(),u)),p.save()},onNextClick:()=>{c.update(u=>(u.nextStep(),u)),p.save()}});var L=l(r,2),b=S(L);{var P=u=>{Q(u,{get graph(){return e().steps[e().stepIndex].outSnapshot},style:"TSP",layout:"circle"})};_(b,u=>{e().stepIndex<e().steps.length&&e().steps[e().stepIndex].outSnapshot&&u(P)})}h(L),i(k,F)},B=k=>{var F=at();i(k,F)};_(D,k=>{g(n).length?k(E):k(B,!1)})}i(t,C)},_e=t=>{var n=ot(),y=S(n),C=S(y);{var D=r=>{Ae(r,{get graph(){return e().inInstance},style:"UNDIRECTED",layout:"circle",onAddEdge:L=>{c.update(b=>{let P=b.inInstance;return P.addEdge(L),P.unlabelSolved(),b.reset(),b.setInInstance(P),b}),p.save()},onRemoveEdge:L=>{c.update(b=>{let P=b.inInstance;return P.removeEdgeById(L.id()),P.unlabelSolved(),b.reset(),b.setInInstance(P),b}),p.save()}})};_(C,r=>{e().inInstance&&!e().inInstance.isEmpty()&&r(D)})}var E=l(C,2);{var B=r=>{je(r,{get cert(){return e().inCert}})};_(E,r=>{e().inCert&&r(B)})}h(y);var k=l(y,2),F=S(k);{var M=r=>{Q(r,{get graph(){return e().outInstance},style:"TSP",layout:"circle"})};_(F,r=>{e().outInstance&&!e().outInstance.isEmpty()&&r(M)})}var J=l(F,2);{var K=r=>{Ve(r,{get cert(){return e().outCert}})};_(J,r=>{e().outCert&&r(K)})}h(k),h(n),i(t,n)};_(me,t=>{d()?t(fe):t(_e,!1)})}h(W),j((t,n)=>{T.disabled=t,U.disabled=n},[()=>!e().hasInInstance()||e().hasOutInstance()||a(),()=>!e().hasInstances()||e().hasOutCertificate()||a()]),he(te,d,t=>Re($,t)),i(m,W),pe(),f()}ye(["click"]);export{St as component,_t as universal};
