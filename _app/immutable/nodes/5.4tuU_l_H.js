import"../chunks/DsnmJJEf.js";import{s as ee,d as fe,b as _e}from"../chunks/kmNpuAZe.js";import{p as de,f as E,s as C,d as T,r as w,b as m,c as le,a as te,A as ne,B as c,D as G,E as D,t as B,M as Ie,z as Se,$ as Ce,an as Z,ao as we,ap as re}from"../chunks/D1gJg5gW.js";import{i as x,s as be,a as ye}from"../chunks/ntNUJhCQ.js";import{r as pe,l as xe}from"../chunks/DnhBb1Nf.js";import{U as q,b as he,e as ie,i as ce,S as Te,g as X,E as K,u as Ee,R as Re,h as Pe,j as ke}from"../chunks/TWPTmQMR.js";import{E as De,C as Ue}from"../chunks/CUgJFBkp.js";import{h as Oe}from"../chunks/TRjCXhQC.js";import{R as z}from"../chunks/BVb8Xddv.js";const $e=!0,ct=Object.freeze(Object.defineProperty({__proto__:null,prerender:$e},Symbol.toStringTag,{value:"Module"}));var Ne=E("<p>The graph doesn't contain a Hamiltonian cycle.</p>"),Ae=E("<li> </li>"),He=E("<ol></ol>"),Le=E("<span><!> </span>"),Me=E("<div></div>"),je=E('<div class="controls"><input type="checkbox" name="showAsListCheckbox"/> <label for="showAsListCheckbox">Show as list</label></div> <!>',1),Fe=E("<main><h2>CertRenderer TSP</h2> <!></main>");function We(R,n){de(n,!0);let e=G(!0);var p=Fe(),_=C(T(p),2);{var a=I=>{var h=Ne();m(I,h)},d=I=>{var h=je(),b=te(h),r=T(b);pe(r),ne(2),w(b);var j=C(b,2);{var J=y=>{var k=He();ie(k,21,()=>n.cert.path,ce,(U,O)=>{var P=Ae(),$=T(P,!0);w(P),B(()=>ee($,c(O).id)),m(U,P)}),w(k),m(y,k)},Q=y=>{var k=Me();ie(k,21,()=>n.cert.path,ce,(U,O,P)=>{var $=Le(),F=T($);Oe(F,()=>P!=0?"&ThinSpace;&LongRightArrow;&ThinSpace;":"");var V=C(F);w($),B(()=>ee(V,` ${c(O).id??""}`)),m(U,$)}),w(k),m(y,k)};x(j,y=>{c(e)?y(J):y(Q,!1)})}he(r,()=>c(e),y=>D(e,y)),m(I,h)};x(_,I=>{n.cert==q?I(a):I(d,!1)})}w(p),m(R,p),le()}var ze=Object.getOwnPropertyDescriptor,Ge=(R,n,e,p)=>{for(var _=p>1?void 0:p?ze(n,e):n,a=R.length-1,d;a>=0;a--)(d=R[a])&&(_=d(_)||_);return _};let se=class{path;constructor(R){this.path=R}};se=Ge([Te.SerializableClass()],se);class qe{decode(n,e){return new se(e.path)}}class Xe{inInstance;nodeCount;constructor(n){this.inInstance=n,this.nodeCount=this.inInstance.nodes.length}copyOver(n){const e=[];return e.push({id:"copy-over",title:"Copy over the original graph",description:"",mapping:{},inSnapshot:this.inInstance.copy(),outSnapshot:n}),{graph:n,steps:e}}assignWeightsToExisting(n){const e=[];return n.edges.forEach(p=>{p.weight=1,p.classes+=" solid"}),e.push({id:"assign-weight-1",title:"Assign weights to existing edges",description:`
                <p>
                    For each edge that was in the original graph now assign the weight 1.
                </p>
            `,mapping:{},inSnapshot:this.inInstance.copy(),outSnapshot:n}),{graph:n,steps:e}}addMissingEdges(n){const e=[],p=new Set(this.inInstance.edges.map(a=>a.id)),_=this.inInstance.nodes.map(a=>(n.addNode(a),a.id.slice(X.length)));for(let a=0;a<n.nodes.length;a++)for(let d=a+1;d<n.nodes.length;d++){const I=_[a],h=_[d],b=K+`${I}-${h}`,r=K+`${h}-${I}`;p.has(b)||p.has(r)||n.addEdge({id:b,from:X+I,to:X+h,weight:2,classes:"muted"})}return e.push({id:"add-missing-edges",title:"Add missing edges",description:`
                <p>
                    Connect all the nodes that weren't connect before by a new edge and assign a weight of 2 to this new edge.
                </p>
            `,mapping:{},inSnapshot:this.inInstance.copy(),outSnapshot:n}),{graph:n,steps:e}}reduce(){const n=[];n.push({id:"reduce-hcircuit-to-tsp-1",title:"Create complete graph",description:`
                <p> 
                    Take all of the nodes from the original graph and add an edge between each of them (make a complete graph).
                    For every edge that exists in the original instance, assign a weight of 1.
                    Otherwise assign some weight larger than 1.
                </p>
                <p>
                    There is ${this.nodeCount} nodes, 
                    which means there will be (${this.nodeCount} * ${this.nodeCount-1}) / 2 = ${this.nodeCount*(this.nodeCount-1)/2} edges, 
                    for it to be complete.
                </p>
                <p>
                    Now this problem can expressed by a decision question:
                    Is there a hamiltonian cycle such that the cost of the traversal is less than or equal to ${this.nodeCount}?
                </p>
            `,inSnapshot:this.inInstance.copy(),mapping:{}});const e=this.copyOver(this.inInstance.copy());n.push(...e.steps);const p=this.assignWeightsToExisting(e.graph.copy());n.push(...p.steps);const _=this.addMissingEdges(p.graph.copy());return n.push(..._.steps),{outInstance:_.graph,steps:n}}}var Be=E('<meta name="description" content="Reduction from HCIRCUIT to TSP"/>'),Ke=(R,n)=>n(),Je=E("<div><!></div> <!> <div><!></div>",1),Qe=E("<span>There are no steps to step through.</span>"),Ve=E('<div class="panes"><div><!> <!></div> <div><!> <!></div></div>'),Ye=E('<main><h1>HCIRCUIT to TSP reduction</h1> <!> <div class="controls"><button>Reduce</button> <button><!></button> <input type="checkbox" name="showStepperCheckbox"/> <label for="showStepperCheckbox">Show steps</label></div> <!> <!></main>');function dt(R,n){de(n,!0);const e=()=>be(d,"$redStore",p),[p,_]=ye();let a=Ee(xe.LS_HCIRCUIT_TSP,new Re),d=a.value;console.debug("input instance:",e().inInstance);let I=G(!1),h=G(!1),b=G(""),r=null;function j(t){r&&(r.terminate(),r=null,D(h,!1),D(b,"Solving cancelled â€” formula changed.")),d.update(s=>(s.reset(),s.setInInstance(t),a.save(),s))}function J(){if(e().inInstance){const t=new Xe(e().inInstance),{outInstance:s,steps:l}=t.reduce();d.update(o=>(o.setSteps(l),o.setOutInstance(s),a.save(),o))}}async function Q(){let{inCert:t,outInstance:s,outCert:l}=e();if(!(!s||l)){D(h,!0),D(b,"Solving TSP..."),r&&(r.terminate(),r=null);try{const o=new Worker(new URL(""+new URL("../workers/WorkerTSPSolver-D5Ndv5U_.js",import.meta.url).href,import.meta.url),{type:"module"});r=o;const L=new Promise((v,f)=>{o.onmessage=S=>{o===r&&(o.terminate(),r=null,v(S.data))},o.onerror=S=>{o===r&&(o.terminate(),r=null,f(S))}}),M={graph:s.toSerializedString(),maxCost:s.nodes.length};if(o.postMessage(M),l=await L,!r&&!c(h))return;if(l==q)d.update(v=>(v.inCert=q,v.outCert=q,v));else{const v=s,f=l.path;v.edges.forEach(u=>u.classes+=" solved");const S=u=>u.slice(X.length);for(let u=0;u<f.length-1;u++){const A=S(f[u].id),i=S(f[u+1].id),W=K+`${A}-${i}`,Y=K+`${i}-${A}`,H=v.edges.find(g=>g.id==W||g.id==Y);H&&(v.removeEdge(H),H.classes+=" used",v.addEdge(H))}t=new qe().decode(v,l),d.update(u=>(u.inCert=t,u.outCert=l,u.outInstance=v,u))}a.save()}catch(o){console.error("Error during solving:",o),D(b,"An error occurred while solving.")}finally{D(h,!1),D(b,""),r=null}}}Ie(()=>{d.update(t=>(t.resetStepIndex(),t))}),_e(()=>{r&&(r.terminate(),r=null)});var y=Ye();Se(t=>{var s=Be();Ce.title="HCIRCUIT to TSP",m(t,s)});var k=C(T(y),2);De(k,{get graph(){return e().inInstance},onChange:t=>j(t),onWrongFormat:t=>alert("From graph editor: "+t)});var U=C(k,2),O=T(U);O.__click=J;var P=C(O,2);P.__click=[Ke,Q];var $=T(P);{var F=t=>{var s=Z("Solving...");m(t,s)},V=t=>{var s=Z("Solve");m(t,s)};x($,t=>{c(h)?t(F):t(V,!1)})}w(P);var ae=C(P,2);pe(ae),ne(2),w(U);var oe=C(U,2);{var ue=t=>{Pe(t,{children:(s,l)=>{ne();var o=Z();B(()=>ee(o,c(b))),m(s,o)}})};x(oe,t=>{c(h)&&t(ue)})}var ve=C(oe,2);{var ge=t=>{const s=re(()=>e().steps),l=re(()=>e().stepIndex);var o=we(),L=te(o);{var M=f=>{var S=Je(),N=te(S),u=T(N);{var A=g=>{z(g,{get graph(){return c(s)[c(l)].inSnapshot},style:"UNDIRECTED",layout:"circle"})};x(u,g=>{c(l)<c(s).length&&c(s)[c(l)].inSnapshot&&!c(s)[c(l)].inSnapshot.empty()&&g(A)})}w(N);var i=C(N,2);ke(i,{get steps(){return e().steps},get stepIndex(){return e().stepIndex},onPrevClick:()=>{d.update(g=>(g.prevStep(),g)),a.save()},onNextClick:()=>{d.update(g=>(g.nextStep(),g)),a.save()}});var W=C(i,2),Y=T(W);{var H=g=>{z(g,{get graph(){return e().steps[e().stepIndex].outSnapshot},style:"TSP",layout:"circle"})};x(Y,g=>{e().stepIndex<e().steps.length&&e().steps[e().stepIndex].outSnapshot&&g(H)})}w(W),m(f,S)},v=f=>{var S=Qe();m(f,S)};x(L,f=>{c(s).length?f(M):f(v,!1)})}m(t,o)},me=t=>{var s=Ve(),l=T(s),o=T(l);{var L=i=>{z(i,{get graph(){return e().inInstance},style:"UNDIRECTED",layout:"circle"})};x(o,i=>{e().inInstance&&!e().inInstance.empty()&&i(L)})}var M=C(o,2);{var v=i=>{Ue(i,{get cert(){return e().inCert}})};x(M,i=>{e().inCert&&i(v)})}w(l);var f=C(l,2),S=T(f);{var N=i=>{z(i,{get graph(){return e().outInstance},style:"TSP",layout:"circle"})};x(S,i=>{e().outInstance&&!e().outInstance.empty()&&i(N)})}var u=C(S,2);{var A=i=>{We(i,{get cert(){return e().outCert}})};x(u,i=>{e().outCert&&i(A)})}w(f),w(s),m(t,s)};x(ve,t=>{c(I)?t(ge):t(me,!1)})}w(y),B((t,s)=>{O.disabled=t,P.disabled=s},[()=>!e().hasInInstance()||e().hasOutInstance()||c(h),()=>!e().hasInstances()||e().hasOutCertificate()||c(h)]),he(ae,()=>c(I),t=>D(I,t)),m(R,y),le(),_()}fe(["click"]);export{dt as component,ct as universal};
