import"../chunks/DsnmJJEf.js";import{O as mt,h as J,e as bt,E as p,ab as wt,Q as yt,R as Ct,S as Be,n as Re,T as Le,j as me,C as St,aQ as It,V as Me,Y as xt,W as ce,au as Qe,U as nt,a4 as Et,as as Ze,aN as rt,aI as it,a_ as Ae,Z as ot,_ as $t,a$ as Te,b0 as Nt,b1 as Fe,aC as lt,k as At,b2 as Tt,aM as kt,b3 as Ot,g as Dt,q as Rt,b4 as dt,J as Lt,b5 as Ft,b6 as We,a0 as Ht,a5 as Pt,b7 as zt,b8 as Mt,an as Xt,A as ct,a1 as ut,b9 as Yt,p as oe,f as D,s as $,d as S,r as y,b as I,c as le,ao as ue,a as Z,t as K,ap as Ee,ba as Gt,w as ke,am as ee,a6 as G,ac as Wt,z as Ue,bb as Ut,v as qt,$ as Vt,aq as Ke}from"../chunks/BB7mMw4l.js";import{s as te,d as qe,o as Jt,w as Bt,g as je}from"../chunks/C04nbfFK.js";import{i as M,p as xe,b as Qt,s as Zt,a as Kt}from"../chunks/BaEzHINP.js";import{r as Oe,c as jt,l as ea}from"../chunks/BSAeQews.js";import{h as Se}from"../chunks/BYv3sgkP.js";function ve(t,e){return e}function ta(t,e,a){for(var s=t.items,r=[],n=e.length,i=0;i<n;i++)Tt(e[i].e,r,!0);var o=n>0&&r.length===0&&a!==null;if(o){var d=a.parentNode;kt(d),d.append(a),s.clear(),Q(t,e[0].prev,e[n-1].next)}Ot(r,()=>{for(var u=0;u<n;u++){var l=e[u];o||(s.delete(l.k),Q(t,l.prev,l.next)),lt(l.e,!o)}})}function he(t,e,a,s,r,n=null){var i=t,o={flags:e,items:new Map,first:null},d=(e&dt)!==0;if(d){var u=t;i=J?Re(Rt(u)):u.appendChild(nt())}J&&bt();var l=null,g=!1,C=new Map,_=wt(()=>{var x=a();return it(x)?x:x==null?[]:rt(x)}),c,h;function b(){aa(h,c,o,C,i,r,e,s,a),n!==null&&(c.length===0?l?ot(l):l=Me(()=>n(i)):l!==null&&$t(l,()=>{l=null}))}mt(()=>{h??=Dt,c=p(_);var x=c.length;if(g&&x===0)return;g=x===0;let N=!1;if(J){var H=yt(i)===Ct;H!==(x===0)&&(i=Be(),Re(i),Le(!1),N=!0)}if(J){for(var R=null,T,f=0;f<x;f++){if(me.nodeType===St&&me.data===It){i=me,N=!0,Le(!1);break}var w=c[f],O=s(w,f);T=Xe(me,o,R,null,w,O,f,r,e,a),o.items.set(O,T),R=T}x>0&&Re(Be())}if(J)x===0&&n&&(l=Me(()=>n(i)));else if(xt()){var U=new Set,q=ce;for(f=0;f<x;f+=1){w=c[f],O=s(w,f);var z=o.items.get(O)??C.get(O);z?(e&(Te|Ae))!==0&&vt(z,w,f,e):(T=Xe(null,o,null,null,w,O,f,r,e,a,!0),C.set(O,T)),U.add(O)}for(const[v,m]of o.items)U.has(v)||q.skipped_effects.add(m.e);q.add_callback(b)}else b();N&&Le(!0),p(_)}),J&&(i=me)}function aa(t,e,a,s,r,n,i,o,d){var u=(i&Ft)!==0,l=(i&(Te|Ae))!==0,g=e.length,C=a.items,_=a.first,c=_,h,b=null,x,N=[],H=[],R,T,f,w;if(u)for(w=0;w<g;w+=1)R=e[w],T=o(R,w),f=C.get(T),f!==void 0&&(f.a?.measure(),(x??=new Set).add(f));for(w=0;w<g;w+=1){if(R=e[w],T=o(R,w),f=C.get(T),f===void 0){var O=s.get(T);if(O!==void 0){s.delete(T),C.set(T,O);var U=b?b.next:c;Q(a,b,O),Q(a,O,U),He(O,U,r),b=O}else{var q=c?c.e.nodes_start:r;b=Xe(q,a,b,b===null?a.first:b.next,R,T,w,n,i,d)}C.set(T,b),N=[],H=[],c=b.next;continue}if(l&&vt(f,R,w,i),(f.e.f&Fe)!==0&&(ot(f.e),u&&(f.a?.unfix(),(x??=new Set).delete(f))),f!==c){if(h!==void 0&&h.has(f)){if(N.length<H.length){var z=H[0],v;b=z.prev;var m=N[0],A=N[N.length-1];for(v=0;v<N.length;v+=1)He(N[v],z,r);for(v=0;v<H.length;v+=1)h.delete(H[v]);Q(a,m.prev,A.next),Q(a,b,m),Q(a,A,z),c=z,b=A,w-=1,N=[],H=[]}else h.delete(f),He(f,c,r),Q(a,f.prev,f.next),Q(a,f,b===null?a.first:b.next),Q(a,b,f),b=f;continue}for(N=[],H=[];c!==null&&c.k!==T;)(c.e.f&Fe)===0&&(h??=new Set).add(c),H.push(c),c=c.next;if(c===null)continue;f=c}N.push(f),b=f,c=f.next}if(c!==null||h!==void 0){for(var E=h===void 0?[]:rt(h);c!==null;)(c.e.f&Fe)===0&&E.push(c),c=c.next;var B=E.length;if(B>0){var P=(i&dt)!==0&&g===0?r:null;if(u){for(w=0;w<B;w+=1)E[w].a?.measure();for(w=0;w<B;w+=1)E[w].a?.fix()}ta(a,E,P)}}u&&Lt(()=>{if(x!==void 0)for(f of x)f.a?.apply()}),t.first=a.first&&a.first.e,t.last=b&&b.e;for(var V of s.values())lt(V.e);s.clear()}function vt(t,e,a,s){(s&Te)!==0&&Qe(t.v,e),(s&Ae)!==0?Qe(t.i,a):t.i=a}function Xe(t,e,a,s,r,n,i,o,d,u,l){var g=(d&Te)!==0,C=(d&Nt)===0,_=g?C?Et(r,!1,!1):Ze(r):r,c=(d&Ae)===0?i:Ze(i),h={i:c,v:_,k:n,a:null,e:null,prev:a,next:s};try{if(t===null){var b=document.createDocumentFragment();b.append(t=nt())}return h.e=Me(()=>o(t,_,c,u),J),h.e.prev=a&&a.e,h.e.next=s&&s.e,a===null?l||(e.first=h):(a.next=h,a.e.next=h.e),s!==null&&(s.prev=h,s.e.prev=h.e),h}finally{}}function He(t,e,a){for(var s=t.next?t.next.e.nodes_start:a,r=e?e.e.nodes_start:a,n=t.e.nodes_start;n!==null&&n!==s;){var i=At(n);r.before(n),n=i}}function Q(t,e,a){e===null?t.first=a:(e.next=a,e.e.next=a&&a.e),a!==null&&(a.prev=e,a.e.prev=e&&e.e)}function sa(t,e){return t==null?null:String(t)}function na(t,e,a,s){var r=t.__style;if(J||r!==e){var n=sa(e);(!J||n!==t.getAttribute("style"))&&(n==null?t.removeAttribute("style"):t.style.cssText=n),t.__style=e}return s}function ht(t,e,a=!1){if(t.multiple){if(e==null)return;if(!it(e))return zt();for(var s of t.options)s.selected=e.includes(ye(s));return}for(s of t.options){var r=ye(s);if(Mt(r,e)){s.selected=!0;return}}(!a||e!==void 0)&&(t.selectedIndex=-1)}function ra(t){var e=new MutationObserver(()=>{ht(t,t.__value)});e.observe(t,{childList:!0,subtree:!0,attributes:!0,attributeFilter:["value"]}),Pt(()=>{e.disconnect()})}function ia(t,e,a=e){var s=!0;We(t,"change",r=>{var n=r?"[selected]":":checked",i;if(t.multiple)i=[].map.call(t.querySelectorAll(n),ye);else{var o=t.querySelector(n)??t.querySelector("option:not([disabled])");i=o&&ye(o)}a(i)}),Ht(()=>{var r=e();if(ht(t,r,s),s&&r===void 0){var n=t.querySelector(":checked");n!==null&&(r=ye(n),a(r))}t.__value=r,s=!1}),ra(t)}function ye(t){return"__value"in t?t.__value:t.value}function oa(t,e,a=e){var s=new WeakSet;We(t,"input",async r=>{var n=r?t.defaultValue:t.value;if(n=Pe(t)?ze(n):n,a(n),ce!==null&&s.add(ce),await Xt(),n!==(n=e())){var i=t.selectionStart,o=t.selectionEnd;t.value=n??"",o!==null&&(t.selectionStart=i,t.selectionEnd=Math.min(o,t.value.length))}}),(J&&t.defaultValue!==t.value||ct(e)==null&&t.value)&&(a(Pe(t)?ze(t.value):t.value),ce!==null&&s.add(ce)),ut(()=>{var r=e();if(t===document.activeElement){var n=Yt??ce;if(s.has(n))return}Pe(t)&&r===ze(t.value)||t.type==="date"&&!r&&!t.value||r!==t.value&&(t.value=r??"")})}function De(t,e,a=e){We(t,"change",s=>{var r=s?t.defaultChecked:t.checked;a(r)}),(J&&t.defaultChecked!==t.checked||ct(e)==null)&&a(t.checked),ut(()=>{var s=e();t.checked=!!s})}function Pe(t){var e=t.type;return e==="number"||e==="range"}function ze(t){return t===""?null:+t}const la=!0,ls=Object.freeze(Object.defineProperty({__proto__:null,prerender:la},Symbol.toStringTag,{value:"Module"})),Ce="unsolvable";var da=D("<p>The 3CNF formula is unsatisfiable.</p>"),ca=D("<div> </div>"),ua=D("<main><h2>CertRenderer 3SAT</h2> <!></main>");function va(t,e){oe(e,!0);var a=ua(),s=$(S(a),2);{var r=i=>{var o=da();I(i,o)},n=i=>{var o=ue(),d=Z(o);he(d,17,()=>e.cert.assignments,ve,(u,l)=>{var g=Ee(()=>Gt(p(l),2));let C=()=>p(g)[0],_=()=>p(g)[1];var c=ca(),h=S(c);y(c),K(()=>te(h,`${C()??""} ≔ ${_()==!0?"T":_()==!1?"F":"Either"}`)),I(u,c)}),I(i,o)};M(s,i=>{e.cert==Ce?i(r):i(n,!1)})}y(a),I(t,a),le()}var ha=D("<p>The graph doesn't contain a hamiltonian cycle.</p>"),fa=D("<li> </li>"),ga=D("<ol></ol>"),pa=D("<span><!> </span>"),_a=D("<div></div>"),ma=D('<div class="controls"><input type="checkbox" name="showAsListCheckbox"/> <label for="showAsListCheckbox">Show as list</label></div> <!>',1),ba=D("<main><h2>CertRenderer HCYCLE</h2> <!></main>");function wa(t,e){oe(e,!0);let a=ee(!0);var s=ba(),r=$(S(s),2);{var n=o=>{var d=ha();I(o,d)},i=o=>{var d=ma(),u=Z(d),l=S(u);Oe(l),ke(2),y(u);var g=$(u,2);{var C=c=>{var h=ga();he(h,21,()=>e.cert.path,ve,(b,x)=>{var N=fa(),H=S(N,!0);y(N),K(()=>te(H,p(x).id)),I(b,N)}),y(h),I(c,h)},_=c=>{var h=_a();he(h,21,()=>e.cert.path,ve,(b,x,N)=>{var H=pa(),R=S(H);Se(R,()=>N!=0?"&ThinSpace;&LongRightArrow;&ThinSpace;":"");var T=$(R);y(H),K(()=>te(T,` ${p(x).id??""}`)),I(b,H)}),y(h),I(c,h)};M(g,c=>{p(a)?c(C):c(_,!1)})}De(l,()=>p(a),c=>G(a,c)),I(o,d)};M(r,o=>{e.cert==Ce?o(n):o(i,!1)})}y(s),I(t,s),le()}class ya extends Error{}function ft(t,e){if(!t)throw new ya("[ASSERT] "+e)}function Ca(t,e,a){return a.indexOf(t)===e}class k{static SerializableClass(e){return function(a){const s=e??a.name;a.prototype.__type=s,k.registerClass(s,a)}}static serialize(e){if(e==null)return e;if(Array.isArray(e))return e.map(k.serialize);if(e instanceof Set)return{__type:"Set",values:Array.from(e).map(k.serialize)};if(e instanceof Map)return{__type:"Map",entries:Array.from(e.entries()).map(([a,s])=>[k.serialize(a),k.serialize(s)])};if(typeof e=="object"){if(Array.isArray(e))return e.map(k.serialize);const a=e.constructor,r={__type:e.__type??a.name};for(const[n,i]of Object.entries(e))r[n]=k.serialize(i);return r}return e}static revive(e){if(e==null)return e;if(Array.isArray(e))return e.map(k.revive);if(e.__type==="Set")return new Set(e.values.map(k.revive));if(e.__type==="Map")return new Map(e.entries.map(([a,s])=>[k.revive(a),k.revive(s)]));if(e.__type){const a=k.getClass(e.__type);if(!a)throw new Error(`Serializer - Unknown class: ${e.__type}`);const s=Object.create(a.prototype);for(const[r,n]of Object.entries(e))r!=="__type"&&(s[r]=k.revive(n));return s}return e}static registerClass(e,a){k.classRegistry.set(e,a)}static getClass(e){return k.classRegistry.get(e)}static classRegistry=new Map}k.registerClass(Object.name,Object);class gt{}var Sa=Object.getOwnPropertyDescriptor,Ve=(t,e,a,s)=>{for(var r=s>1?void 0:s?Sa(e,a):e,n=t.length-1,i;n>=0;n--)(i=t[n])&&(r=i(r)||r);return r};let $e=class{id;varName;negated;constructor(t,e,a=!1){this.id=t,this.varName=e,this.negated=a}toJson(){return{__type:$e.name,id:this.id,varName:this.varName,negated:this.negated}}asString(){return`${this.negated?"!":""}${this.varName}`}asHtmlString(){return(this.negated?"&not;":"")+this.varName}};$e=Ve([k.SerializableClass("Literal")],$e);let Ne=class{id;literals;constructor(t,e){ft(e.length==3),this.id=t,this.literals=[e[0],e[1],e[2]]}asString(){return this.literals.map(t=>t.asString()).join(" ")}asHtmlString(){return"("+this.literals.map(e=>e.asHtmlString()).join("&or;")+")"}toJSON(){return{__type:Ne.name,id:this.id,literals:this.literals}}};Ne=Ve([k.SerializableClass("Clause")],Ne);let fe=class extends gt{_variables=new Set;_clauses=new Set;addVariable(t){this._variables.add(t)}addClause(t){this._clauses.add(t),t.literals.forEach(e=>this.addVariable(e.varName))}asString(){return Array.from(this._clauses.values()).map(t=>t.asString()).join(`
`)}asHtmlString(){return this.clauses.map(t=>t.asHtmlString()).join("&and;")}get variables(){return Array.from(this._variables.values())}get clauses(){return Array.from(this._clauses.values())}empty(){const t=this.clauses.length==0||this.variables.length==0;return console.debug("empty",t),t}static fromString(t){const e=t.split(`
`).map(s=>s.trim()).filter(s=>s.length).filter(Ca);let a=new fe;for(let s=0;s<e.length;s++){const r=e[s],n=r.split(" ").map(d=>d.trim()).filter(d=>d.length);if(n.length!=3)return`Clause number ${s+1} (${r}) doesn't have exactly 3 literals. Instead it has ${n.length} literals.`;let i=[];for(let d=0;d<n.length;d++){let u=n[d];const l=u.startsWith("!");if(l&&(u=u.replace("!","")),u.includes("!")||u.includes("||")||u.includes("&&"))return`Literal ${l?"!":""}${u} is invalid.`;const g=new $e(`v:${d}-c:${s}`,u,l);i.push(g)}ft(i.length==3);const o=new Ne(`c:${s}`,i);a.addClause(o)}return a}};fe=Ve([k.SerializableClass("CNF3")],fe);class Je{static cnf3TextInput={NO_SOLUTION:`x y z
!x y z
x !y z
!x !y z
x y !z
!x y !z
x !y !z
!x !y !z
`,BASIC:`x y z
a b c
`};static getTextInputs(e){if(e===fe)return Je.cnf3TextInput;throw new Error(`No demos provided for class ${e.name}.`)}}function Ia(t,e,a,s,r){G(e,a[p(s)],!0),r()}var xa=D("<option> </option>"),Ea=D(`<div class="cnf-editor"><h2>CNF Editor</h2> <p><i>Removes duplicate clauses automatically.</i></p> <textarea class="svelte-whqlb8">
    </textarea> <select><option>--Choose a demo--</option><!></select></div>`);function $a(t,e){oe(e,!0);const a=Je.getTextInputs(fe);let s=ee(Wt(e.cnf?.asString()??"")),r=ee("");const n=_=>{e.onChange&&e.onChange(_)},i=_=>{e.onWrongFormat&&e.onWrongFormat(_)},o=()=>{const _=fe.fromString(p(s));if(typeof _=="string"){i(_);return}n(_)};Ue(()=>{e.cnf&&G(s,e.cnf.asString(),!0)});var d=Ea(),u=$(S(d),4);Ut(u),u.__change=o;var l=$(u,2);l.__change=[Ia,s,a,r,o];var g=S(l);g.value=g.__value="";var C=$(g);he(C,17,()=>Object.keys(a),ve,(_,c)=>{var h=xa(),b=S(h,!0);y(h);var x={};K(()=>{te(b,p(c)),x!==(x=p(c))&&(h.value=(h.__value=p(c))??"")}),I(_,h)}),y(l),y(d),oa(u,()=>p(s),_=>G(s,_)),ia(l,()=>p(r),_=>G(r,_)),I(t,d),le()}qe(["change"]);function Na(t,e,a){e()&&a.stepIndex>0&&e()()}function Aa(t,e,a,s){e()&&a.stepIndex<s-1&&e()()}var Ta=D("<h3> </h3> <p><!></p> <!>",1),ka=D("<h3> </h3> <p><!></p>",1),Oa=D('<section><div class="header svelte-bomf3d"><h2>Reduction Stepper</h2> <div class="controls"><div><input type="checkbox" name="showAllCheckbox"/> <label for="showAllCheckbox">Show all</label></div> <div><button>Previous</button> <button>Next</button> <span> </span></div></div></div> <!></section>');function Da(t,e){oe(e,!0);let a=xe(e,"indent",3,0),s=xe(e,"onNextClick",3,void 0),r=xe(e,"onPrevClick",3,void 0);const n=e.steps.length;let i=ee(!1);var o=Oa(),d=S(o),u=$(S(d),2),l=S(u),g=S(l);Oe(g),ke(2),y(l);var C=$(l,2),_=S(C);_.__click=[Na,r,e];var c=$(_,2);c.__click=[Aa,s,e,n];var h=$(c,2),b=S(h);y(h),y(C),y(u),y(d);var x=$(d,2);{var N=R=>{var T=ue(),f=Z(T);he(f,17,()=>e.steps,ve,(w,O,U)=>{var q=Ta(),z=Z(q),v=S(z);y(z);var m=$(z,2),A=S(m);Se(A,()=>p(O).description),y(m);var E=$(m,2);M(E,B=>{}),K(()=>te(v,`Step #${U+1}: ${p(O).title??""}`)),I(w,q)}),I(R,T)},H=R=>{var T=ue(),f=Z(T);{var w=O=>{const U=Ee(()=>e.steps[e.stepIndex]);var q=ka(),z=Z(q),v=S(z);y(z);var m=$(z,2),A=S(m);Se(A,()=>p(U).description),y(m),K(()=>te(v,`Step #${e.stepIndex+1}: ${p(U).title??""}`)),I(O,q)};M(f,O=>{e.stepIndex<e.steps.length&&O(w)})}I(R,T)};M(x,R=>{p(i)?R(N):R(H,!1)})}y(o),K(()=>{na(o,`padding-left: ${a()*100}px; border: solid black 1px`),te(b,`${e.stepIndex+1}/${n??""}`)}),De(g,()=>p(i),R=>G(i,R)),I(t,o),le()}qe(["click"]);var Ra=D('<div class="clause svelte-z6uwnm"><!></div>'),La=D('<div class="cnf-renderer"><h2>CNF Renderer</h2> <div><input type="checkbox" name="viewAsColumnCheckbox"/> <label for="viewAsColumnCheckbox">View as column</label></div> <!></div>');function et(t,e){oe(e,!0);let a=ee(!1);var s=La(),r=$(S(s),2),n=S(r);Oe(n),ke(2),y(r);var i=$(r,2);{var o=u=>{var l=ue(),g=Z(l);he(g,17,()=>e.cnf.clauses,ve,(C,_)=>{var c=Ra(),h=S(c);Se(h,()=>p(_).asHtmlString()),y(c),I(C,c)}),I(u,l)},d=u=>{var l=ue(),g=Z(l);Se(g,()=>e.cnf.asHtmlString()),I(u,l)};M(i,u=>{p(a)?u(o):u(d,!1)})}y(s),De(n,()=>p(a),u=>G(a,u)),I(t,s),le()}const tt={DEFAULT_STYLE:[{selector:"node",style:{label:"data(id)","text-valign":"top",color:"#000","background-color":"#61bffc","text-outline-color":"#fff","text-outline-width":2,"border-color":"black","border-style":"solid","border-width":2}},{selector:"edge",style:{"curve-style":"bezier","line-color":"black",width:2}}],"3SAT-HCYCLE":[{selector:"node",style:{label:"data(id)","font-size":12,"text-valign":"top","background-color":"blue","border-color":"black","border-style":"solid","border-width":2}},{selector:"node.true",style:{"background-color":"green"}},{selector:"node.false",style:{"background-color":"red"}},{selector:"node.source, node.inbetween, node.target",style:{"background-color":"white","border-style":"solid","border-color":"black"}},{selector:"node.clause",style:{"background-color":"orange"}},{selector:"node.guarantee",style:{opacity:.5}},{selector:"edge",style:{"line-color":"black","target-arrow-color":"black","target-arrow-shape":"chevron","curve-style":"bezier","arrow-scale":1}},{selector:"edge.muted",style:{"line-opacity":.2,"line-color":"black"}},{selector:"edge.clause",style:{"curve-style":"bezier",width:3,"line-opacity":1,"arrow-scale":2}},{selector:"edge.true_in",style:{"target-arrow-color":"green","line-color":"green","line-style":"dashed"}},{selector:"edge.true_out",style:{"target-arrow-color":"green","line-color":"green"}},{selector:"edge.false_in",style:{"target-arrow-color":"red","line-color":"red","line-style":"dashed"}},{selector:"edge.false_out",style:{"target-arrow-color":"red","line-color":"red"}},{selector:"edge.solved",style:{"line-opacity":.2}},{selector:"edge.solved.used",style:{"line-opacity":1}}]};var Fa=D('<section><h2>Graph Renderer</h2> <div id="cy" class="svelte-ovjh18"></div></section>');function at(t,e){oe(e,!0);let a=xe(e,"style",3,"DEFAULT_STYLE"),s,r;Ue(()=>{const o=e.graph.nodes.map(g=>({data:{id:g.id,label:g.id},position:g.position,classes:g.classes})),d=e.graph.edges.map(g=>({data:{id:g.id,source:g.from,target:g.to},classes:g.classes})),u=r?r.pan():{x:0,y:0},l=r?r.zoom():1;r?r.elements().remove():r=jt({container:s,wheelSensitivity:5,style:tt[a()]}),r.add([...o,...d]),r.style(tt[a()]),r.zoom(l),r.pan(u)});var n=Fa(),i=$(S(n),2);Qt(i,o=>s=o,()=>s),y(n),I(t,n),le()}const Ha=":",de="n:",j="n%:",Y="e:",se="source",ne="target",be="n%c:",we="n%i:",re="n%t:",ie="n%f:";function Pa(t,e,a={serialize:s=>k.serialize(s),revive:s=>k.revive(s)}){let s=Bt(e);Jt(()=>{const n=localStorage.getItem(t);if(n){const i=a.revive(JSON.parse(n));s.set(i)}});const r=()=>{if(je(s)){const n=JSON.stringify(a.serialize(je(s)));localStorage.setItem(t,n)}else localStorage.removeItem(t)};return{value:s,save:()=>r()}}var za=Object.getOwnPropertyDescriptor,Ma=(t,e,a,s)=>{for(var r=s>1?void 0:s?za(e,a):e,n=t.length-1,i;n>=0;n--)(i=t[n])&&(r=i(r)||r);return r};let Ye=class{assignments;constructor(t){this.assignments=t}};Ye=Ma([k.SerializableClass("Certificate3SAT")],Ye);class Xa{decode(e,a){const{path:s}=a,r=new Map;for(let n=0;n<s.length;n++){const i=s[n].id;if(i.startsWith(re)){const o=i.substring(re.length,i.lastIndexOf("_"));r.has(o)||r.set(o,!0)}else if(i.startsWith(ie)){const o=i.substring(ie.length,i.lastIndexOf("_"));r.has(o)||r.set(o,!1)}}return new Ye(r)}}var Ya=Object.getOwnPropertyDescriptor,Ga=(t,e,a,s)=>{for(var r=s>1?void 0:s?Ya(e,a):e,n=t.length-1,i;n>=0;n--)(i=t[n])&&(r=i(r)||r);return r};let ge=class extends gt{_nodes;_edges;constructor(){super(),this._nodes=new Set,this._edges=new Set}addNode(t){t.classes==null&&(t.classes=""),this._nodes.add(t)}addEdge(t){t.classes==null&&(t.classes=""),this._edges.add(t)}get nodes(){return Array.from(this._nodes.values())}get edges(){return Array.from(this._edges.values())}removeNode(t){if(!this._nodes.has(t))return;this._nodes.delete(t),Array.from(this.edges).filter(a=>a.to===t.id||a.from===t.id).forEach(a=>this._edges.delete(a))}removeEdge(t){this._edges.delete(t)}empty(){return this.nodes.length==0||this.edges.length==0}copy(){const t=new ge;for(const e of this._nodes)t.addNode({id:e.id,label:e.label,position:e.position?{...e.position}:void 0,classes:e.classes});for(const e of this._edges)t.addEdge({id:e.id,from:e.from,to:e.to,weight:e.weight,classes:e.classes});return t}toSerializedString(t=!1){const e={nodes:this.nodes.map(a=>({id:a.id,label:a.label??null,position:a.position??null,classes:a.classes??""})),edges:this.edges.map(a=>({id:a.id,from:a.from,to:a.to,weight:a.weight??null,classes:a.classes??""}))};return JSON.stringify(e,null,t?2:0)}static fromSerializedString(t){const e=JSON.parse(t),a=new ge;if(Array.isArray(e.nodes))for(const s of e.nodes)a.addNode({id:s.id,label:s.label??void 0,position:s.position??void 0,classes:s.classes??""});if(Array.isArray(e.edges))for(const s of e.edges)a.addEdge({id:s.id,from:s.from,to:s.to,weight:s.weight??void 0,classes:s.classes??""});return a}};ge=Ga([k.SerializableClass("Graph")],ge);class Wa{inInstance;rowNodeCount;rowXOffset;varCount;clauseCount;height;yStep;yOffset;xDist=50;yDist=300;constructor(e){this.inInstance=e;const{variables:a,clauses:s}=this.inInstance;this.yOffset=this.yDist/2,this.varCount=a.length,this.clauseCount=s.length,this.height=(this.varCount-1)*this.yDist,this.yStep=(this.height-this.yDist)/(this.clauseCount-1==0?1:this.clauseCount-1),this.rowNodeCount=3*s.length+3,this.rowXOffset=(this.rowNodeCount-1)/2*this.xDist}reduce(){let e=[];const a=this.createVarGadgets();e.push(...a.interSteps);const s=this.createClauseGadgets(a.graph.copy());return e.push(...s.interSteps),{outInstance:s.graph,steps:e}}createClauseGadgets(e){const{clauses:a}=this.inInstance;let s=[],r=e.copy();return s.push({id:"create-clause-gadget-nodes",title:"Create clause nodes",description:`
                <p>
                    For every clause, create one clause node 
                    (this node must be visited exactly once).
                    There are ${this.clauseCount} clause nodes.
                </p>
                <p>
                    For each of the clause, create edges to or from the variable row nodes
                    based on these rules:
                </p>
                <ul>
                    <li>
                        If the literal <b>isn't negated</b>, 
                        pick a free (one that hasn't been used yet in this step) 
                        row node <i>r</i> and connect it to the clause node.

                        The selected node is an <u>out-going</u> node.

                        Then connect the clause node back to a row node <i>r + 1</i> 
                        (adjacent on the right of it).

                        This node is an <u>in-coming</u> node.
                    </li>
                    <li>
                        If the literal <b>is negated</b>, 
                        pick a free row node <i>r</i> 
                        and connect it to the clause node.

                        The selected node is an <u>out-going</u> node.

                        Then connect the clause node back to a row node <i>r - 1</i> 
                        (adjacent on the left of it).

                        This node is an <u>in-coming</u> node.
                    </li>
                </ul>
                <p>
                    This way we gaurantee for each clause that:
                    <ul>
                        <li>
                            If the literal <i>L</i> of some variable <i>X</i> 
                            <b>wasn't negated</b> in the clause, 
                            then we can reach it from an <i>X</i> variable row node 
                            and come back to an <i>X</i> variable row node on the right of it,
                            when we approach it from the left (we assinged X to be True).
                        </li>
                        <li>
                            If the literal <i>L</i> of some variable <i>X</i> 
                            <b>was negated</b> in the clause, 
                            then we can reach it from an <i>X</i> variable row node 
                            and come back to an <i>X</i> variable row node on the left of it,
                            when we approach it from the right (we assigned X to be False).
                        </li>
                    </ul>
                </p>
            `,inSnapshot:this.inInstance,outSnapshot:r,mapping:{}}),a.forEach((n,i)=>{const o=i+1,d=`${o}`,u={id:be+`${d}`,position:{x:2*this.rowXOffset,y:i*this.yStep+this.yOffset},classes:"clause"};r.addNode(u),e.addNode(u),n.literals.forEach((l,g)=>{const C=`${l.varName}_${3*o}`,_=`${l.varName}_${3*o+1}`;l.negated?(e.addEdge({id:Y+`${_}-${d}`,from:de+`${_}`,to:be+`${d}`,classes:"false_out"}),e.addEdge({id:Y+`${d}-${C}`,from:be+`${d}`,to:de+`${C}`,classes:"false_in"})):(e.addEdge({id:Y+`${C}-${d}`,from:de+`${C}`,to:be+`${d}`,classes:"true_out"}),e.addEdge({id:Y+`${d}-${_}`,from:be+`${d}`,to:de+`${_}`,classes:"true_in"}))}),s.push({id:`connect-clause-node-${i}`,title:`Connect clause node "${d}" to variable row nodes`,description:`
                    <p>
                        Clause node "${d}" represents the clause ${n.asHtmlString()}.
                    </p>
                    <ul>
                        ${n.literals.map(l=>`
                                <li>
                                    ${l.asHtmlString()}
                                    &hyphen;
                                    ${l.negated?`
                                        because ${l.varName} is <i>negated</i>, 
                                        the <u>out-going</u> node (${l.varName}_${3*o+1})
                                        will be on the <b>right</b> of
                                        the <u>in-coming</u> node (${l.varName}_${3*o}).
                                    `:`
                                        because ${l.varName} is <i>isn't negated</i>, 
                                        the <u>out-going</u> node (${l.varName}_${3*o})
                                        will be on the <b>left</b> of
                                        the <u>in-coming</u> node (${l.varName}_${3*o+1}).
                                    `}
                                </li>
                            `).join("")}
                    </ul>
                    <p>
                        To clarify:
                        <ul>
                            <li>out-going node is incident to an edge connecting a row node to a clause node.</li>
                            <li>in-coming node is incident to an edge connecting a clause node to a row node.</li>
                        </ul>
                    </p>
                `,inSnapshot:this.inInstance,outSnapshot:e.copy(),mapping:{}})}),{graph:e,interSteps:s}}createVarGadgets(){const{variables:e}=this.inInstance;let a=new ge,s=new ge,r=[];return e.forEach((n,i)=>{if(i==0)s.addNode({id:j+se,position:{x:0,y:i*this.yDist-this.yDist/2},classes:"source"}),s.addEdge({id:Y+`${se}-${n}_1`,from:j+`${se}`,to:re+`${n}_1`,classes:"muted"}),s.addEdge({id:Y+`${se}-${n}_${this.rowNodeCount}`,from:j+`${se}`,to:ie+`${n}_${this.rowNodeCount}`,classes:"muted"});else{const o=`${e[i-1]}_${n}`;s.addNode({id:we+`${o}`,position:{x:0,y:i*this.yDist-this.yDist/2},classes:"inbetween"});const d=e[i-1];s.addEdge({id:Y+`${d}_1-${o}`,from:re+`${d}_1`,to:we+o,classes:"muted"}),s.addEdge({id:Y+`${d}_${this.rowNodeCount}-${o}`,from:ie+`${d}_${this.rowNodeCount}`,to:we+o,classes:"muted"}),s.addEdge({id:Y+`${o}-${n}_1`,from:we+`${o}`,to:re+`${n}_1`,classes:"muted"}),s.addEdge({id:Y+`${o}-${n}_${this.rowNodeCount}`,from:we+`${o}`,to:ie+`${n}_${this.rowNodeCount}`,classes:"muted"})}for(let o=1;o<=this.rowNodeCount-1;o++){const d=`${n}_${o}`,u=`${n}_${o+1}`;let l="",g=de,C=de;o==1?(l+=" true",g=re):o==this.rowNodeCount-1?C=ie:(o+1)%3==0&&(l+=" guarantee");const _={id:g+`${d}`,position:{x:(o-1)*this.xDist-this.rowXOffset,y:i*this.yDist},classes:l};if(a.addNode(_),s.addNode(_),o==this.rowNodeCount-1){const b={id:C+`${u}`,position:{x:o*this.xDist-this.rowXOffset,y:i*this.yDist},classes:"false"};a.addNode(b),s.addNode(b)}const c={id:Y+`${d}-${u}`,from:g+`${d}`,to:C+`${u}`,classes:"muted"},h={id:Y+`${u}-${d}`,from:C+`${u}`,to:g+`${d}`,classes:"muted"};a.addEdge(c),a.addEdge(h),s.addEdge(c),s.addEdge(h)}i==e.length-1&&(s.addNode({id:j+ne,position:{x:0,y:i*this.yDist+this.yDist/2},classes:"target"}),s.addEdge({id:Y+`${n}_1-${ne}`,from:re+`${n}_1`,to:j+`${ne}`,classes:"muted"}),s.addEdge({id:Y+`${n}_${this.rowNodeCount}-${ne}`,from:ie+`${n}_${this.rowNodeCount}`,to:j+`${ne}`,classes:"muted"}),s.addEdge({id:Y+`${ne}-${se}`,from:j+`${ne}`,to:j+`${se}`,classes:"muted"}))}),r.push({id:"create-variable-gadgets",title:"Create individual variable gadgets",description:`
                <p>
                    For every variable, create a row variable gadget.
                </p>
                <p>
                    This gadget consists of ${this.rowNodeCount} row nodes.
                    They are all connected birectinally.
                </p>
                <p>
                    The number of row nodes it derived as follows: 
                </p>
                <p>
                    For every clause we need 2 nodes - an <i>out-going</i> and <i>in-coming</i> node.
                    Each of these 2 nodes must be padded a <i>pad</i> node (at least one).
                    The rows themselves also need <i>true</i> and and <i>false</i> ends.
                </p>
                <p>
                    ${this.clauseCount==1?`There is ${this.clauseCount} clause.`:`There are ${this.clauseCount} clauses.`}
                    Therefore we need: 
                    <ul>
                        <li>2 * ${this.clauseCount} out-going and in-coming nodes</li>
                        <li>${this.clauseCount} + 1 pad nodes</li>
                        <li>1 true and 1 false nodes at the row ends</li>
                    </ul>
                </p>
                <p>
                    (2 * ${this.clauseCount}) + (${this.clauseCount} + 1) + 1 + 1 = ${this.rowNodeCount} nodes per variable row.
                </p>
            `,inSnapshot:this.inInstance,outSnapshot:a,mapping:{}}),r.push({id:"create-inbetween-nodes",title:"Create inbetween nodes",description:`
                <p>
                    Create the <i>source</i> node, the <i>inbetween</i> nodes that lie
                    between the variable rows and <i>target</i> node. 
                </p>
                <p>
                    Connect the <i>source</i> node 
                    to the row ends of the first variable "${this.inInstance.variables[0]}".
                    After that connect its row ends to the inbetween/target node below.
                    Finally connect the <i>target</i> node to <i>source</i> node to close the loop.
                </p>
                <p>Why did we do this?</p>
                <p>
                    Going from the <i>source</i> or an <i>inbetween</i> node 
                    to the variable's row node is equivalent to assigning 
                    a boolean value that corresponding variable.
                </p>
                <ul>
                    <li> 
                        Going through the <b>left edge means assigning 'true'</b>.
                    </li>
                    <li>
                        Going though the <b>right edge means assigning 'false'</b>.
                    </li>
                </ul>
                <p>
                    Notice that we can only choose either 'true' or 'false' edge.
                    Backtracking is impossible.
                </p>
                <p>
                    After going through either the right or left edge, 
                    we must visit the row nodes, for the final cycle to be Hamiltonian.
                </p>
                <ul>
                    <li>
                        If we chose the <b>left edge</b>, then we end up on the <b>'true'</b> node 
                        and have to traverse the row nodes from <u>left to right</u> until 
                        we end up at the 'false' node.
                    </li>

                    <li>
                        If we chose the <b>right</b> edge, then we end up on the <b>'false'</b> node 
                        and have to traverse the row nodes from <u>right to left</u> until
                        we end up at the 'true' node.
                    </li>

                    <li>
                        Onwards, the only choice is to continue 
                        to the next <i>inbetween</i>/<i>target</i> node below.
                    </li>
                </ul>
                <p>
                    The last step is to go from the <i>target</i> node back to the <i>source</i> node.
                </p>
            `,inSnapshot:this.inInstance,outSnapshot:s,mapping:{}}),{graph:s,interSteps:r}}}var Ua=Object.getOwnPropertyDescriptor,qa=(t,e,a,s)=>{for(var r=s>1?void 0:s?Ua(e,a):e,n=t.length-1,i;n>=0;n--)(i=t[n])&&(r=i(r)||r);return r};let st=class{path;constructor(t){this.path=t}};st=qa([k.SerializableClass("Certificate3SAT")],st);var Va=Object.getOwnPropertyDescriptor,Ja=(t,e,a,s)=>{for(var r=s>1?void 0:s?Va(e,a):e,n=t.length-1,i;n>=0;n--)(i=t[n])&&(r=i(r)||r);return r};let Ge=class{inInstance=null;outInstance=null;steps=[];stepIndex=0;inCert=null;outCert=null;reset(){this.inInstance=null,this.outInstance=null,this.inCert=null,this.outCert=null,this.steps=[],this.stepIndex=0}resetStepIndex(){this.stepIndex=0}setInInstance(t){this.reset(),this.inInstance=t}set setSteps(t){this.steps=t,this.stepIndex=0}nextStep(){const t=this.steps.length;this.stepIndex=Math.min(this.stepIndex+1,t)}prevStep(){this.stepIndex=Math.max(this.stepIndex-1,0)}hasInstances(){return this.inInstance!=null&&this.outInstance!=null}};Ge=Ja([k.SerializableClass("ReductionStore")],Ge);var Ba=D('<meta name="description" content="Redcution from 3SAT to HCYCLE"/>'),Qa=(t,e)=>e(),Za=D('<div class="loading svelte-1cz0gvf"><span class="spinner svelte-1cz0gvf"></span> <span> </span></div>'),Ka=D("<div><!></div> <!> <div><!></div>",1),ja=D("<span>There are no steps to step through.</span>"),es=D('<div class="panes svelte-1cz0gvf"><div><!> <!></div> <div><!> <!></div></div>'),ts=D('<main><h1>3SAT to HCYCLE reduction</h1> <!> <div><button>Reduce</button> <button><!></button> <input type="checkbox" name="showStepperCheckbox"/> <label for="showStepperCheckbox">Show steps</label></div> <!> <!></main>');function ds(t,e){oe(e,!0);const a=()=>Zt(i,"$redStore",s),[s,r]=Kt();let n=Pa(ea.LS_3SAT_HCYCLE,new Ge),i=n.value,o=ee(!1),d=ee(!1),u=ee(""),l=null;function g(v){l&&(l.terminate(),l=null,G(d,!1),G(u,"Solving cancelled — formula changed.")),i.update(m=>(m.reset(),m.setInInstance(v),n.save(),m))}function C(){if(a().inInstance){const v=new Wa(a().inInstance),{outInstance:m,steps:A}=v.reduce();i.update(E=>(E.steps=A,E.outInstance=m,E)),n.save()}}async function _(){let{inCert:v,outInstance:m,outCert:A}=a();if(!(!m||A)){G(d,!0),G(u,"Solving Hamiltonian cycle..."),l&&(l.terminate(),l=null);try{const E=new Worker(new URL(""+new URL("../workers/WorkerHCYCLESolver-BPfLfcAe.js",import.meta.url).href,import.meta.url),{type:"module"});l=E;const B=new Promise((P,V)=>{E.onmessage=X=>{E===l&&(E.terminate(),l=null,P(X.data))},E.onerror=X=>{E===l&&(E.terminate(),l=null,V(X))}});if(E.postMessage(m.toSerializedString()),A=await B,!l&&!p(d))return;if(A==Ce)i.update(P=>(P.inCert=Ce,P.outCert=Ce,P));else{const P=m,V=A.path;P.edges.forEach(F=>F.classes+=" solved");const X=F=>F.slice(F.search(Ha)+1);for(let F=0;F<V.length-1;F++){const ae=X(V[F].id),pe=X(V[F+1].id),_e=Y+`${ae}-${pe}`,L=P.edges.find(Ie=>Ie.id==_e);L&&(P.removeEdge(L),L.classes+=" used",P.addEdge(L))}v=new Xa().decode(P,A),i.update(F=>(F.inCert=v,F.outCert=A,F.outInstance=P,F))}n.save()}catch(E){console.error("Error during solving:",E),G(u,"An error occurred while solving.")}finally{G(d,!1),G(u,""),l=null}}}Ue(()=>{i.update(v=>(v.resetStepIndex(),v))});var c=ts();qt(v=>{var m=Ba();Vt.title="3SAT to HCYCLE",I(v,m)});var h=$(S(c),2);$a(h,{get cnf(){return a().inInstance},onChange:v=>g(v),onWrongFormat:v=>alert("From editor: "+v)});var b=$(h,2),x=S(b);x.__click=C;var N=$(x,2);N.__click=[Qa,_];var H=S(N);{var R=v=>{var m=Ke("Solving...");I(v,m)},T=v=>{var m=Ke("Solve");I(v,m)};M(H,v=>{p(d)?v(R):v(T,!1)})}y(N);var f=$(N,2);Oe(f),ke(2),y(b);var w=$(b,2);{var O=v=>{var m=Za(),A=$(S(m),2),E=S(A,!0);y(A),y(m),K(()=>te(E,p(u))),I(v,m)};M(w,v=>{p(d)&&v(O)})}var U=$(w,2);{var q=v=>{const m=Ee(()=>a().steps),A=Ee(()=>a().stepIndex);var E=ue(),B=Z(E);{var P=X=>{var F=Ka(),ae=Z(F),pe=S(ae);{var _e=W=>{et(W,{get cnf(){return p(m)[p(A)].inSnapshot}})};M(pe,W=>{p(A)<p(m).length&&p(m)[p(A)].inSnapshot&&!p(m)[p(A)].inSnapshot.empty()&&W(_e)})}y(ae);var L=$(ae,2);Da(L,{get steps(){return a().steps},get stepIndex(){return a().stepIndex},onPrevClick:()=>{i.update(W=>(W.prevStep(),W)),n.save()},onNextClick:()=>{i.update(W=>(W.nextStep(),W)),n.save()}});var Ie=$(L,2),pt=S(Ie);{var _t=W=>{at(W,{get graph(){return a().steps[a().stepIndex].outSnapshot},style:"3SAT-HCYCLE"})};M(pt,W=>{a().stepIndex<a().steps.length&&a().steps[a().stepIndex].outSnapshot&&W(_t)})}y(Ie),I(X,F)},V=X=>{var F=ja();I(X,F)};M(B,X=>{p(m).length?X(P):X(V,!1)})}I(v,E)},z=v=>{var m=es(),A=S(m),E=S(A);{var B=L=>{et(L,{get cnf(){return a().inInstance}})};M(E,L=>{a().inInstance&&!a().inInstance.empty()&&L(B)})}var P=$(E,2);{var V=L=>{va(L,{get cert(){return a().inCert}})};M(P,L=>{a().inCert&&L(V)})}y(A);var X=$(A,2),F=S(X);{var ae=L=>{at(L,{get graph(){return a().outInstance},style:"3SAT-HCYCLE"})};M(F,L=>{a().outInstance&&!a().outInstance.empty()&&L(ae)})}var pe=$(F,2);{var _e=L=>{wa(L,{get cert(){return a().outCert}})};M(pe,L=>{a().outCert&&L(_e)})}y(X),y(m),I(v,m)};M(U,v=>{p(o)?v(q):v(z,!1)})}y(c),K(v=>{x.disabled=p(d),N.disabled=v},[()=>!a().hasInstances()||p(d)]),De(f,()=>p(o),v=>G(o,v)),I(t,c),le(),r()}qe(["click"]);export{ds as component,ls as universal};
