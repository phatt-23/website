import"../chunks/DsnmJJEf.js";import"../chunks/DVXSbgSC.js";import{p as he,f as F,J as ue,d as R,s as g,t as W,b as S,c as Ie,$ as ge,u as Q,r as y,K,am as Y,an as Ce,a as z,m as b,ac as j}from"../chunks/0h0eovDe.js";import{d as ve,s as me}from"../chunks/BeBJMhcX.js";import{s as B,i as m,a as _e,b as fe,c as Ee}from"../chunks/E6MyXn9j.js";import{l as Se,r as be}from"../chunks/CSnGU0Cu.js";import{N as H,H as C,R as Re,E as k,G as ye,u as Ne,a as Ae,c as we,b as xe,U as q,d as Ge,f as Fe}from"../chunks/DCk9rHG9.js";import{i as He}from"../chunks/DaAev7kg.js";import{E as Oe,R as Ue,C as Pe}from"../chunks/Bs7IJ1ml.js";import{C as De,a as Xe}from"../chunks/8Ke2ApCb.js";import{R as V}from"../chunks/YqW4Rh_A.js";const Te=!0,st=Object.freeze(Object.defineProperty({__proto__:null,prerender:Te},Symbol.toStringTag,{value:"Module"}));class ee{decode(a,e){console.debug(e.path);const s=new Array;e.path.forEach(c=>{const l=this.getNodeName(c.id);s.push(l)});const o=new Array;let r;for(let c=0;c<s.length;c++)r!=s[c]&&(r=s[c],o.push({id:H+r}));return new De(o)}nodePrefixes=[C.INCOMING_NODE_PREFIX,C.OUTGOING_NODE_PREFIX,C.GAP_NODE_PREFIX];getNodeName(a){for(let e=0;e<this.nodePrefixes.length;e++){const s=this.nodePrefixes[e];if(a.startsWith(s))return a.slice(s.length)}throw new Error(`Encountered node that doesn't start with any of the legal prefixes: ${a}`)}}class Ze extends Re{nodeDist=80;tripletDist=6*this.nodeDist;nodeCount;circum;radius;radStep;startRot;constructor(a){if(super(a),a.isEmpty())throw new Error("Reducer doesn't accept empty graphs (Graph with node nodes).");this.nodeCount=a.nodes.length,this.circum=this.tripletDist*this.nodeCount,this.radius=this.circum/(2*Math.PI),this.radStep=2*Math.PI/this.nodeCount,this.startRot=.5*Math.PI}doReduce(){const a=[],e=this.createNodeTriplets();a.push(...e.steps);const s=this.connectEdges(e.graph.copy());return a.push(...s.steps),{outInstance:s.graph,steps:a}}connectEdges(a){const e=[],s=r=>r.slice(H.length),o=new Array;return this.inInstance.edges.forEach(r=>{const c=s(r.from),l=s(r.to);o.push({from:c,to:l});const h=C.OUTGOING_NODE_PREFIX+c,d=C.INCOMING_NODE_PREFIX+l;a.addEdge({id:k+`${h}-${d}`,from:h,to:d})}),e.push({id:"connect-edges",title:"Connect edges",description:`
                <p> 
                    For every original edge from node <i>a</i> to node <i>b</i>,
                    connect the node <i>a_out</i> with the node <i>b_in</i>.
                </p>
                <p>
                    In this particular case, add these edges:
                    <ul>
                        ${o.map(r=>`<li>(${r.from}_out, ${r.to}_in)</li>`).join("")}
                    </ul>
                </p>
            `,inSnapshot:this.inInstance.copy(),outSnapshot:a.copy(),mapping:{}}),{graph:a,steps:e}}createNodeTriplets(){const a=[],e=new ye;return this.inInstance.nodes.forEach((s,o)=>{const r=s.id.slice(H.length),c={x:this.radius*Math.cos(o*this.radStep-this.startRot-.2*this.radStep),y:this.radius*Math.sin(o*this.radStep-this.startRot-.2*this.radStep)},l={x:this.radius*Math.cos(o*this.radStep-this.startRot),y:this.radius*Math.sin(o*this.radStep-this.startRot)},h={x:this.radius*Math.cos(o*this.radStep-this.startRot+.2*this.radStep),y:this.radius*Math.sin(o*this.radStep-this.startRot+.2*this.radStep)},d={in:{id:C.INCOMING_NODE_PREFIX+r,position:c,classes:s.classes},gap:{id:C.GAP_NODE_PREFIX+r,position:l,classes:s.classes},out:{id:C.OUTGOING_NODE_PREFIX+r,position:h,classes:s.classes}};Object.values(d).forEach(U=>e.addNode(U)),e.addEdge({id:k+`${d.in.id}-${d.gap.id}`,from:d.in.id,to:d.gap.id}),e.addEdge({id:k+`${d.gap.id}-${d.out.id}`,from:d.gap.id,to:d.out.id})}),a.push({id:"create-node-triplets",title:"Create node triplets",description:`
                <p> 
                    For each node in the original graph,
                    create three nodes that represent:
                    <ul>
                        <li>
                            an in-coming node
                        </li>
                        <li>
                            a gap node
                        </li>
                        <li>
                            and an out-going node
                        </li>
                    </ul>
                </p>
                <p>
                    Connect the in-coming node with the gap-node and the gap-node with the out-going node.
                </p>
                <p>
                    For this particular graph there will be ${this.nodeCount} node ${this.nodeCount==1?"triplet":"triplets"}.
                    ${this.nodeCount==1?"The triplet is:":"The triplets are:"}
                    <ul>  
                        ${this.inInstance.nodes.map(s=>{const o=s.id.slice(H.length);return`
                                <li>
                                    ${o} - (
                                        ${C.INCOMING_NODE_PREFIX+o}, 
                                        ${C.GAP_NODE_PREFIX+o}, 
                                        ${C.OUTGOING_NODE_PREFIX+o}
                                    )
                                </li>
                            `}).join("")}
                    </ul>
                </p>
            `,inSnapshot:this.inInstance.copy(),outSnapshot:e.copy(),mapping:{}}),{graph:e,steps:a}}}var $e=F('<meta name="description" content="Reduction from HCYCLE to HCIRCUIT"/>'),Ye=F("<div><!></div> <!> <div><!></div>",1),Be=F("<span>There are no steps to step through.</span>"),ke=F('<div class="panes"><div><!> <!></div> <div><!> <!></div></div>'),Ve=F('<main><h1>HCYCLE to HCIRCUIT reduction</h1> <!> <div class="controls"><button>Reduce</button> <button><!></button> <input type="checkbox" name="showStepperCheckbox"/> <label for="showStepperCheckbox">Show steps</label></div> <!> <!></main>');function nt(O,a){he(a,!1);const e=()=>B(h,"$redStore",r),s=()=>B(U,"$isSolving",r),o=()=>B(d,"$showStepper",r),[r,c]=_e();let l=Ne(Se.LS_HCYCLE_HCIRCUIT,new Ae),{redStore:h,showStepper:d,isSolving:U,solveMessage:te,editorChanged:se,reduce:ne,solve:ae}=we({storage:l,workerUrl:new URL("data:video/mp2t;base64,Ly8gQ3JlYXRlZCBieSBwaGF0dC0yMyBvbiAyMS8xMC8yMDI1CgppbXBvcnQgeyBVbnNvbHZhYmxlIH0gZnJvbSAiJGxpYi9jb3JlL1Vuc29sdmFibGUiOwppbXBvcnQgeyBHcmFwaCB9IGZyb20gIiRsaWIvaW5zdGFuY2UvR3JhcGgiOwppbXBvcnQgeyBTb2x2ZXJIQ0lSQ1VJVCB9IGZyb20gIiRsaWIvc29sdmUvU29sdmVySENJUkNVSVQiOwoKc2VsZi5vbm1lc3NhZ2UgPSBhc3luYyAoZSkgPT4gewogICAgdHJ5IHsKICAgICAgICBjb25zb2xlLmRlYnVnKCdXb3JrZXJIQ0lSQ1VJVFNvbHZlcjo6b25tZXNzYWdlJyk7CiAgICAgICAgY29uc3QgaW5zdGFuY2UgOiBHcmFwaCA9IEdyYXBoLmZyb21TZXJpYWxpemVkU3RyaW5nKGUuZGF0YSk7CiAgICAgICAgY29uc3Qgc29sdmVyID0gbmV3IFNvbHZlckhDSVJDVUlUKGluc3RhbmNlKTsKICAgICAgICBjb25zdCByZXN1bHQgPSBzb2x2ZXIuc29sdmUoKTsKICAgICAgICBwb3N0TWVzc2FnZShyZXN1bHQgfHwgVW5zb2x2YWJsZSk7CiAgICB9CiAgICBjYXRjaCAoZSkgewogICAgICAgIHBvc3RNZXNzYWdlKHsKICAgICAgICAgICAgZXJyb3I6IHRydWUsCiAgICAgICAgICAgIG1lc3NhZ2U6IGUgaW5zdGFuY2VvZiBFcnJvciA/IGUubWVzc2FnZSA6IFN0cmluZyhlKQogICAgICAgIH0pOwogICAgfQp9Owo=",import.meta.url),reducerFactory:t=>new Ze(t),decoderFactory:()=>new ee,onSolveFinished:(t,n)=>{if(n==q){Ee(h,Q(e).inCert=q,Q(e));return}const u=new ee().decode(t,n),A=e().inInstance;A.labelSolved({path:u.path,directed:!1}),t.labelSolved({path:n.path,directed:!1}),h.update(_=>(_.inInstance=A,_.inCert=u,_.outCert=n,_.outInstance=t,_))}});He();var P=Ve();ue(t=>{var n=$e();ge.title="HCYCLE to HCIRCUIT",S(t,n)});var J=g(R(P),2);Oe(J,{get graph(){return e().inInstance},onChange:t=>se(t),onWrongFormat:t=>alert("From graph editor: "+t)});var D=g(J,2),X=R(D);X.__click=ne;var x=g(X,2);x.__click=ae;var oe=R(x);{var re=t=>{var n=Y("Solving...");S(t,n)},ie=t=>{var n=Y("Solve");S(t,n)};m(oe,t=>{s()?t(re):t(ie,!1)})}y(x);var M=g(x,2);be(M),K(2),y(D);var L=g(D,2);{var de=t=>{Ge(t,{children:(n,v)=>{K();var u=Y();W(()=>me(u,te)),S(n,u)}})};m(L,t=>{s()&&t(de)})}var ce=g(L,2);{var pe=t=>{const n=j(()=>e().steps),v=j(()=>e().stepIndex);var u=Ce(),A=z(u);{var _=f=>{var N=Ye(),G=z(N),Z=R(G);{var $=p=>{V(p,{get graph(){return b(n)[b(v)].inSnapshot},style:"DIRECTED",layout:"circle"})};m(Z,p=>{b(v)<b(n).length&&b(n)[b(v)].inSnapshot&&!b(n)[b(v)].inSnapshot.isEmpty()&&p($)})}y(G);var i=g(G,2);Fe(i,{get steps(){return e().steps},get stepIndex(){return e().stepIndex},onPrevClick:()=>{h.update(p=>(p.prevStep(),p)),l.save()},onNextClick:()=>{h.update(p=>(p.nextStep(),p)),l.save()}});var w=g(i,2),I=R(w);{var E=p=>{V(p,{get graph(){return e().steps[e().stepIndex].outSnapshot},style:"HCIRCUIT",layout:"preset"})};m(I,p=>{e().stepIndex<e().steps.length&&e().steps[e().stepIndex].outSnapshot&&p(E)})}y(w),S(f,N)},T=f=>{var N=Be();S(f,N)};m(A,f=>{b(n).length?f(_):f(T,!1)})}S(t,u)},le=t=>{var n=ke(),v=R(n),u=R(v);{var A=i=>{Ue(i,{get graph(){return e().inInstance},style:"DIRECTED",layout:"circle",directed:!0,onAddEdge:w=>{h.update(I=>{let E=I.inInstance;return E.addEdge(w),E.unlabelSolved(),I.reset(),I.setInInstance(E),I}),l.save()},onRemoveEdge:w=>{h.update(I=>{let E=I.inInstance;return E.removeEdgeById(w.id()),E.unlabelSolved(),I.reset(),I.setInInstance(E),I}),l.save()}})};m(u,i=>{e().inInstance&&!e().inInstance.isEmpty()&&i(A)})}var _=g(u,2);{var T=i=>{Xe(i,{get cert(){return e().inCert}})};m(_,i=>{e().inCert&&i(T)})}y(v);var f=g(v,2),N=R(f);{var G=i=>{V(i,{get graph(){return e().outInstance},style:"HCIRCUIT",layout:"preset"})};m(N,i=>{e().outInstance&&!e().outInstance.isEmpty()&&i(G)})}var Z=g(N,2);{var $=i=>{Pe(i,{get cert(){return e().outCert}})};m(Z,i=>{e().outCert&&i($)})}y(f),y(n),S(t,n)};m(ce,t=>{o()?t(pe):t(le,!1)})}y(P),W((t,n)=>{X.disabled=t,x.disabled=n},[()=>!e().hasInInstance()||e().hasOutInstance()||s(),()=>!e().hasInstances()||e().hasOutCertificate()||s()]),xe(M,o,t=>fe(d,t)),S(O,P),Ie(),c()}ve(["click"]);export{nt as component,st as universal};
