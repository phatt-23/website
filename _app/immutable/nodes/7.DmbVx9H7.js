import"../chunks/DsnmJJEf.js";import"../chunks/DVXSbgSC.js";import{p as le,f as P,J as ue,d as b,s as I,t as J,b as S,c as ge,$ as Ie,u as Q,r as y,K as z,am as B,an as ve,a as j,m as R,ac as K}from"../chunks/0h0eovDe.js";import{d as me,s as Ce}from"../chunks/BeBJMhcX.js";import{s as M,i as C,a as _e,b as fe,c as Ee}from"../chunks/E6MyXn9j.js";import{l as Se,r as Re}from"../chunks/CSnGU0Cu.js";import{N as F,H as v,R as be,E as Z,G as ye,u as Ne,a as we,c as xe,b as Oe,U as q,d as Ge,f as Pe}from"../chunks/C6qEDlbA.js";import{i as Fe}from"../chunks/DaAev7kg.js";import{E as Ue,R as $e,C as De}from"../chunks/BIUKchAi.js";import{C as He,a as Te}from"../chunks/DrV4eIYw.js";import{R as L}from"../chunks/Bnlbtspj.js";const Xe=!0,st=Object.freeze(Object.defineProperty({__proto__:null,prerender:Xe},Symbol.toStringTag,{value:"Module"}));class ee{decode(a,e){console.debug(e.path);const s=new Array;e.path.forEach(c=>{const h=this.getNodeName(c.id);s.push(h)});const o=new Array;let r;for(let c=0;c<s.length;c++)r!=s[c]&&(r=s[c],o.push({id:F+r}));return new He(o)}nodePrefixes=[v.INCOMING_NODE_PREFIX,v.OUTGOING_NODE_PREFIX,v.GAP_NODE_PREFIX];getNodeName(a){for(let e=0;e<this.nodePrefixes.length;e++){const s=this.nodePrefixes[e];if(a.startsWith(s))return a.slice(s.length)}throw new Error(`Encountered node that doesn't start with any of the legal prefixes: ${a}`)}}class Ye extends be{nodeDist=80;tripletDist=6*this.nodeDist;nodeCount;circum;radius;radStep;startRot;constructor(a){if(super(a),a.isEmpty())throw new Error("Reducer doesn't accept empty graphs (Graph with node nodes).");this.nodeCount=a.nodes.length,this.circum=this.tripletDist*this.nodeCount,this.radius=this.circum/(2*Math.PI),this.radStep=2*Math.PI/this.nodeCount,this.startRot=.5*Math.PI}doReduce(){const a=[],e=this.createNodeTriplets();a.push(...e.steps);const s=this.connectEdges(e.graph.copy());return a.push(...s.steps),{outInstance:s.graph,steps:a}}connectEdges(a){const e=[],s=r=>r.slice(F.length),o=new Array;return this.inInstance.edges.forEach(r=>{const c=s(r.from),h=s(r.to);o.push({from:c,to:h});const l=v.OUTGOING_NODE_PREFIX+c,d=v.INCOMING_NODE_PREFIX+h;a.addEdge({id:Z+`${l}-${d}`,from:l,to:d})}),e.push({id:"connect-edges",title:"Connect edges",description:`
                <p> 
                    For every original edge from node <i>a</i> to node <i>b</i>,
                    connect the node <i>a_out</i> with the node <i>b_in</i>.
                </p>
                <p>
                    In this particular case, add these edges:
                    <ul>
                        ${o.map(r=>`<li>(${r.from}_out, ${r.to}_in)</li>`).join("")}
                    </ul>
                </p>
            `,inSnapshot:this.inInstance.copy(),outSnapshot:a.copy(),mapping:{}}),{graph:a,steps:e}}createNodeTriplets(){const a=[],e=new ye;return this.inInstance.nodes.forEach((s,o)=>{const r=s.id.slice(F.length),c={x:this.radius*Math.cos(o*this.radStep-this.startRot-.2*this.radStep),y:this.radius*Math.sin(o*this.radStep-this.startRot-.2*this.radStep)},h={x:this.radius*Math.cos(o*this.radStep-this.startRot),y:this.radius*Math.sin(o*this.radStep-this.startRot)},l={x:this.radius*Math.cos(o*this.radStep-this.startRot+.2*this.radStep),y:this.radius*Math.sin(o*this.radStep-this.startRot+.2*this.radStep)},d={in:{id:v.INCOMING_NODE_PREFIX+r,position:c,classes:s.classes},gap:{id:v.GAP_NODE_PREFIX+r,position:h,classes:s.classes},out:{id:v.OUTGOING_NODE_PREFIX+r,position:l,classes:s.classes}};Object.values(d).forEach($=>e.addNode($)),e.addEdge({id:Z+`${d.in.id}-${d.gap.id}`,from:d.in.id,to:d.gap.id}),e.addEdge({id:Z+`${d.gap.id}-${d.out.id}`,from:d.gap.id,to:d.out.id})}),a.push({id:"create-node-triplets",title:"Create node triplets",description:`
                <p> 
                    For each node in the original graph,
                    create three nodes that represent:
                    <ul>
                        <li>
                            an in-coming node
                        </li>
                        <li>
                            a gap node
                        </li>
                        <li>
                            and an out-going node
                        </li>
                    </ul>
                </p>
                <p>
                    Connect the in-coming node with the gap-node and the gap-node with the out-going node.
                </p>
                <p>
                    For this particular graph there will be ${this.nodeCount} node ${this.nodeCount==1?"triplet":"triplets"}.
                    ${this.nodeCount==1?"The triplet is:":"The triplets are:"}
                    <ul>  
                        ${this.inInstance.nodes.map(s=>{const o=s.id.slice(F.length);return`
                                <li>
                                    ${o} - (
                                        ${v.INCOMING_NODE_PREFIX+o}, 
                                        ${v.GAP_NODE_PREFIX+o}, 
                                        ${v.OUTGOING_NODE_PREFIX+o}
                                    )
                                </li>
                            `}).join("")}
                    </ul>
                </p>
            `,inSnapshot:this.inInstance.copy(),outSnapshot:e.copy(),mapping:{}}),{graph:e,steps:a}}}var ke=P('<meta name="description" content="Reduction from HCYCLE to HCIRCUIT"/>'),Be=P("<div><!></div> <!> <div><!></div>",1),Me=P("<span>There are no steps to step through.</span>"),Ze=P('<div class="panes"><div><!> <!></div> <div><!> <!></div></div>'),Le=P('<main><h1>HCYCLE to HCIRCUIT reduction</h1> <!> <div class="controls"><button>Reduce</button> <button><!></button> <input type="checkbox" name="showStepperCheckbox"/> <label for="showStepperCheckbox">Show steps</label></div> <!> <!></main>');function nt(U,a){le(a,!1);const e=()=>M(l,"$redStore",r),s=()=>M($,"$isSolving",r),o=()=>M(d,"$showStepper",r),[r,c]=_e();let h=Ne(Se.LS_HCYCLE_HCIRCUIT,new we),{redStore:l,showStepper:d,isSolving:$,solveMessage:te,editorChanged:se,reduce:ne,solve:ae}=xe({storage:h,workerUrl:new URL("data:video/mp2t;base64,Ly8gQ3JlYXRlZCBieSBwaGF0dC0yMyBvbiAyMS8xMC8yMDI1CgppbXBvcnQgeyBVbnNvbHZhYmxlIH0gZnJvbSAiJGxpYi9jb3JlL1Vuc29sdmFibGUiOwppbXBvcnQgeyBHcmFwaCB9IGZyb20gIiRsaWIvaW5zdGFuY2UvR3JhcGgiOwppbXBvcnQgeyBTb2x2ZXJIQ0lSQ1VJVCB9IGZyb20gIiRsaWIvc29sdmUvU29sdmVySENJUkNVSVQiOwoKc2VsZi5vbm1lc3NhZ2UgPSBhc3luYyAoZSkgPT4gewogICAgY29uc3QgaW5zdGFuY2UgOiBHcmFwaCA9IEdyYXBoLmZyb21TZXJpYWxpemVkU3RyaW5nKGUuZGF0YSk7CiAgICBjb25zdCBzb2x2ZXIgPSBuZXcgU29sdmVySENJUkNVSVQoaW5zdGFuY2UpOwogICAgY29uc3QgcmVzdWx0ID0gc29sdmVyLnNvbHZlKCk7CiAgICBwb3N0TWVzc2FnZShyZXN1bHQgfHwgVW5zb2x2YWJsZSk7Cn07Cg==",import.meta.url),reducerFactory:t=>new Ye(t),decoderFactory:()=>new ee,onSolveFinished:(t,n)=>{if(n==q){Ee(l,Q(e).inCert=q,Q(e));return}const u=new ee().decode(t,n),w=e().inInstance;w.labelSolved({path:u.path,directed:!1}),t.labelSolved({path:n.path,directed:!1}),l.update(_=>(_.inInstance=w,_.inCert=u,_.outCert=n,_.outInstance=t,_))}});Fe();var D=Le();ue(t=>{var n=ke();Ie.title="HCYCLE to HCIRCUIT",S(t,n)});var V=I(b(D),2);Ue(V,{get graph(){return e().inInstance},onChange:t=>se(t),onWrongFormat:t=>alert("From graph editor: "+t)});var H=I(V,2),T=b(H);T.__click=ne;var O=I(T,2);O.__click=ae;var oe=b(O);{var re=t=>{var n=B("Solving...");S(t,n)},ie=t=>{var n=B("Solve");S(t,n)};C(oe,t=>{s()?t(re):t(ie,!1)})}y(O);var A=I(O,2);Re(A),z(2),y(H);var W=I(H,2);{var de=t=>{Ge(t,{children:(n,m)=>{z();var u=B();J(()=>Ce(u,te)),S(n,u)}})};C(W,t=>{s()&&t(de)})}var ce=I(W,2);{var pe=t=>{const n=K(()=>e().steps),m=K(()=>e().stepIndex);var u=ve(),w=j(u);{var _=f=>{var N=Be(),G=j(N),Y=b(G);{var k=p=>{L(p,{get graph(){return R(n)[R(m)].inSnapshot},style:"DIRECTED",layout:"circle"})};C(Y,p=>{R(m)<R(n).length&&R(n)[R(m)].inSnapshot&&!R(n)[R(m)].inSnapshot.isEmpty()&&p(k)})}y(G);var i=I(G,2);Pe(i,{get steps(){return e().steps},get stepIndex(){return e().stepIndex},onPrevClick:()=>{l.update(p=>(p.prevStep(),p)),h.save()},onNextClick:()=>{l.update(p=>(p.nextStep(),p)),h.save()}});var x=I(i,2),g=b(x);{var E=p=>{L(p,{get graph(){return e().steps[e().stepIndex].outSnapshot},style:"HCIRCUIT",layout:"preset"})};C(g,p=>{e().stepIndex<e().steps.length&&e().steps[e().stepIndex].outSnapshot&&p(E)})}y(x),S(f,N)},X=f=>{var N=Me();S(f,N)};C(w,f=>{R(n).length?f(_):f(X,!1)})}S(t,u)},he=t=>{var n=Ze(),m=b(n),u=b(m);{var w=i=>{$e(i,{get graph(){return e().inInstance},style:"DIRECTED",layout:"circle",directed:!0,onAddEdge:x=>{l.update(g=>{let E=g.inInstance;return E.addEdge(x),E.unlabelSolved(),g.reset(),g.setInInstance(E),g}),h.save()},onRemoveEdge:x=>{l.update(g=>{let E=g.inInstance;return E.removeEdgeById(x.id()),E.unlabelSolved(),g.reset(),g.setInInstance(E),g}),h.save()}})};C(u,i=>{e().inInstance&&!e().inInstance.isEmpty()&&i(w)})}var _=I(u,2);{var X=i=>{Te(i,{get cert(){return e().inCert}})};C(_,i=>{e().inCert&&i(X)})}y(m);var f=I(m,2),N=b(f);{var G=i=>{L(i,{get graph(){return e().outInstance},style:"HCIRCUIT",layout:"preset"})};C(N,i=>{e().outInstance&&!e().outInstance.isEmpty()&&i(G)})}var Y=I(N,2);{var k=i=>{De(i,{get cert(){return e().outCert}})};C(Y,i=>{e().outCert&&i(k)})}y(f),y(n),S(t,n)};C(ce,t=>{o()?t(pe):t(he,!1)})}y(D),J((t,n)=>{T.disabled=t,O.disabled=n},[()=>!e().hasInInstance()||e().hasOutInstance()||s(),()=>!e().hasInstances()||e().hasOutCertificate()||s()]),Oe(A,o,t=>fe(d,t)),S(U,D),ge(),c()}me(["click"]);export{nt as component,st as universal};
