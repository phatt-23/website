import"../chunks/DsnmJJEf.js";import"../chunks/DVXSbgSC.js";import{p as he,f as H,J as ue,d as R,s as I,t as Q,b as S,c as ge,$ as Ie,u as W,r as y,K,am as B,an as ve,a as j,m as b,ac as z}from"../chunks/0h0eovDe.js";import{d as Ce,s as me}from"../chunks/BeBJMhcX.js";import{s as Z,i as m,a as _e,b as fe,c as Ee}from"../chunks/E6MyXn9j.js";import{l as Se,r as be}from"../chunks/CSnGU0Cu.js";import{N as P,H as v,R as Re,E as k,G as ye,u as Ne,a as we,c as xe,b as Oe,U as q,d as Ge,f as He}from"../chunks/DCk9rHG9.js";import{i as Pe}from"../chunks/DaAev7kg.js";import{E as Fe,R as Ue,C as Ae}from"../chunks/Bs7IJ1ml.js";import{C as De,a as Te}from"../chunks/8Ke2ApCb.js";import{R as M}from"../chunks/YqW4Rh_A.js";const Xe=!0,st=Object.freeze(Object.defineProperty({__proto__:null,prerender:Xe},Symbol.toStringTag,{value:"Module"}));class ee{decode(a,e){console.debug(e.path);const s=new Array;e.path.forEach(c=>{const l=this.getNodeName(c.id);s.push(l)});const o=new Array;let r;for(let c=0;c<s.length;c++)r!=s[c]&&(r=s[c],o.push({id:P+r}));return new De(o)}nodePrefixes=[v.INCOMING_NODE_PREFIX,v.OUTGOING_NODE_PREFIX,v.GAP_NODE_PREFIX];getNodeName(a){for(let e=0;e<this.nodePrefixes.length;e++){const s=this.nodePrefixes[e];if(a.startsWith(s))return a.slice(s.length)}throw new Error(`Encountered node that doesn't start with any of the legal prefixes: ${a}`)}}class $e extends Re{nodeDist=80;tripletDist=6*this.nodeDist;nodeCount;circum;radius;radStep;startRot;constructor(a){if(super(a),a.isEmpty())throw new Error("Reducer doesn't accept empty graphs (Graph with node nodes).");this.nodeCount=a.nodes.length,this.circum=this.tripletDist*this.nodeCount,this.radius=this.circum/(2*Math.PI),this.radStep=2*Math.PI/this.nodeCount,this.startRot=.5*Math.PI}doReduce(){const a=[],e=this.createNodeTriplets();a.push(...e.steps);const s=this.connectEdges(e.graph.copy());return a.push(...s.steps),{outInstance:s.graph,steps:a}}connectEdges(a){const e=[],s=r=>r.slice(P.length),o=new Array;return this.inInstance.edges.forEach(r=>{const c=s(r.from),l=s(r.to);o.push({from:c,to:l});const h=v.OUTGOING_NODE_PREFIX+c,d=v.INCOMING_NODE_PREFIX+l;a.addEdge({id:k+`${h}-${d}`,from:h,to:d})}),e.push({id:"connect-edges",title:"Connect edges",description:`
                <p> 
                    For every original edge from node <i>a</i> to node <i>b</i>,
                    connect the node <i>a_out</i> with the node <i>b_in</i>.
                </p>
                <p>
                    In this particular case, add these edges:
                    <ul>
                        ${o.map(r=>`<li>(${r.from}_out, ${r.to}_in)</li>`).join("")}
                    </ul>
                </p>
            `,inSnapshot:this.inInstance.copy(),outSnapshot:a.copy(),mapping:{}}),{graph:a,steps:e}}createNodeTriplets(){const a=[],e=new ye;return this.inInstance.nodes.forEach((s,o)=>{const r=s.id.slice(P.length),c={x:this.radius*Math.cos(o*this.radStep-this.startRot-.2*this.radStep),y:this.radius*Math.sin(o*this.radStep-this.startRot-.2*this.radStep)},l={x:this.radius*Math.cos(o*this.radStep-this.startRot),y:this.radius*Math.sin(o*this.radStep-this.startRot)},h={x:this.radius*Math.cos(o*this.radStep-this.startRot+.2*this.radStep),y:this.radius*Math.sin(o*this.radStep-this.startRot+.2*this.radStep)},d={in:{id:v.INCOMING_NODE_PREFIX+r,position:c,classes:s.classes},gap:{id:v.GAP_NODE_PREFIX+r,position:l,classes:s.classes},out:{id:v.OUTGOING_NODE_PREFIX+r,position:h,classes:s.classes}};Object.values(d).forEach(U=>e.addNode(U)),e.addEdge({id:k+`${d.in.id}-${d.gap.id}`,from:d.in.id,to:d.gap.id}),e.addEdge({id:k+`${d.gap.id}-${d.out.id}`,from:d.gap.id,to:d.out.id})}),a.push({id:"create-node-triplets",title:"Create node triplets",description:`
                <p> 
                    For each node in the original graph,
                    create three nodes that represent:
                    <ul>
                        <li>
                            an in-coming node
                        </li>
                        <li>
                            a gap node
                        </li>
                        <li>
                            and an out-going node
                        </li>
                    </ul>
                </p>
                <p>
                    Connect the in-coming node with the gap-node and the gap-node with the out-going node.
                </p>
                <p>
                    For this particular graph there will be ${this.nodeCount} node ${this.nodeCount==1?"triplet":"triplets"}.
                    ${this.nodeCount==1?"The triplet is:":"The triplets are:"}
                    <ul>  
                        ${this.inInstance.nodes.map(s=>{const o=s.id.slice(P.length);return`
                                <li>
                                    ${o} - (
                                        ${v.INCOMING_NODE_PREFIX+o}, 
                                        ${v.GAP_NODE_PREFIX+o}, 
                                        ${v.OUTGOING_NODE_PREFIX+o}
                                    )
                                </li>
                            `}).join("")}
                    </ul>
                </p>
            `,inSnapshot:this.inInstance.copy(),outSnapshot:e.copy(),mapping:{}}),{graph:e,steps:a}}}var Ye=H('<meta name="description" content="Reduction from HCYCLE to HCIRCUIT"/>'),Be=H("<div><!></div> <!> <div><!></div>",1),Ze=H("<span>There are no steps to step through.</span>"),ke=H('<div class="panes"><div><!> <!></div> <div><!> <!></div></div>'),Me=H('<main><h1>HCYCLE to HCIRCUIT reduction</h1> <!> <div class="controls"><button>Reduce</button> <button><!></button> <input type="checkbox" name="showStepperCheckbox"/> <label for="showStepperCheckbox">Show steps</label></div> <!> <!></main>');function nt(F,a){he(a,!1);const e=()=>Z(h,"$redStore",r),s=()=>Z(U,"$isSolving",r),o=()=>Z(d,"$showStepper",r),[r,c]=_e();let l=Ne(Se.LS_HCYCLE_HCIRCUIT,new we),{redStore:h,showStepper:d,isSolving:U,solveMessage:te,editorChanged:se,reduce:ne,solve:ae}=xe({storage:l,workerUrl:new URL("data:video/mp2t;base64,Ly8gQ3JlYXRlZCBieSBwaGF0dC0yMyBvbiAyMS8xMC8yMDI1CgppbXBvcnQgeyBVbnNvbHZhYmxlIH0gZnJvbSAiJGxpYi9jb3JlL1Vuc29sdmFibGUiOwppbXBvcnQgeyBHcmFwaCB9IGZyb20gIiRsaWIvaW5zdGFuY2UvR3JhcGgiOwppbXBvcnQgeyBTb2x2ZXJIQ0lSQ1VJVCB9IGZyb20gIiRsaWIvc29sdmUvU29sdmVySENJUkNVSVQiOwoKc2VsZi5vbm1lc3NhZ2UgPSBhc3luYyAoZSkgPT4gewogICAgdHJ5IHsKICAgICAgICBjb25zb2xlLmRlYnVnKCdXb3JrZXJIQ0lSQ1VJVFNvbHZlcjo6b25tZXNzYWdlJyk7CiAgICAgICAgY29uc3QgaW5zdGFuY2UgOiBHcmFwaCA9IEdyYXBoLmZyb21TZXJpYWxpemVkU3RyaW5nKGUuZGF0YSk7CiAgICAgICAgY29uc3Qgc29sdmVyID0gbmV3IFNvbHZlckhDSVJDVUlUKGluc3RhbmNlKTsKICAgICAgICBjb25zdCByZXN1bHQgPSBzb2x2ZXIuc29sdmUoKTsKICAgICAgICBwb3N0TWVzc2FnZShyZXN1bHQgfHwgVW5zb2x2YWJsZSk7CiAgICB9CiAgICBjYXRjaCAoZSkgewogICAgICAgIHBvc3RNZXNzYWdlKGUpOwogICAgfQp9Owo=",import.meta.url),reducerFactory:t=>new $e(t),decoderFactory:()=>new ee,onSolveFinished:(t,n)=>{if(n==q){Ee(h,W(e).inCert=q,W(e));return}const u=new ee().decode(t,n),w=e().inInstance;w.labelSolved({path:u.path,directed:!1}),t.labelSolved({path:n.path,directed:!1}),h.update(_=>(_.inInstance=w,_.inCert=u,_.outCert=n,_.outInstance=t,_))}});Pe();var A=Me();ue(t=>{var n=Ye();Ie.title="HCYCLE to HCIRCUIT",S(t,n)});var V=I(R(A),2);Fe(V,{get graph(){return e().inInstance},onChange:t=>se(t),onWrongFormat:t=>alert("From graph editor: "+t)});var D=I(V,2),T=R(D);T.__click=ne;var O=I(T,2);O.__click=ae;var oe=R(O);{var re=t=>{var n=B("Solving...");S(t,n)},ie=t=>{var n=B("Solve");S(t,n)};m(oe,t=>{s()?t(re):t(ie,!1)})}y(O);var J=I(O,2);be(J),K(2),y(D);var L=I(D,2);{var de=t=>{Ge(t,{children:(n,C)=>{K();var u=B();Q(()=>me(u,te)),S(n,u)}})};m(L,t=>{s()&&t(de)})}var ce=I(L,2);{var pe=t=>{const n=z(()=>e().steps),C=z(()=>e().stepIndex);var u=ve(),w=j(u);{var _=f=>{var N=Be(),G=j(N),$=R(G);{var Y=p=>{M(p,{get graph(){return b(n)[b(C)].inSnapshot},style:"DIRECTED",layout:"circle"})};m($,p=>{b(C)<b(n).length&&b(n)[b(C)].inSnapshot&&!b(n)[b(C)].inSnapshot.isEmpty()&&p(Y)})}y(G);var i=I(G,2);He(i,{get steps(){return e().steps},get stepIndex(){return e().stepIndex},onPrevClick:()=>{h.update(p=>(p.prevStep(),p)),l.save()},onNextClick:()=>{h.update(p=>(p.nextStep(),p)),l.save()}});var x=I(i,2),g=R(x);{var E=p=>{M(p,{get graph(){return e().steps[e().stepIndex].outSnapshot},style:"HCIRCUIT",layout:"preset"})};m(g,p=>{e().stepIndex<e().steps.length&&e().steps[e().stepIndex].outSnapshot&&p(E)})}y(x),S(f,N)},X=f=>{var N=Ze();S(f,N)};m(w,f=>{b(n).length?f(_):f(X,!1)})}S(t,u)},le=t=>{var n=ke(),C=R(n),u=R(C);{var w=i=>{Ue(i,{get graph(){return e().inInstance},style:"DIRECTED",layout:"circle",directed:!0,onAddEdge:x=>{h.update(g=>{let E=g.inInstance;return E.addEdge(x),E.unlabelSolved(),g.reset(),g.setInInstance(E),g}),l.save()},onRemoveEdge:x=>{h.update(g=>{let E=g.inInstance;return E.removeEdgeById(x.id()),E.unlabelSolved(),g.reset(),g.setInInstance(E),g}),l.save()}})};m(u,i=>{e().inInstance&&!e().inInstance.isEmpty()&&i(w)})}var _=I(u,2);{var X=i=>{Te(i,{get cert(){return e().inCert}})};m(_,i=>{e().inCert&&i(X)})}y(C);var f=I(C,2),N=R(f);{var G=i=>{M(i,{get graph(){return e().outInstance},style:"HCIRCUIT",layout:"preset"})};m(N,i=>{e().outInstance&&!e().outInstance.isEmpty()&&i(G)})}var $=I(N,2);{var Y=i=>{Ae(i,{get cert(){return e().outCert}})};m($,i=>{e().outCert&&i(Y)})}y(f),y(n),S(t,n)};m(ce,t=>{o()?t(pe):t(le,!1)})}y(A),Q((t,n)=>{T.disabled=t,O.disabled=n},[()=>!e().hasInInstance()||e().hasOutInstance()||s(),()=>!e().hasInstances()||e().hasOutCertificate()||s()]),Oe(J,o,t=>fe(d,t)),S(F,A),ge(),c()}Ce(["click"]);export{nt as component,st as universal};
