import"../chunks/DsnmJJEf.js";import"../chunks/7c8ahxPy.js";import{p as ce,f as S,s as l,d as I,r as h,b as i,c as pe,a as Q,K as V,m as g,L as Ie,M as Se,t as j,J as Ce,$ as be,u as ne,an as X,ao as we,ac as ae}from"../chunks/BHy43uIv.js";import{s as Y,d as ye}from"../chunks/Bo-e_C1i.js";import{i as _,s as A,a as xe,b as Re,c as Te}from"../chunks/lPMcd3W4.js";import{r as le,l as Ee}from"../chunks/hAUU4et8.js";import{U as ee,b as he,e as oe,i as re,S as ke,R as Pe,E as ie,u as $e,l as Ue,m as We,n as Oe,W as De,o as Fe,p as He}from"../chunks/CdN2dGYn.js";import{i as Le}from"../chunks/Bic1S2_H.js";import{E as Me,R as Ae,C as je}from"../chunks/cgj_CQk6.js";import{h as Ne}from"../chunks/_9mKL30m.js";import{R as Z}from"../chunks/C8rFwzaR.js";const qe=!0,_t=Object.freeze(Object.defineProperty({__proto__:null,prerender:qe},Symbol.toStringTag,{value:"Module"}));var ze=S("<p>The graph doesn't contain a Hamiltonian cycle with the given cost.</p>"),Ge=S("<li> </li>"),Ke=S("<ol></ol>"),Be=S("<span><!> </span>"),Je=S("<div></div>"),Xe=S('<div class="controls"><input type="checkbox" name="showAsListCheckbox"/> <label for="showAsListCheckbox">Show as list</label></div> <!>',1),Ze=S("<main><h2>CertRenderer TSP</h2> <!></main>");function Qe(m,s){ce(s,!0);let e=Ie(!0);var a=Ze(),d=l(I(a),2);{var o=f=>{var p=ze();i(f,p)},v=f=>{var p=Xe(),c=Q(p),$=I(c);le($),V(2),h(c);var L=l(c,2);{var q=w=>{var x=Ke();oe(x,21,()=>s.cert.path,re,(W,D)=>{var R=Ge(),T=I(R,!0);h(R),j(()=>Y(T,g(D).id)),i(W,R)}),h(x),i(w,x)},z=w=>{var x=Je();oe(x,21,()=>s.cert.path,re,(W,D,R)=>{var T=Be(),U=I(T);Ne(U,()=>R!=0?"&ThinSpace;&LongRightArrow;&ThinSpace;":"");var G=l(U);h(T),j(()=>Y(G,` ${g(D).id??""}`)),i(W,T)}),h(x),i(w,x)};_(L,w=>{g(e)?w(q):w(z,!1)})}he($,()=>g(e),w=>Se(e,w)),i(f,p)};_(d,f=>{s.cert==ee?f(o):f(v,!1)})}h(a),i(m,a),pe()}var Ve=Object.getOwnPropertyDescriptor,Ye=(m,s,e,a)=>{for(var d=a>1?void 0:a?Ve(s,e):s,o=m.length-1,v;o>=0;o--)(v=m[o])&&(d=v(d)||d);return d};let N=class{path;constructor(m){this.path=m}};N=Ye([ke.SerializableClass()],N);class de{decode(s,e){return new N(e.path)}}class et extends Pe{nodeCount;constructor(s){super(s),this.nodeCount=this.inInstance.nodes.length}copyOver(s){const e=[];return e.push({id:"copy-over",title:"Copy over the original graph",description:"",mapping:{},inSnapshot:this.inInstance.copy(),outSnapshot:s}),{graph:s,steps:e}}assignWeightsToExisting(s){const e=[];return s.edges.forEach(a=>{a.weight=1,a.classes+=" solid"}),e.push({id:"assign-weight-1",title:"Assign weights to existing edges",description:`
                <p>
                    For each edge that was in the original graph now assign the weight 1.
                </p>
            `,mapping:{},inSnapshot:this.inInstance.copy(),outSnapshot:s}),{graph:s,steps:e}}addMissingEdges(s){const e=[],a=new Set(this.inInstance.edges.map(o=>o.id));console.debug("idgeIds.values()",[...a.values()]);const d=this.inInstance.nodes.map(o=>(s.addNode(o),o.id));for(let o=0;o<s.nodes.length;o++)for(let v=o+1;v<s.nodes.length;v++){const f=d[o],p=d[v],c=ie+`${f}-${p}`,$=ie+`${p}-${f}`,L=a.has(c)||a.has($);console.debug("check existence of",c,$),L||s.addEdge({id:c,from:f,to:p,weight:2,classes:"muted"})}return e.push({id:"add-missing-edges",title:"Add missing edges",description:`
                <p>
                    Connect all the nodes that weren't connect before by a new edge and assign a weight of 2 to this new edge.
                </p>
            `,mapping:{},inSnapshot:this.inInstance.copy(),outSnapshot:s}),{graph:s,steps:e}}doReduce(){const s=[];s.push({id:"reduce-hcircuit-to-tsp-1",title:"Create complete graph",description:`
                <p> 
                    Take all of the nodes from the original graph and add an edge between each of them (make a complete graph).
                    For every edge that exists in the original instance, assign a weight of 1.
                    Otherwise assign some weight larger than 1.
                </p>
                <p>
                    There is ${this.nodeCount} nodes, 
                    which means there will be (${this.nodeCount} * ${this.nodeCount-1}) / 2 = ${this.nodeCount*(this.nodeCount-1)/2} edges, 
                    for it to be complete.
                </p>
                <p>
                    Now this problem can expressed by a decision question:
                    Is there a hamiltonian cycle such that the cost of the traversal is less than or equal to ${this.nodeCount}?
                </p>
            `,inSnapshot:this.inInstance.copy(),mapping:{}});const e=this.copyOver(this.inInstance.copy());s.push(...e.steps);const a=this.assignWeightsToExisting(e.graph.copy());s.push(...a.steps);const d=this.addMissingEdges(a.graph.copy());return s.push(...d.steps),{outInstance:d.graph,steps:s}}}function tt(m){return new Worker(""+new URL("../workers/WorkerTSPSolver-CIbZEHyn.js",import.meta.url).href,{name:m?.name})}var st=S('<meta name="description" content="Reduction from HCIRCUIT to TSP"/>'),nt=S("<div><!></div> <!> <div><!></div>",1),at=S("<span>There are no steps to step through.</span>"),ot=S('<div class="panes"><div><!> <!></div> <div><!> <!></div></div>'),rt=S('<main><h1>HCIRCUIT to TSP reduction</h1> <!> <div class="controls"><button>Reduce</button> <button><!></button> <input type="checkbox" name="showStepperCheckbox"/> <label for="showStepperCheckbox">Show steps</label></div> <!> <!></main>');function It(m,s){ce(s,!1);const e=()=>A(c,"$redStore",v),a=()=>A(L,"$isSolving",v),d=()=>A($,"$showStepper",v),o=()=>A(q,"$solveMessage",v),[v,f]=xe();let p=$e(Ee.LS_HCIRCUIT_TSP,new Ue),{redStore:c,showStepper:$,isSolving:L,solveMessage:q,editorChanged:z,reduce:w,solve:x}=We({storage:p,workerFactory:()=>new tt,reducerFactory:t=>new et(t),decoderFactory:()=>new de,createWorkerRequest:t=>({graph:t.toSerializedString(),maxCost:t.nodes.length}),resolveWorkerResponse:t=>{const n=t;return Oe(n.type==De.RESULT),new N(n.path)},onSolveFinished:(t,n)=>{if(n==ee){Te(c,ne(e).inCert=ee,ne(e));return}const C=new de().decode(t,n),F=e().inInstance;F.labelSolved({path:C.path,directed:!1}),t.labelSolved({path:n.path,directed:!1}),c.update(E=>(E.inInstance=F,E.inCert=C,E.outCert=n,E.outInstance=t,E))}});Le();var W=rt();Ce(t=>{var n=st();be.title="HCIRCUIT to TSP",i(t,n)});var D=l(I(W),2);Me(D,{get graph(){return e().inInstance},onChange:t=>z(t),onWrongFormat:t=>alert("From graph editor: "+t)});var R=l(D,2),T=I(R);T.__click=w;var U=l(T,2);U.__click=x;var G=I(U);{var ve=t=>{var n=X("Solving...");i(t,n)},ue=t=>{var n=X("Solve");i(t,n)};_(G,t=>{a()?t(ve):t(ue,!1)})}h(U);var te=l(U,2);le(te),V(2),h(R);var se=l(R,2);{var ge=t=>{Fe(t,{children:(n,y)=>{V();var C=X();j(()=>Y(C,o())),i(n,C)}})};_(se,t=>{a()&&t(ge)})}var me=l(se,2);{var fe=t=>{const n=ae(()=>e().steps),y=ae(()=>e().stepIndex);var C=we(),F=Q(C);{var E=k=>{var O=nt(),M=Q(O),B=I(M);{var J=u=>{Z(u,{get graph(){return g(n)[g(y)].inSnapshot},style:"UNDIRECTED",layout:"circle"})};_(B,u=>{g(y)<g(n).length&&g(n)[g(y)].inSnapshot&&!g(n)[g(y)].inSnapshot.isEmpty()&&u(J)})}h(M);var r=l(M,2);He(r,{get steps(){return e().steps},get stepIndex(){return e().stepIndex},onPrevClick:()=>{c.update(u=>(u.prevStep(),u)),p.save()},onNextClick:()=>{c.update(u=>(u.nextStep(),u)),p.save()}});var H=l(r,2),b=I(H);{var P=u=>{Z(u,{get graph(){return e().steps[e().stepIndex].outSnapshot},style:"TSP",layout:"circle"})};_(b,u=>{e().stepIndex<e().steps.length&&e().steps[e().stepIndex].outSnapshot&&u(P)})}h(H),i(k,O)},K=k=>{var O=at();i(k,O)};_(F,k=>{g(n).length?k(E):k(K,!1)})}i(t,C)},_e=t=>{var n=ot(),y=I(n),C=I(y);{var F=r=>{Ae(r,{get graph(){return e().inInstance},style:"UNDIRECTED",layout:"circle",onAddEdge:H=>{c.update(b=>{let P=b.inInstance;return P.addEdge(H),P.unlabelSolved(),b.reset(),b.setInInstance(P),b}),p.save()},onRemoveEdge:H=>{c.update(b=>{let P=b.inInstance;return P.removeEdgeById(H.id()),P.unlabelSolved(),b.reset(),b.setInInstance(P),b}),p.save()}})};_(C,r=>{e().inInstance&&!e().inInstance.isEmpty()&&r(F)})}var E=l(C,2);{var K=r=>{je(r,{get cert(){return e().inCert}})};_(E,r=>{e().inCert&&r(K)})}h(y);var k=l(y,2),O=I(k);{var M=r=>{Z(r,{get graph(){return e().outInstance},style:"TSP",layout:"circle"})};_(O,r=>{e().outInstance&&!e().outInstance.isEmpty()&&r(M)})}var B=l(O,2);{var J=r=>{Qe(r,{get cert(){return e().outCert}})};_(B,r=>{e().outCert&&r(J)})}h(k),h(n),i(t,n)};_(me,t=>{d()?t(fe):t(_e,!1)})}h(W),j((t,n)=>{T.disabled=t,U.disabled=n},[()=>!e().hasInInstance()||e().hasOutInstance()||a(),()=>!e().hasInstances()||e().hasOutCertificate()||a()]),he(te,d,t=>Re($,t)),i(m,W),pe(),f()}ye(["click"]);export{It as component,_t as universal};
