import"../chunks/DsnmJJEf.js";import"../chunks/DVXSbgSC.js";import{p as de,f as b,s as l,d as C,r as h,b as i,c as pe,a as K,K as V,m as u,L as be,M as Se,t as z,J as fe,$ as _e,u as ne,am as M,an as we,ac as ae}from"../chunks/0h0eovDe.js";import{s as Q,d as ye}from"../chunks/BeBJMhcX.js";import{i as m,s as P,a as xe,b as Re,c as Te}from"../chunks/E6MyXn9j.js";import{r as le,l as Ze}from"../chunks/CSnGU0Cu.js";import{U as q,b as he,e as oe,i as re,S as Ae,R as Ge,E as ie,u as Ee,a as ke,c as Ue,d as Be,f as Fe}from"../chunks/uz1bvOJO.js";import{i as Ne}from"../chunks/DaAev7kg.js";import{E as He,R as We,C as Je}from"../chunks/C15Ak6db.js";import{h as Pe}from"../chunks/Bp5AzgID.js";import{R as j}from"../chunks/C6222NCp.js";const ze=!0,ut=Object.freeze(Object.defineProperty({__proto__:null,prerender:ze},Symbol.toStringTag,{value:"Module"}));var Oe=b("<p>The graph doesn't contain a Hamiltonian cycle with the given cost.</p>"),Xe=b("<li> </li>"),Ye=b("<ol></ol>"),$e=b("<span><!> </span>"),De=b("<div></div>"),Le=b('<div class="controls"><input type="checkbox" name="showAsListCheckbox"/> <label for="showAsListCheckbox">Show as list</label></div> <!>',1),Me=b("<main><h2>CertRenderer TSP</h2> <!></main>");function je(_,s){de(s,!0);let e=be(!0);var a=Me(),c=l(C(a),2);{var o=I=>{var p=Oe();i(I,p)},g=I=>{var p=Le(),d=K(p),E=C(d);le(E),V(2),h(d);var W=l(d,2);{var O=w=>{var x=Ye();oe(x,21,()=>s.cert.path,re,(U,F)=>{var R=Xe(),T=C(R,!0);h(R),z(()=>Q(T,u(F).id)),i(U,R)}),h(x),i(w,x)},X=w=>{var x=De();oe(x,21,()=>s.cert.path,re,(U,F,R)=>{var T=$e(),k=C(T);Pe(k,()=>R!=0?"&ThinSpace;&LongRightArrow;&ThinSpace;":"");var Y=l(k);h(T),z(()=>Q(Y,` ${u(F).id??""}`)),i(U,T)}),h(x),i(w,x)};m(W,w=>{u(e)?w(O):w(X,!1)})}he(E,()=>u(e),w=>Se(e,w)),i(I,p)};m(c,I=>{s.cert==q?I(o):I(g,!1)})}h(a),i(_,a),pe()}var Ke=Object.getOwnPropertyDescriptor,Ve=(_,s,e,a)=>{for(var c=a>1?void 0:a?Ke(s,e):s,o=_.length-1,g;o>=0;o--)(g=_[o])&&(c=g(c)||c);return c};let ee=class{path;constructor(_){this.path=_}};ee=Ve([Ae.SerializableClass()],ee);class ce{decode(s,e){return new ee(e.path)}}class Qe extends Ge{nodeCount;constructor(s){super(s),this.nodeCount=this.inInstance.nodes.length}copyOver(s){const e=[];return e.push({id:"copy-over",title:"Copy over the original graph",description:"",mapping:{},inSnapshot:this.inInstance.copy(),outSnapshot:s}),{graph:s,steps:e}}assignWeightsToExisting(s){const e=[];return s.edges.forEach(a=>{a.weight=1,a.classes+=" solid"}),e.push({id:"assign-weight-1",title:"Assign weights to existing edges",description:`
                <p>
                    For each edge that was in the original graph now assign the weight 1.
                </p>
            `,mapping:{},inSnapshot:this.inInstance.copy(),outSnapshot:s}),{graph:s,steps:e}}addMissingEdges(s){const e=[],a=new Set(this.inInstance.edges.map(o=>o.id));console.debug("idgeIds.values()",[...a.values()]);const c=this.inInstance.nodes.map(o=>(s.addNode(o),o.id));for(let o=0;o<s.nodes.length;o++)for(let g=o+1;g<s.nodes.length;g++){const I=c[o],p=c[g],d=ie+`${I}-${p}`,E=ie+`${p}-${I}`,W=a.has(d)||a.has(E);console.debug("check existence of",d,E),W||s.addEdge({id:d,from:I,to:p,weight:2,classes:"muted"})}return e.push({id:"add-missing-edges",title:"Add missing edges",description:`
                <p>
                    Connect all the nodes that weren't connect before by a new edge and assign a weight of 2 to this new edge.
                </p>
            `,mapping:{},inSnapshot:this.inInstance.copy(),outSnapshot:s}),{graph:s,steps:e}}doReduce(){const s=[];s.push({id:"reduce-hcircuit-to-tsp-1",title:"Create complete graph",description:`
                <p> 
                    Take all of the nodes from the original graph and add an edge between each of them (make a complete graph).
                    For every edge that exists in the original instance, assign a weight of 1.
                    Otherwise assign some weight larger than 1.
                </p>
                <p>
                    There is ${this.nodeCount} nodes, 
                    which means there will be (${this.nodeCount} * ${this.nodeCount-1}) / 2 = ${this.nodeCount*(this.nodeCount-1)/2} edges, 
                    for it to be complete.
                </p>
                <p>
                    Now this problem can expressed by a decision question:
                    Is there a hamiltonian cycle such that the cost of the traversal is less than or equal to ${this.nodeCount}?
                </p>
            `,inSnapshot:this.inInstance.copy(),mapping:{}});const e=this.copyOver(this.inInstance.copy());s.push(...e.steps);const a=this.assignWeightsToExisting(e.graph.copy());s.push(...a.steps);const c=this.addMissingEdges(a.graph.copy());return s.push(...c.steps),{outInstance:c.graph,steps:s}}}var qe=b('<meta name="description" content="Reduction from HCIRCUIT to TSP"/>'),et=b("<div><!></div> <!> <div><!></div>",1),tt=b("<span>There are no steps to step through.</span>"),st=b('<div class="panes"><div><!> <!></div> <div><!> <!></div></div>'),nt=b('<main><h1>HCIRCUIT to TSP reduction</h1> <!> <div class="controls"><button>Reduce</button> <button><!></button> <input type="checkbox" name="showStepperCheckbox"/> <label for="showStepperCheckbox">Show steps</label></div> <!> <!></main>');function It(_,s){de(s,!1);const e=()=>P(d,"$redStore",g),a=()=>P(W,"$isSolving",g),c=()=>P(E,"$showStepper",g),o=()=>P(O,"$solveMessage",g),[g,I]=xe();let p=Ee(Ze.LS_HCIRCUIT_TSP,new ke),{redStore:d,showStepper:E,isSolving:W,solveMessage:O,editorChanged:X,reduce:w,solve:x}=Ue({storage:p,workerUrl:new URL("data:video/mp2t;base64,Ly8gQ3JlYXRlZCBieSBwaGF0dC0yMyBvbiAyMS8xMC8yMDI1CgppbXBvcnQgeyBVbnNvbHZhYmxlIH0gZnJvbSAiJGxpYi9jb3JlL1Vuc29sdmFibGUiOwppbXBvcnQgeyBHcmFwaCB9IGZyb20gIiRsaWIvaW5zdGFuY2UvR3JhcGgiOwppbXBvcnQgeyBTb2x2ZXJUU1AgfSBmcm9tICIkbGliL3NvbHZlL1NvbHZlclRTUCI7CgpzZWxmLm9ubWVzc2FnZSA9IGFzeW5jIChlKSA9PiB7CiAgICBjb25zdCBzZXJpYWxpemVkR3JhcGg6IHN0cmluZyA9IGUuZGF0YS5ncmFwaDsKICAgIGNvbnN0IG1heENvc3Q6IG51bWJlciA9IGUuZGF0YS5tYXhDb3N0OwogICAgY29uc29sZS5kZWJ1ZyhzZXJpYWxpemVkR3JhcGgpOwogICAgY29uc29sZS5kZWJ1ZyhtYXhDb3N0KTsKCiAgICBjb25zdCBpbnN0YW5jZTogR3JhcGggPSBHcmFwaC5mcm9tU2VyaWFsaXplZFN0cmluZyhzZXJpYWxpemVkR3JhcGgpOwoKICAgIGNvbnN0IHNvbHZlciA9IG5ldyBTb2x2ZXJUU1AoaW5zdGFuY2UsIG1heENvc3QpOwogICAgdHJ5IHsKICAgICAgICBjb25zdCByZXN1bHQgPSBzb2x2ZXIuc29sdmUoKTsKICAgICAgICBwb3N0TWVzc2FnZShyZXN1bHQgfHwgVW5zb2x2YWJsZSk7CiAgICB9IGZpbmFsbHkgewogICAgICAgIHBvc3RNZXNzYWdlKFVuc29sdmFibGUpOwogICAgfQp9Owo=",import.meta.url),createWorkerMessage:t=>({graph:t.toSerializedString(),maxCost:t.nodes.length}),reducerFactory:t=>new Qe(t),decoderFactory:()=>new ce,onSolveFinished:(t,n)=>{if(n==q){Te(d,ne(e).inCert=q,ne(e));return}const S=new ce().decode(t,n),N=e().inInstance;N.labelSolved({path:S.path,directed:!1}),t.labelSolved({path:n.path,directed:!1}),d.update(Z=>(Z.inInstance=N,Z.inCert=S,Z.outCert=n,Z.outInstance=t,Z))}});Ne();var U=nt();fe(t=>{var n=qe();_e.title="HCIRCUIT to TSP",i(t,n)});var F=l(C(U),2);He(F,{get graph(){return e().inInstance},onChange:t=>X(t),onWrongFormat:t=>alert("From graph editor: "+t)});var R=l(F,2),T=C(R);T.__click=w;var k=l(T,2);k.__click=x;var Y=C(k);{var ge=t=>{var n=M("Solving...");i(t,n)},ve=t=>{var n=M("Solve");i(t,n)};m(Y,t=>{a()?t(ge):t(ve,!1)})}h(k);var te=l(k,2);le(te),V(2),h(R);var se=l(R,2);{var ue=t=>{Be(t,{children:(n,y)=>{V();var S=M();z(()=>Q(S,o())),i(n,S)}})};m(se,t=>{a()&&t(ue)})}var Ie=l(se,2);{var me=t=>{const n=ae(()=>e().steps),y=ae(()=>e().stepIndex);var S=we(),N=K(S);{var Z=A=>{var B=et(),J=K(B),D=C(J);{var L=v=>{j(v,{get graph(){return u(n)[u(y)].inSnapshot},style:"UNDIRECTED",layout:"circle"})};m(D,v=>{u(y)<u(n).length&&u(n)[u(y)].inSnapshot&&!u(n)[u(y)].inSnapshot.isEmpty()&&v(L)})}h(J);var r=l(J,2);Fe(r,{get steps(){return e().steps},get stepIndex(){return e().stepIndex},onPrevClick:()=>{d.update(v=>(v.prevStep(),v)),p.save()},onNextClick:()=>{d.update(v=>(v.nextStep(),v)),p.save()}});var H=l(r,2),f=C(H);{var G=v=>{j(v,{get graph(){return e().steps[e().stepIndex].outSnapshot},style:"TSP",layout:"circle"})};m(f,v=>{e().stepIndex<e().steps.length&&e().steps[e().stepIndex].outSnapshot&&v(G)})}h(H),i(A,B)},$=A=>{var B=tt();i(A,B)};m(N,A=>{u(n).length?A(Z):A($,!1)})}i(t,S)},Ce=t=>{var n=st(),y=C(n),S=C(y);{var N=r=>{We(r,{get graph(){return e().inInstance},style:"UNDIRECTED",layout:"circle",onAddEdge:H=>{d.update(f=>{let G=f.inInstance;return G.addEdge(H),G.unlabelSolved(),f.reset(),f.setInInstance(G),f}),p.save()},onRemoveEdge:H=>{d.update(f=>{let G=f.inInstance;return G.removeEdgeById(H.id()),G.unlabelSolved(),f.reset(),f.setInInstance(G),f}),p.save()}})};m(S,r=>{e().inInstance&&!e().inInstance.isEmpty()&&r(N)})}var Z=l(S,2);{var $=r=>{Je(r,{get cert(){return e().inCert}})};m(Z,r=>{e().inCert&&r($)})}h(y);var A=l(y,2),B=C(A);{var J=r=>{j(r,{get graph(){return e().outInstance},style:"TSP",layout:"circle"})};m(B,r=>{e().outInstance&&!e().outInstance.isEmpty()&&r(J)})}var D=l(B,2);{var L=r=>{je(r,{get cert(){return e().outCert}})};m(D,r=>{e().outCert&&r(L)})}h(A),h(n),i(t,n)};m(Ie,t=>{c()?t(me):t(Ce,!1)})}h(U),z((t,n)=>{T.disabled=t,k.disabled=n},[()=>!e().hasInInstance()||e().hasOutInstance()||a(),()=>!e().hasInstances()||e().hasOutCertificate()||a()]),he(te,c,t=>Re(E,t)),i(_,U),pe(),I()}ye(["click"]);export{It as component,ut as universal};
