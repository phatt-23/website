import"../chunks/DsnmJJEf.js";import{s as V,d as me,o as fe}from"../chunks/BjnrFQNC.js";import{p as se,f as x,s as m,d as w,r as f,b as v,c as ie,a as Z,n as ee,g as o,h as M,i as k,t as z,D as _e,z as Ie,$ as Ce,K as J,L as Se,M as ae}from"../chunks/CoIEHD9u.js";import{i as b,s as be,a as we}from"../chunks/CFopsLng.js";import{r as ce,l as xe}from"../chunks/DEkd9q3U.js";import{U as W,b as de,e as re,i as oe,G as ye,N as Q,E as le,u as Te,R as Re,P as ke,S as Ee,f as Pe,g as G}from"../chunks/pXZND8Dt.js";import{E as De,D as Ue,C as Le}from"../chunks/DJxBrkU9.js";import{h as Ne}from"../chunks/BhYlo1k4.js";const He=!0,ot=Object.freeze(Object.defineProperty({__proto__:null,prerender:He},Symbol.toStringTag,{value:"Module"}));var $e=x("<p>The graph doesn't contain a Hamiltonian cycle.</p>"),Oe=x("<li> </li>"),Ae=x("<ol></ol>"),Fe=x("<span><!> </span>"),je=x("<div></div>"),Ge=x('<div class="controls"><input type="checkbox" name="showAsListCheckbox"/> <label for="showAsListCheckbox">Show as list</label></div> <!>',1),Me=x("<main><h2>CertRenderer TSP</h2> <!></main>");function We($,h){se(h,!0);let t=M(!0);var E=Me(),H=m(w(E),2);{var c=_=>{var l=$e();v(_,l)},g=_=>{var l=Ge(),C=Z(l),r=w(C);ce(r),ee(2),f(C);var X=m(C,2);{var q=S=>{var T=Ae();re(T,21,()=>h.cert.path,oe,(D,U)=>{var y=Oe(),L=w(y,!0);f(y),z(()=>V(L,o(U).id)),v(D,y)}),f(T),v(S,T)},K=S=>{var T=je();re(T,21,()=>h.cert.path,oe,(D,U,y)=>{var L=Fe(),j=w(L);Ne(j,()=>y!=0?"&ThinSpace;&LongRightArrow;&ThinSpace;":"");var Y=m(j);f(L),z(()=>V(Y,` ${o(U).id??""}`)),v(D,L)}),f(T),v(S,T)};b(X,S=>{o(t)?S(q):S(K,!1)})}de(r,()=>o(t),S=>k(t,S)),v(_,l)};b(H,_=>{h.cert==W?_(c):_(g,!1)})}f(E),v($,E),ie()}class ze{inInstance;nodeCount;constructor(h){this.inInstance=h,this.nodeCount=this.inInstance.nodes.length}reduce(){const h=new ye,t=[],E=new Set(this.inInstance.edges.map(c=>c.id)),H=this.inInstance.nodes.map(c=>(h.addNode(c),c.id.slice(Q.length)));console.debug("edgeIds:",E);for(let c=0;c<this.nodeCount;c++)for(let g=c+1;g<this.nodeCount;g++){const _=H[c],l=H[g],C=le+`${_}-${l}`,r=E.has(C);h.addEdge({id:C,from:Q+_,to:Q+l,weight:r?1:2,classes:r?"solid":"muted"})}return t.push({id:"reduce-hcircuit-to-tsp-1",title:"Create complete graph",description:`
                <p> 
                    Take all of the nodes from the original graph and add an edge between each of them (make a complete graph).
                    For every edge that exists in the original instance, assign a weight of 1.
                    Otherwise assign some weight larger than 1.
                </p>
                <p>
                    There is ${this.nodeCount} nodes, 
                    which means there will be (${this.nodeCount} * ${this.nodeCount-1}) / 2 = ${this.nodeCount*(this.nodeCount-1)/2} edges, 
                    for it to be complete.
                </p>
                <p>
                    Now this problem can expressed by a decision question:
                    Is there a hamiltonian cycle such that the cost of the traversal is less than or equal to ${this.nodeCount}?
                </p>
            `,inSnapshot:this.inInstance.copy(),outSnapshot:h.copy(),mapping:{}}),{outInstance:h,steps:t}}}var Xe=x('<meta name="description" content="Reduction from HCIRCUIT to TSP"/>'),qe=($,h)=>h(),Ke=x("<div><!></div> <!> <div><!></div>",1),Ye=x("<span>There are no steps to step through.</span>"),Be=x('<div class="panes"><div><!> <!></div> <div><!> <!></div></div>'),Je=x('<main><h1>HCIRCUIT to TSP reduction</h1> <!> <div class="controls"><button>Reduce</button> <button><!></button> <input type="checkbox" name="showStepperCheckbox"/> <label for="showStepperCheckbox">Show steps</label></div> <!> <!></main>');function st($,h){se(h,!0);const t=()=>be(g,"$redStore",E),[E,H]=we();let c=Te(xe.LS_HCIRCUIT_TSP,new Re),g=c.value;console.debug("input instance:",t().inInstance);let _=M(!1),l=M(!1),C=M(""),r=null;function X(e){r&&(r.terminate(),r=null,k(l,!1),k(C,"Solving cancelled â€” formula changed.")),g.update(n=>(n.reset(),n.setInInstance(e),c.save(),n))}function q(){if(t().inInstance){const e=new ze(t().inInstance),{outInstance:n,steps:d}=e.reduce();g.update(a=>(a.setSteps(d),a.setOutInstance(n),c.save(),a))}}async function K(){let{inCert:e,outInstance:n,outCert:d}=t();if(!(!n||d)){k(l,!0),k(C,"Solving TSP..."),r&&(r.terminate(),r=null);try{const a=new Worker(new URL(""+new URL("../workers/WorkerTSPSolver-301-_PYL.js",import.meta.url).href,import.meta.url),{type:"module"});r=a;const O=new Promise((u,R)=>{a.onmessage=p=>{a===r&&(a.terminate(),r=null,u(p.data))},a.onerror=p=>{a===r&&(a.terminate(),r=null,R(p))}});if(a.postMessage(n.toSerializedString()),d=await O,!r&&!o(l))return;if(d==W)g.update(u=>(u.inCert=W,u.outCert=W,u));else{const u=n,R=d.path;u.edges.forEach(s=>s.classes+=" solved");const p=s=>s.slice(s.search(ke)+1);for(let s=0;s<R.length-1;s++){const A=p(R[s].id),F=p(R[s+1].id),i=le+`${A}-${F}`,N=u.edges.find(B=>B.id==i);N&&(u.removeEdge(N),N.classes+=" used",u.addEdge(N))}e=new Ue().decode(u,d),g.update(s=>(s.inCert=e,s.outCert=d,s.outInstance=u,s))}c.save()}catch(a){console.error("Error during solving:",a),k(C,"An error occurred while solving.")}finally{k(l,!1),k(C,""),r=null}}}_e(()=>{g.update(e=>(e.resetStepIndex(),e))}),fe(()=>{r&&(r.terminate(),r=null)});var S=Je();Ie(e=>{var n=Xe();Ce.title="HCIRCUIT to TSP",v(e,n)});var T=m(w(S),2);De(T,{get graph(){return t().inInstance},onChange:e=>X(e),onWrongFormat:e=>alert("From graph editor: "+e)});var D=m(T,2),U=w(D);U.__click=q;var y=m(U,2);y.__click=[qe,K];var L=w(y);{var j=e=>{var n=J("Solving...");v(e,n)},Y=e=>{var n=J("Solve");v(e,n)};b(L,e=>{o(l)?e(j):e(Y,!1)})}f(y);var te=m(y,2);ce(te),ee(2),f(D);var ne=m(D,2);{var ue=e=>{Ee(e,{children:(n,d)=>{ee();var a=J();z(()=>V(a,o(C))),v(n,a)}})};b(ne,e=>{o(l)&&e(ue)})}var pe=m(ne,2);{var ve=e=>{const n=ae(()=>t().steps),d=ae(()=>t().stepIndex);var a=Se(),O=Z(a);{var u=p=>{var P=Ke(),s=Z(P),A=w(s);{var F=I=>{G(I,{get graph(){return o(n)[o(d)].inSnapshot},style:"UNDIRECTED",layout:"circle"})};b(A,I=>{o(d)<o(n).length&&o(n)[o(d)].inSnapshot&&!o(n)[o(d)].inSnapshot.empty()&&I(F)})}f(s);var i=m(s,2);Pe(i,{get steps(){return t().steps},get stepIndex(){return t().stepIndex},onPrevClick:()=>{g.update(I=>(I.prevStep(),I)),c.save()},onNextClick:()=>{g.update(I=>(I.nextStep(),I)),c.save()}});var N=m(i,2),B=w(N);{var ge=I=>{G(I,{get graph(){return t().steps[t().stepIndex].outSnapshot},style:"TSP",layout:"circle"})};b(B,I=>{t().stepIndex<t().steps.length&&t().steps[t().stepIndex].outSnapshot&&I(ge)})}f(N),v(p,P)},R=p=>{var P=Ye();v(p,P)};b(O,p=>{o(n).length?p(u):p(R,!1)})}v(e,a)},he=e=>{var n=Be(),d=w(n),a=w(d);{var O=i=>{G(i,{get graph(){return t().inInstance},style:"UNDIRECTED",layout:"circle"})};b(a,i=>{t().inInstance&&!t().inInstance.empty()&&i(O)})}var u=m(a,2);{var R=i=>{Le(i,{get cert(){return t().inCert}})};b(u,i=>{t().inCert&&i(R)})}f(d);var p=m(d,2),P=w(p);{var s=i=>{G(i,{get graph(){return t().outInstance},style:"TSP",layout:"circle"})};b(P,i=>{t().outInstance&&!t().outInstance.empty()&&i(s)})}var A=m(P,2);{var F=i=>{We(i,{get cert(){return t().outCert}})};b(A,i=>{t().outCert&&i(F)})}f(p),f(n),v(e,n)};b(pe,e=>{o(_)?e(ve):e(he,!1)})}f(S),z((e,n)=>{U.disabled=e,y.disabled=n},[()=>!t().hasInInstance()||t().hasOutInstance()||o(l),()=>!t().hasInstances()||t().hasOutCertificate()||o(l)]),de(te,()=>o(_),e=>k(_,e)),v($,S),ie(),H()}me(["click"]);export{st as component,ot as universal};
