import"../chunks/DsnmJJEf.js";import"../chunks/7c8ahxPy.js";import{p as ue,f as D,J as ve,d as y,s as I,t as B,b as S,c as Ie,$ as ge,u as J,r as b,K as Q,an as X,ao as _e,a as V,m as N,ac as Z}from"../chunks/BHy43uIv.js";import{d as me,s as Ce}from"../chunks/Bo-e_C1i.js";import{s as W,i as C,a as fe,b as Ee,c as Re}from"../chunks/lPMcd3W4.js";import{l as Se,r as Ne}from"../chunks/hAUU4et8.js";import{g as T,H as g,R as ye,E as Y,G as be,S as we,u as Oe,l as Pe,m as xe,b as $e,U as ee,n as De,W as Te,o as Fe,p as Ge}from"../chunks/4Tn6J3At.js";import{i as He}from"../chunks/Bic1S2_H.js";import{E as Ue,R as ke,C as Me}from"../chunks/CoHqDsmR.js";import{C as Le,a as Xe}from"../chunks/BjtV0G3U.js";import{R as j}from"../chunks/eBivCHW5.js";const We=!0,pt=Object.freeze(Object.defineProperty({__proto__:null,prerender:We},Symbol.toStringTag,{value:"Module"}));class te{decode(o,e){console.debug(e.path);const s=new Array;e.path.forEach(d=>{const h=this.getNodeName(d.id);s.push(h)});const n=new Array;let a;for(let d=0;d<s.length;d++)a!=s[d]&&(a=s[d],n.push({id:T+a}));return new Le(n)}nodePrefixes=[g.INCOMING_NODE_PREFIX,g.OUTGOING_NODE_PREFIX,g.GAP_NODE_PREFIX];getNodeName(o){for(let e=0;e<this.nodePrefixes.length;e++){const s=this.nodePrefixes[e];if(o.startsWith(s))return o.slice(s.length)}throw new Error(`Encountered node that doesn't start with any of the legal prefixes: ${o}`)}}class Ye extends ye{nodeDist=80;tripletDist=6*this.nodeDist;nodeCount;circum;radius;radStep;startRot;constructor(o){if(super(o),o.isEmpty())throw new Error("Reducer doesn't accept empty graphs (Graph with node nodes).");this.nodeCount=o.nodes.length,this.circum=this.tripletDist*this.nodeCount,this.radius=this.circum/(2*Math.PI),this.radStep=2*Math.PI/this.nodeCount,this.startRot=.5*Math.PI}doReduce(){const o=[],e=this.createNodeTriplets();o.push(...e.steps);const s=this.connectEdges(e.graph.copy());return o.push(...s.steps),{outInstance:s.graph,steps:o}}connectEdges(o){const e=[],s=a=>a.slice(T.length),n=new Array;return this.inInstance.edges.forEach(a=>{const d=s(a.from),h=s(a.to);n.push({from:d,to:h});const l=g.OUTGOING_NODE_PREFIX+d,p=g.INCOMING_NODE_PREFIX+h;o.addEdge({id:Y+`${l}-${p}`,from:l,to:p})}),e.push({id:"connect-edges",title:"Connect edges",description:`
                <p> 
                    For every original edge from node <i>a</i> to node <i>b</i>,
                    connect the node <i>a_out</i> with the node <i>b_in</i>.
                </p>
                <p>
                    In this particular case, add these edges:
                    <ul>
                        ${n.map(a=>`<li>(${a.from}_out, ${a.to}_in)</li>`).join("")}
                    </ul>
                </p>
            `,inSnapshot:this.inInstance.copy(),outSnapshot:o.copy(),mapping:{}}),{graph:o,steps:e}}createNodeTriplets(){const o=[],e=new be;return this.inInstance.nodes.forEach((s,n)=>{const a=s.id.slice(T.length),d={x:this.radius*Math.cos(n*this.radStep-this.startRot-.2*this.radStep),y:this.radius*Math.sin(n*this.radStep-this.startRot-.2*this.radStep)},h={x:this.radius*Math.cos(n*this.radStep-this.startRot),y:this.radius*Math.sin(n*this.radStep-this.startRot)},l={x:this.radius*Math.cos(n*this.radStep-this.startRot+.2*this.radStep),y:this.radius*Math.sin(n*this.radStep-this.startRot+.2*this.radStep)},p={in:{id:g.INCOMING_NODE_PREFIX+a,position:d,classes:s.classes},gap:{id:g.GAP_NODE_PREFIX+a,position:h,classes:s.classes},out:{id:g.OUTGOING_NODE_PREFIX+a,position:l,classes:s.classes}};Object.values(p).forEach(F=>e.addNode(F)),e.addEdge({id:Y+`${p.in.id}-${p.gap.id}`,from:p.in.id,to:p.gap.id}),e.addEdge({id:Y+`${p.gap.id}-${p.out.id}`,from:p.gap.id,to:p.out.id})}),o.push({id:"create-node-triplets",title:"Create node triplets",description:`
                <p> 
                    For each node in the original graph,
                    create three nodes that represent:
                    <ul>
                        <li>
                            an in-coming node
                        </li>
                        <li>
                            a gap node
                        </li>
                        <li>
                            and an out-going node
                        </li>
                    </ul>
                </p>
                <p>
                    Connect the in-coming node with the gap-node and the gap-node with the out-going node.
                </p>
                <p>
                    For this particular graph there will be ${this.nodeCount} node ${this.nodeCount==1?"triplet":"triplets"}.
                    ${this.nodeCount==1?"The triplet is:":"The triplets are:"}
                    <ul>  
                        ${this.inInstance.nodes.map(s=>{const n=s.id.slice(T.length);return`
                                <li>
                                    ${n} - (
                                        ${g.INCOMING_NODE_PREFIX+n}, 
                                        ${g.GAP_NODE_PREFIX+n}, 
                                        ${g.OUTGOING_NODE_PREFIX+n}
                                    )
                                </li>
                            `}).join("")}
                    </ul>
                </p>
            `,inSnapshot:this.inInstance.copy(),outSnapshot:e.copy(),mapping:{}}),{graph:e,steps:o}}}var je=Object.getOwnPropertyDescriptor,Ae=(_,o,e,s)=>{for(var n=s>1?void 0:s?je(o,e):o,a=_.length-1,d;a>=0;a--)(d=_[a])&&(n=d(n)||n);return n};let A=class{path;constructor(_){this.path=_}};A=Ae([we.SerializableClass()],A);function ze(_){return new Worker(""+new URL("../workers/WorkerHCIRCUITSolver-C8nmT2-i.js",import.meta.url).href,{name:_?.name})}var qe=D('<meta name="description" content="Reduction from HCYCLE to HCIRCUIT"/>'),Ke=D("<div><!></div> <!> <div><!></div>",1),Be=D("<span>There are no steps to step through.</span>"),Je=D('<div class="panes"><div><!> <!></div> <div><!> <!></div></div>'),Qe=D('<main><h1>HCYCLE to HCIRCUIT reduction</h1> <!> <div class="controls"><button>Reduce</button> <button><!></button> <input type="checkbox" name="showStepperCheckbox"/> <label for="showStepperCheckbox">Show steps</label></div> <!> <!></main>');function ct(_,o){ue(o,!1);const e=()=>W(l,"$redStore",a),s=()=>W(F,"$isSolving",a),n=()=>W(p,"$showStepper",a),[a,d]=fe();let h=Oe(Se.LS_HCYCLE_HCIRCUIT,new Pe),{redStore:l,showStepper:p,isSolving:F,solveMessage:se,editorChanged:re,reduce:ne,solve:oe}=xe({storage:h,workerFactory:()=>new ze,reducerFactory:t=>new Ye(t),decoderFactory:()=>new te,createWorkerRequest:t=>({graph:t.toSerializedString()}),resolveWorkerResponse:t=>{const r=t;return De(r.type==Te.RESULT),new A(r.path)},onSolveFinished:(t,r)=>{if(r==ee){Re(l,J(e).inCert=ee,J(e));return}const u=new te().decode(t,r),O=e().inInstance;O.labelSolved({path:u.path,directed:!0}),t.labelSolved({path:r.path,directed:!1}),l.update(f=>(f.inInstance=O,f.inCert=u,f.outCert=r,f.outInstance=t,f))}});He();var G=Qe();ve(t=>{var r=qe();ge.title="HCYCLE to HCIRCUIT",S(t,r)});var z=I(y(G),2);Ue(z,{get graph(){return e().inInstance},onChange:t=>re(t),onWrongFormat:t=>alert("From graph editor: "+t)});var H=I(z,2),U=y(H);U.__click=ne;var x=I(U,2);x.__click=oe;var ae=y(x);{var ie=t=>{var r=X("Solving...");S(t,r)},de=t=>{var r=X("Solve");S(t,r)};C(ae,t=>{s()?t(ie):t(de,!1)})}b(x);var q=I(x,2);Ne(q),Q(2),b(H);var K=I(H,2);{var pe=t=>{Fe(t,{children:(r,m)=>{Q();var u=X();B(()=>Ce(u,se)),S(r,u)}})};C(K,t=>{s()&&t(pe)})}var ce=I(K,2);{var he=t=>{const r=Z(()=>e().steps),m=Z(()=>e().stepIndex);var u=_e(),O=V(u);{var f=E=>{var w=Ke(),$=V(w),M=y($);{var L=c=>{j(c,{get graph(){return N(r)[N(m)].inSnapshot},style:"DIRECTED",layout:"circle"})};C(M,c=>{N(m)<N(r).length&&N(r)[N(m)].inSnapshot&&!N(r)[N(m)].inSnapshot.isEmpty()&&c(L)})}b($);var i=I($,2);Ge(i,{get steps(){return e().steps},get stepIndex(){return e().stepIndex},onPrevClick:()=>{l.update(c=>(c.prevStep(),c)),h.save()},onNextClick:()=>{l.update(c=>(c.nextStep(),c)),h.save()}});var P=I(i,2),v=y(P);{var R=c=>{j(c,{get graph(){return e().steps[e().stepIndex].outSnapshot},style:"HCIRCUIT",layout:"preset"})};C(v,c=>{e().stepIndex<e().steps.length&&e().steps[e().stepIndex].outSnapshot&&c(R)})}b(P),S(E,w)},k=E=>{var w=Be();S(E,w)};C(O,E=>{N(r).length?E(f):E(k,!1)})}S(t,u)},le=t=>{var r=Je(),m=y(r),u=y(m);{var O=i=>{ke(i,{get graph(){return e().inInstance},style:"DIRECTED",layout:"circle",directed:!0,onAddEdge:P=>{l.update(v=>{let R=v.inInstance;return R.addEdge(P),R.unlabelSolved(),v.reset(),v.setInInstance(R),v}),h.save()},onRemoveEdge:P=>{l.update(v=>{let R=v.inInstance;return R.removeEdgeById(P.id()),R.unlabelSolved(),v.reset(),v.setInInstance(R),v}),h.save()}})};C(u,i=>{e().inInstance&&!e().inInstance.isEmpty()&&i(O)})}var f=I(u,2);{var k=i=>{Xe(i,{get cert(){return e().inCert}})};C(f,i=>{e().inCert&&i(k)})}b(m);var E=I(m,2),w=y(E);{var $=i=>{j(i,{get graph(){return e().outInstance},style:"HCIRCUIT",layout:"preset"})};C(w,i=>{e().outInstance&&!e().outInstance.isEmpty()&&i($)})}var M=I(w,2);{var L=i=>{Me(i,{get cert(){return e().outCert}})};C(M,i=>{e().outCert&&i(L)})}b(E),b(r),S(t,r)};C(ce,t=>{n()?t(he):t(le,!1)})}b(G),B((t,r)=>{U.disabled=t,x.disabled=r},[()=>!e().hasInInstance()||e().hasOutInstance()||s(),()=>!e().hasInstances()||e().hasOutCertificate()||s()]),$e(q,n,t=>Ee(p,t)),S(_,G),Ie(),d()}me(["click"]);export{ct as component,pt as universal};
