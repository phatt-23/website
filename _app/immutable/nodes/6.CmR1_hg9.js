import"../chunks/DsnmJJEf.js";import{f as g,d as O,r as D,t as Z,b as p,p as ee,g as te,Q as re,K as se,c as ne,O as ae,$ as oe,h as j,s as E,a as k,a9 as y,S as ie,k as ce}from"../chunks/CTrBG-su.js";import{a as q,i as G,s as de,c as le}from"../chunks/0-nxEys-.js";import{S as pe,R as he,E as L,u as ue,m as ge,n as ve,o as fe,U as z,p as me,W as Ie,q as Se,O as Ce,I as _e}from"../chunks/QFfqNP4o.js";import{a as we,C as ye}from"../chunks/CCciNkN7.js";import{s as Re}from"../chunks/xh0yEfGp.js";import{E as Te,R as Ee}from"../chunks/D9ukKQF0.js";import{R as x}from"../chunks/BLjARmoN.js";import{l as Pe}from"../chunks/Dw-FwYao.js";const $e=!0,Ze=Object.freeze(Object.defineProperty({__proto__:null,prerender:$e},Symbol.toStringTag,{value:"Module"}));var be=g("<p> </p>");function Ue(c,e){we(c,{get cert(){return e.cert},unsolvablePlaceholder:o=>{var a=be(),n=O(a);D(a),Z(()=>Re(n,`The graph doesn't contain a Hamiltonian cycle with the given cost of ${e.cost??""}.`)),p(o,a)},$$slots:{unsolvablePlaceholder:!0}})}var ke=Object.getOwnPropertyDescriptor,xe=(c,e,t,o)=>{for(var a=o>1?void 0:o?ke(e,t):e,n=c.length-1,v;n>=0;n--)(v=c[n])&&(a=v(a)||a);return a};let P=class{constructor(c){this.path=c}};P=xe([pe.SerializableClass()],P);class N{decode(e,t){return new P(t.path)}}class Oe extends he{nodeCount;constructor(e){super(e),this.nodeCount=this.inInstance.nodes.length}copyOver(e){const t=[];return t.push({id:"copy-over",title:"Copy over the original graph",description:"",mapping:{},inSnapshot:this.inInstance.copy(),outSnapshot:e}),{graph:e,steps:t}}assignWeightsToExisting(e){const t=[];return e.edges.forEach(o=>{o.weight=1,o.classes+=" solid"}),t.push({id:"assign-weight-1",title:"Assign weights to existing edges",description:`
                <p>
                    For each edge that was in the original graph now assign the weight 1.
                </p>
            `,mapping:{},inSnapshot:this.inInstance.copy(),outSnapshot:e}),{graph:e,steps:t}}addMissingEdges(e){const t=[],o=new Set(this.inInstance.edges.map(n=>n.id)),a=this.inInstance.nodes.map(n=>(e.addNode(n),n.id));for(let n=0;n<e.nodes.length;n++)for(let v=n+1;v<e.nodes.length;v++){const C=a[n],i=a[v],R=L+`${C}-${i}`,$=L+`${i}-${C}`;o.has(R)||o.has($)||e.addEdge({id:R,from:C,to:i,weight:2,classes:"muted"})}return t.push({id:"add-missing-edges",title:"Add missing edges",description:`
                <p>
                    Connect all the nodes that weren't connect before by a new edge and assign a weight of 2 to this new edge.
                </p>
            `,mapping:{},inSnapshot:this.inInstance.copy(),outSnapshot:e}),{graph:e,steps:t}}doReduce(){const e=[];e.push({id:"reduce-hcircuit-to-tsp-1",title:"Create complete graph",description:`
                <p> 
                    Take all of the nodes from the original graph and add an edge between each of them (make a complete graph).
                    For every edge that exists in the original instance, assign a weight of 1.
                    Otherwise assign some weight larger than 1.
                </p>
                <p>
                    There is ${this.nodeCount} nodes, 
                    which means there will be (${this.nodeCount} * ${this.nodeCount-1}) / 2 = ${this.nodeCount*(this.nodeCount-1)/2} edges, 
                    for it to be complete.
                </p>
                <p>
                    Now this problem can expressed by a decision question:
                    Is there a hamiltonian cycle such that the cost of the traversal is less than or equal to ${this.nodeCount}?
                </p>
            `,inSnapshot:this.inInstance.copy(),mapping:{}});const t=this.copyOver(this.inInstance.copy());e.push(...t.steps);const o=this.assignWeightsToExisting(t.graph.copy());e.push(...o.steps);const a=this.addMissingEdges(o.graph.copy());return e.push(...a.steps),{outInstance:a.graph,steps:e}}}function De(c){return new Worker(""+new URL("../workers/WorkerTSPSolver-DR6CT8vu.js",import.meta.url).href,{name:c?.name})}var He=g('<meta name="description" content="Reduction from HCIRCUIT to TSP"/>'),We=g("<h2>Input HCIRCUIT Instance</h2>"),Fe=g("<span>Certificate for HCYCLE will appear here.</span>"),Me=g("<h2>Graph Editor</h2>"),je=g("<!> <!>",1),qe=g("<h2>Output TSP Instance</h2>"),Ge=g('<span class="placeholder">Certificate for TSP will appear here.</span>'),Le=g("<!> <!>",1),ze=g('<main class="svelte-47q0oi"><h1>HCIRCUIT to TSP reduction</h1> <div class="card-list svelte-47q0oi"><!> <!></div></main>');function et(c,e){ee(e,!0);const t=()=>q(i,"$redStore",a),o=()=>q(R,"$showStepper",a),[a,n]=de(),v=(r,s=y)=>{_e(r,{get redStore(){return i},get hideCertificate(){return s()},title:h=>{var m=We();p(h,m)},instance:(h,m=y)=>{var u=ie(),I=k(u);{var J=w=>{x(w,{get graph(){return m()},style:"UNDIRECTED",layout:"circle"})},V=w=>{Ee(w,{get graph(){return m()},style:"UNDIRECTED",layout:"circle",onAddEdge:U=>{i.update(S=>{let _=S.inInstance;return _.addEdge(U),_.unlabelSolved(),S.reset(),S.setInInstance(_),S}),C.save()},onRemoveEdge:U=>{i.update(S=>{let _=S.inInstance;return _.removeEdgeById(U.id()),_.unlabelSolved(),S.reset(),S.setInInstance(_),S}),C.save()}})};G(I,w=>{s()?w(J):w(V,!1)})}p(h,u)},certificate:(h,m=y)=>{ye(h,{get cert(){return m()}})},certificatePlaceholder:h=>{var m=Fe();p(h,m)},$$slots:{title:!0,instance:!0,certificate:!0,certificatePlaceholder:!0}})};let C=ue(Pe.LS_HCIRCUIT_TSP,new ge),{redStore:i,showStepper:R,isSolving:$,solveMessage:H,editorChanged:A,reduce:K,solve:Y}=ve({storage:C,workerFactory:()=>new De,reducerFactory:r=>new Oe(r),decoderFactory:()=>new N,createWorkerRequest:r=>({graph:r.toSerializedString(),maxCost:r.nodes.length}),resolveWorkerResponse:r=>{const s=r;return me(s.type==Ie.RESULT),new P(s.path)},onSolveFinished:(r,s)=>{if(s==z){le(i,j(t).inCert=z,j(t));return}const l=new N().decode(r,s),T=t().inInstance;T.labelSolved({path:l.path,directed:!1}),r.labelSolved({path:s.path,directed:!1}),i.update(f=>(f.inInstance=T,f.inCert=l,f.outCert=s,f.outInstance=r,f))}}),W=ae(0);te(()=>{t().inInstance&&re(W,t().inInstance.nodes.length,!0)});var b=ze();se(r=>{var s=He();oe.title="HCIRCUIT to TSP",p(r,s)});var F=E(O(b),2),M=O(F);fe(M,{get redStore(){return i},get isSolving(){return $},get solveMessage(){return H},get showStepper(){return R},get reduce(){return K},get solve(){return Y},title:d=>{var l=Me();p(d,l)},editor:d=>{Te(d,{get graph(){return t().inInstance},onChange:l=>A(l),displayErrorMessages:!0})},$$slots:{title:!0,editor:!0}});var B=E(M,2);{var Q=r=>{var s=je(),d=k(s);v(d,()=>!0);var l=E(d,2);Se(l,{get redStore(){return i},get storage(){return C},instance:(f,h=y)=>{x(f,{get graph(){return h()},style:"TSP",layout:"circle"})},$$slots:{instance:!0}}),p(r,s)},X=r=>{var s=Le(),d=k(s);v(d,()=>!1);var l=E(d,2);Ce(l,{get redStore(){return i},title:u=>{var I=qe();p(u,I)},instance:(u,I=y)=>{x(u,{get graph(){return I()},style:"TSP",layout:"circle"})},certificate:(u,I=y)=>{Ue(u,{get cert(){return I()},get cost(){return ce(W)}})},certificatePlaceholder:u=>{var I=Ge();p(u,I)},$$slots:{title:!0,instance:!0,certificate:!0,certificatePlaceholder:!0}}),p(r,s)};G(B,r=>{o()?r(Q):r(X,!1)})}D(F),D(b),p(c,b),ne(),n()}export{et as component,Ze as universal};
