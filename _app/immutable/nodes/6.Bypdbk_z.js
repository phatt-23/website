import"../chunks/DsnmJJEf.js";import"../chunks/DVXSbgSC.js";import{p as de,f as b,s as l,d as C,r as g,b as i,c as pe,a as D,K as M,m as u,L as be,M as Se,t as N,J as fe,$ as _e,u as ne,am as $,an as ye,ac as ae}from"../chunks/0h0eovDe.js";import{s as Q,d as we}from"../chunks/BeBJMhcX.js";import{i as m,s as H,a as xe,b as Re,c as Te}from"../chunks/E6MyXn9j.js";import{r as le,l as Ae}from"../chunks/CSnGU0Cu.js";import{U as q,b as ge,e as oe,i as re,S as Be,R as Ee,E as ie,u as Ue,a as Ze,c as Fe,d as Ge,f as ze}from"../chunks/DCk9rHG9.js";import{i as Pe}from"../chunks/DaAev7kg.js";import{E as ke,R as Ke,C as Xe}from"../chunks/Bs7IJ1ml.js";import{h as He}from"../chunks/Bp5AzgID.js";import{R as j}from"../chunks/YqW4Rh_A.js";const Ne=!0,ut=Object.freeze(Object.defineProperty({__proto__:null,prerender:Ne},Symbol.toStringTag,{value:"Module"}));var We=b("<p>The graph doesn't contain a Hamiltonian cycle with the given cost.</p>"),Le=b("<li> </li>"),Oe=b("<ol></ol>"),Ve=b("<span><!> </span>"),Ye=b("<div></div>"),Je=b('<div class="controls"><input type="checkbox" name="showAsListCheckbox"/> <label for="showAsListCheckbox">Show as list</label></div> <!>',1),$e=b("<main><h2>CertRenderer TSP</h2> <!></main>");function je(_,s){de(s,!0);let e=be(!0);var a=$e(),c=l(C(a),2);{var o=I=>{var p=We();i(I,p)},h=I=>{var p=Je(),d=D(p),U=C(d);le(U),M(2),g(d);var K=l(d,2);{var W=y=>{var x=Oe();oe(x,21,()=>s.cert.path,re,(F,z)=>{var R=Le(),T=C(R,!0);g(R),N(()=>Q(T,u(z).id)),i(F,R)}),g(x),i(y,x)},L=y=>{var x=Ye();oe(x,21,()=>s.cert.path,re,(F,z,R)=>{var T=Ve(),Z=C(T);He(Z,()=>R!=0?"&ThinSpace;&LongRightArrow;&ThinSpace;":"");var O=l(Z);g(T),N(()=>Q(O,` ${u(z).id??""}`)),i(F,T)}),g(x),i(y,x)};m(K,y=>{u(e)?y(W):y(L,!1)})}ge(U,()=>u(e),y=>Se(e,y)),i(I,p)};m(c,I=>{s.cert==q?I(o):I(h,!1)})}g(a),i(_,a),pe()}var De=Object.getOwnPropertyDescriptor,Me=(_,s,e,a)=>{for(var c=a>1?void 0:a?De(s,e):s,o=_.length-1,h;o>=0;o--)(h=_[o])&&(c=h(c)||c);return c};let ee=class{path;constructor(_){this.path=_}};ee=Me([Be.SerializableClass()],ee);class ce{decode(s,e){return new ee(e.path)}}class Qe extends Ee{nodeCount;constructor(s){super(s),this.nodeCount=this.inInstance.nodes.length}copyOver(s){const e=[];return e.push({id:"copy-over",title:"Copy over the original graph",description:"",mapping:{},inSnapshot:this.inInstance.copy(),outSnapshot:s}),{graph:s,steps:e}}assignWeightsToExisting(s){const e=[];return s.edges.forEach(a=>{a.weight=1,a.classes+=" solid"}),e.push({id:"assign-weight-1",title:"Assign weights to existing edges",description:`
                <p>
                    For each edge that was in the original graph now assign the weight 1.
                </p>
            `,mapping:{},inSnapshot:this.inInstance.copy(),outSnapshot:s}),{graph:s,steps:e}}addMissingEdges(s){const e=[],a=new Set(this.inInstance.edges.map(o=>o.id));console.debug("idgeIds.values()",[...a.values()]);const c=this.inInstance.nodes.map(o=>(s.addNode(o),o.id));for(let o=0;o<s.nodes.length;o++)for(let h=o+1;h<s.nodes.length;h++){const I=c[o],p=c[h],d=ie+`${I}-${p}`,U=ie+`${p}-${I}`,K=a.has(d)||a.has(U);console.debug("check existence of",d,U),K||s.addEdge({id:d,from:I,to:p,weight:2,classes:"muted"})}return e.push({id:"add-missing-edges",title:"Add missing edges",description:`
                <p>
                    Connect all the nodes that weren't connect before by a new edge and assign a weight of 2 to this new edge.
                </p>
            `,mapping:{},inSnapshot:this.inInstance.copy(),outSnapshot:s}),{graph:s,steps:e}}doReduce(){const s=[];s.push({id:"reduce-hcircuit-to-tsp-1",title:"Create complete graph",description:`
                <p> 
                    Take all of the nodes from the original graph and add an edge between each of them (make a complete graph).
                    For every edge that exists in the original instance, assign a weight of 1.
                    Otherwise assign some weight larger than 1.
                </p>
                <p>
                    There is ${this.nodeCount} nodes, 
                    which means there will be (${this.nodeCount} * ${this.nodeCount-1}) / 2 = ${this.nodeCount*(this.nodeCount-1)/2} edges, 
                    for it to be complete.
                </p>
                <p>
                    Now this problem can expressed by a decision question:
                    Is there a hamiltonian cycle such that the cost of the traversal is less than or equal to ${this.nodeCount}?
                </p>
            `,inSnapshot:this.inInstance.copy(),mapping:{}});const e=this.copyOver(this.inInstance.copy());s.push(...e.steps);const a=this.assignWeightsToExisting(e.graph.copy());s.push(...a.steps);const c=this.addMissingEdges(a.graph.copy());return s.push(...c.steps),{outInstance:c.graph,steps:s}}}var qe=b('<meta name="description" content="Reduction from HCIRCUIT to TSP"/>'),et=b("<div><!></div> <!> <div><!></div>",1),tt=b("<span>There are no steps to step through.</span>"),st=b('<div class="panes"><div><!> <!></div> <div><!> <!></div></div>'),nt=b('<main><h1>HCIRCUIT to TSP reduction</h1> <!> <div class="controls"><button>Reduce</button> <button><!></button> <input type="checkbox" name="showStepperCheckbox"/> <label for="showStepperCheckbox">Show steps</label></div> <!> <!></main>');function It(_,s){de(s,!1);const e=()=>H(d,"$redStore",h),a=()=>H(K,"$isSolving",h),c=()=>H(U,"$showStepper",h),o=()=>H(W,"$solveMessage",h),[h,I]=xe();let p=Ue(Ae.LS_HCIRCUIT_TSP,new Ze),{redStore:d,showStepper:U,isSolving:K,solveMessage:W,editorChanged:L,reduce:y,solve:x}=Fe({storage:p,workerUrl:new URL("data:video/mp2t;base64,Ly8gQ3JlYXRlZCBieSBwaGF0dC0yMyBvbiAyMS8xMC8yMDI1CgppbXBvcnQgeyBVbnNvbHZhYmxlIH0gZnJvbSAiJGxpYi9jb3JlL1Vuc29sdmFibGUiOwppbXBvcnQgeyBHcmFwaCB9IGZyb20gIiRsaWIvaW5zdGFuY2UvR3JhcGgiOwppbXBvcnQgeyBTb2x2ZXJUU1AgfSBmcm9tICIkbGliL3NvbHZlL1NvbHZlclRTUCI7CgpzZWxmLm9ubWVzc2FnZSA9IGFzeW5jIChlKSA9PiB7CiAgICBjb25zb2xlLmRlYnVnKCdXb3JrZXJUU1BTb2x2ZXI6Om9ubWVzc2FnZScpOwoKICAgIHRyeSB7CiAgICAgICAgY29uc3Qgc2VyaWFsaXplZEdyYXBoOiBzdHJpbmcgPSBlLmRhdGEuZ3JhcGg7CiAgICAgICAgY29uc3QgbWF4Q29zdDogbnVtYmVyID0gZS5kYXRhLm1heENvc3Q7CgogICAgICAgIGNvbnNvbGUuZGVidWcoc2VyaWFsaXplZEdyYXBoKTsKICAgICAgICBjb25zb2xlLmRlYnVnKG1heENvc3QpOwoKICAgICAgICBjb25zdCBpbnN0YW5jZTogR3JhcGggPSBHcmFwaC5mcm9tU2VyaWFsaXplZFN0cmluZyhzZXJpYWxpemVkR3JhcGgpOwoKICAgICAgICBjb25zdCBzb2x2ZXIgPSBuZXcgU29sdmVyVFNQKGluc3RhbmNlLCBtYXhDb3N0KTsKICAgICAgICBjb25zdCByZXN1bHQgPSBzb2x2ZXIuc29sdmUoKTsKCiAgICAgICAgcG9zdE1lc3NhZ2UocmVzdWx0IHx8IFVuc29sdmFibGUpOwogICAgfQogICAgY2F0Y2ggKGUpIHsKICAgICAgICBwb3N0TWVzc2FnZShlKTsKICAgIH0KfTsK",import.meta.url),createWorkerMessage:t=>({graph:t.toSerializedString(),maxCost:t.nodes.length}),reducerFactory:t=>new Qe(t),decoderFactory:()=>new ce,onSolveFinished:(t,n)=>{if(n==q){Te(d,ne(e).inCert=q,ne(e));return}const S=new ce().decode(t,n),P=e().inInstance;P.labelSolved({path:S.path,directed:!1}),t.labelSolved({path:n.path,directed:!1}),d.update(A=>(A.inInstance=P,A.inCert=S,A.outCert=n,A.outInstance=t,A))}});Pe();var F=nt();fe(t=>{var n=qe();_e.title="HCIRCUIT to TSP",i(t,n)});var z=l(C(F),2);ke(z,{get graph(){return e().inInstance},onChange:t=>L(t),onWrongFormat:t=>alert("From graph editor: "+t)});var R=l(z,2),T=C(R);T.__click=y;var Z=l(T,2);Z.__click=x;var O=C(Z);{var he=t=>{var n=$("Solving...");i(t,n)},ve=t=>{var n=$("Solve");i(t,n)};m(O,t=>{a()?t(he):t(ve,!1)})}g(Z);var te=l(Z,2);le(te),M(2),g(R);var se=l(R,2);{var ue=t=>{Ge(t,{children:(n,w)=>{M();var S=$();N(()=>Q(S,o())),i(n,S)}})};m(se,t=>{a()&&t(ue)})}var Ie=l(se,2);{var me=t=>{const n=ae(()=>e().steps),w=ae(()=>e().stepIndex);var S=ye(),P=D(S);{var A=B=>{var G=et(),X=D(G),Y=C(X);{var J=v=>{j(v,{get graph(){return u(n)[u(w)].inSnapshot},style:"UNDIRECTED",layout:"circle"})};m(Y,v=>{u(w)<u(n).length&&u(n)[u(w)].inSnapshot&&!u(n)[u(w)].inSnapshot.isEmpty()&&v(J)})}g(X);var r=l(X,2);ze(r,{get steps(){return e().steps},get stepIndex(){return e().stepIndex},onPrevClick:()=>{d.update(v=>(v.prevStep(),v)),p.save()},onNextClick:()=>{d.update(v=>(v.nextStep(),v)),p.save()}});var k=l(r,2),f=C(k);{var E=v=>{j(v,{get graph(){return e().steps[e().stepIndex].outSnapshot},style:"TSP",layout:"circle"})};m(f,v=>{e().stepIndex<e().steps.length&&e().steps[e().stepIndex].outSnapshot&&v(E)})}g(k),i(B,G)},V=B=>{var G=tt();i(B,G)};m(P,B=>{u(n).length?B(A):B(V,!1)})}i(t,S)},Ce=t=>{var n=st(),w=C(n),S=C(w);{var P=r=>{Ke(r,{get graph(){return e().inInstance},style:"UNDIRECTED",layout:"circle",onAddEdge:k=>{d.update(f=>{let E=f.inInstance;return E.addEdge(k),E.unlabelSolved(),f.reset(),f.setInInstance(E),f}),p.save()},onRemoveEdge:k=>{d.update(f=>{let E=f.inInstance;return E.removeEdgeById(k.id()),E.unlabelSolved(),f.reset(),f.setInInstance(E),f}),p.save()}})};m(S,r=>{e().inInstance&&!e().inInstance.isEmpty()&&r(P)})}var A=l(S,2);{var V=r=>{Xe(r,{get cert(){return e().inCert}})};m(A,r=>{e().inCert&&r(V)})}g(w);var B=l(w,2),G=C(B);{var X=r=>{j(r,{get graph(){return e().outInstance},style:"TSP",layout:"circle"})};m(G,r=>{e().outInstance&&!e().outInstance.isEmpty()&&r(X)})}var Y=l(G,2);{var J=r=>{je(r,{get cert(){return e().outCert}})};m(Y,r=>{e().outCert&&r(J)})}g(B),g(n),i(t,n)};m(Ie,t=>{c()?t(me):t(Ce,!1)})}g(F),N((t,n)=>{T.disabled=t,Z.disabled=n},[()=>!e().hasInInstance()||e().hasOutInstance()||a(),()=>!e().hasInstances()||e().hasOutCertificate()||a()]),ge(te,c,t=>Re(U,t)),i(_,F),pe(),I()}we(["click"]);export{It as component,ut as universal};
