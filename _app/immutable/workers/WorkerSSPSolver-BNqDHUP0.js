(function(){"use strict";const m="unsolvable";class a{static SerializableClass(e){return function(t){const s=e??t.name;t.prototype.__type=s,a.registerClass(s,t)}}static serialize(e){if(e==null)return e;if(Array.isArray(e))return e.map(a.serialize);if(e instanceof Set)return{__type:"Set",values:Array.from(e).map(a.serialize)};if(e instanceof Map)return{__type:"Map",entries:Array.from(e.entries()).map(([t,s])=>[a.serialize(t),a.serialize(s)])};if(typeof e=="object"){if(Array.isArray(e))return e.map(a.serialize);const t=e.constructor,r={__type:e.__type??t.name};for(const[c,o]of Object.entries(e))r[c]=a.serialize(o);return r}return e}static revive(e){if(e==null)return e;if(Array.isArray(e))return e.map(a.revive);if(e.__type==="Set")return new Set(e.values.map(a.revive));if(e.__type==="Map")return new Map(e.entries.map(([t,s])=>[a.revive(t),a.revive(s)]));if(e.__type){const t=a.getClass(e.__type);if(!t)throw new Error(`Serializer - Unknown class: ${e.__type}`);const s=Object.create(t.prototype);for(const[r,c]of Object.entries(e))r!=="__type"&&(s[r]=a.revive(c));return s}return e}static registerClass(e,t){a.classRegistry.set(e,t)}static getClass(e){return a.classRegistry.get(e)}static classRegistry=new Map}a.registerClass(Object.name,Object);class y{}var d=Object.getOwnPropertyDescriptor,f=(n,e,t,s)=>{for(var r=s>1?void 0:s?d(e,t):e,c=n.length-1,o;c>=0;c--)(o=n[c])&&(r=o(r)||r);return r};let l=class{id;value;used;classes;constructor(n,e,t=!1,s){this.id=n,this.value=e,this.used=t,this.classes=s}asString(){return this.value.join("")}};l=f([a.SerializableClass("SSPNumber")],l);let u=class extends y{numbers;target;constructor(){super(),this.numbers=[],this.target=[0]}addNumber(n){this.numbers.push(n)}setTarget(n){this.target=n}empty(){return this.numbers.length==0}static fromString(n,e){const t=new u;if(!n)return"SSP cannot be constructed from an empty string";const s=n.split(`
`).map(r=>r.trim()).filter(r=>r.length);try{const r=Array(e).map(c=>Number.parseInt(c));t.setTarget(r)}catch(r){return console.error(r),`Couldn't parse the target number: ${e}`}return s.forEach((r,c)=>{try{const o=Array.from(r).map(p=>Number.parseInt(p));t.addNumber(new l(`${c}`,o))}catch(o){return console.error(o),`Couldn't parse the number on the line ${c}: ${r}.`}}),t}toSerializedString(){const n={numbers:this.numbers.map(e=>({id:e.id,value:e.value,used:e.used,classes:e.classes??null})),target:this.target};return JSON.stringify(n)}static fromSerializedString(n){const e=new u,t=JSON.parse(n);if(e.setTarget(t.target),Array.isArray(t.numbers))for(const s of t.numbers)e.addNumber(new l(s.id,s.value,s.used,s.classes));return e}copy(){const n=new u;return n.setTarget([...this.target]),this.numbers.forEach(e=>{const t=new l(e.id,[...e.value],e.used,e.classes);n.addNumber(t)}),n}};u=f([a.SerializableClass("SSP")],u);class v{numbers;constructor(e){this.numbers=e}}class h{instance;constructor(e){this.instance=e}solve(){console.debug("SolverSSP::solve()");const e=this.instance.numbers,t=parseInt(this.instance.target.join("")),s=e.map(i=>parseInt(i.value.join(""))),r=new Map;r.set(0,-1);for(let i=0;i<s.length;i++){const S=s[i],w=Array.from(r.keys());for(const b of w){const g=b+S;r.has(g)||r.set(g,i)}}if(!r.has(t))return m;const c=[];let o=t;const p=new Set;for(;o>0;){const i=r.get(o);if(i===void 0||i===-1)break;c.push(e[i]),p.add(i),o-=s[i]}for(let i=0;i<e.length;i++)e[i].used=p.has(i);return new v(c)}}self.onmessage=async n=>{console.debug("WorkerSSPSolver::onmessage"),console.debug("Calling SSP.fromSerializedString method");const e=u.fromSerializedString(n.data);if(typeof e=="string"){postMessage(new Error("SSP couldn't be parsed from string."));return}console.debug("Creating new solver");const t=new h(e);try{console.debug("solving...");const s=t.solve();postMessage(s||m)}finally{postMessage(m)}}})();
