(function(){"use strict";const v="unsolvable";class E{}class l{static SerializableClass(e){return function(t){const s=e??t.name;t.prototype.__type=s,l.registerClass(s,t)}}static serialize(e){if(e==null)return e;if(Array.isArray(e))return e.map(l.serialize);if(e instanceof Set)return{__type:"Set",values:Array.from(e).map(l.serialize)};if(e instanceof Map)return{__type:"Map",entries:Array.from(e.entries()).map(([t,s])=>[l.serialize(t),l.serialize(s)])};if(typeof e=="object"){if(Array.isArray(e))return e.map(l.serialize);const t=e.constructor,i={__type:e.__type??t.name};for(const[r,o]of Object.entries(e))i[r]=l.serialize(o);return i}return e}static revive(e){if(e==null)return e;if(Array.isArray(e))return e.map(l.revive);if(e.__type==="Set")return new Set(e.values.map(l.revive));if(e.__type==="Map")return new Map(e.entries.map(([t,s])=>[l.revive(t),l.revive(s)]));if(e.__type){const t=l.getClass(e.__type);if(!t)throw new Error(`Serializer - Unknown class: ${e.__type}`);const s=Object.create(t.prototype);for(const[i,r]of Object.entries(e))i!=="__type"&&(s[i]=l.revive(r));return s}return e}static registerClass(e,t){l.classRegistry.set(e,t)}static getClass(e){return l.classRegistry.get(e)}static classRegistry=new Map}l.registerClass(Object.name,Object);const g="n:",I="e:";function P(n,e,t){return t.indexOf(n)===e}var S=Object.getOwnPropertyDescriptor,M=(n,e,t,s)=>{for(var i=s>1?void 0:s?S(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(i=o(i)||i);return i};let h=class extends E{_nodes;_edges;constructor(){super(),this._nodes=new Set,this._edges=new Set}addNode(n){n.classes==null&&(n.classes=""),!this.nodes.find(e=>e.id==n.id)&&this._nodes.add(n)}addEdge(n){n.classes==null&&(n.classes=""),!this.edges.find(e=>e.id==n.id)&&this._edges.add(n)}get nodes(){return Array.from(this._nodes.values())}get edges(){return Array.from(this._edges.values())}removeNode(n){if(!this._nodes.has(n))return;this._nodes.delete(n),Array.from(this.edges).filter(t=>t.to===n.id||t.from===n.id).forEach(t=>this._edges.delete(t))}removeEdge(n){this._edges.delete(n)}empty(){return this.nodes.length==0}copy(){const n=new h;for(const e of this._nodes)n.addNode({id:e.id,label:e.label,position:e.position?{...e.position}:void 0,classes:e.classes});for(const e of this._edges)n.addEdge({id:e.id,from:e.from,to:e.to,weight:e.weight,classes:e.classes});return n}asString(){const n=this.nodes.map(t=>t.id.slice(g.length)).join(`
`),e=this.edges.map(t=>t.from.slice(g.length)+" "+t.to.slice(g.length)+(t.weight!=null?" "+t.weight:"")).join(`
`);return n+`
`+e+`
`}static fromString(n){if(n.length==0)return"Cannot construct a graph from empty string";const e=n.split(`
`).map(s=>s.trim()).filter(s=>s.length).filter(P);let t=new h;console.debug("LINES",e);for(let s=0;s<e.length;s++){const r=e[s].split(" ").map(o=>o.trim()).filter(o=>o.length);if(r.length==1){const o=r;t.addNode({id:g+o})}else if(r.length<=3){const o=r[0],f=r[1];let u;if(r.length==3)try{u=Number.parseFloat(r[2])}catch{return`On the line ${s}, couldn't parse the weight: '${r[2]}Please enter a number (floating allowed)`}t.addNode({id:g+o}),t.addNode({id:g+f}),t.addEdge({id:I+`${o}-${f}`,from:g+o,to:g+f,weight:u})}}return t}toSerializedString(n=!1){const e={nodes:this.nodes.map(t=>({id:t.id,label:t.label??null,position:t.position??null,classes:t.classes??""})),edges:this.edges.map(t=>({id:t.id,from:t.from,to:t.to,weight:t.weight??null,classes:t.classes??""}))};return JSON.stringify(e,null,n?2:0)}static fromSerializedString(n){const e=JSON.parse(n),t=new h;if(Array.isArray(e.nodes))for(const s of e.nodes)t.addNode({id:s.id,label:s.label??void 0,position:s.position??void 0,classes:s.classes??""});if(Array.isArray(e.edges))for(const s of e.edges)t.addEdge({id:s.id,from:s.from,to:s.to,weight:s.weight??void 0,classes:s.classes??""});return t}};h=M([l.SerializableClass()],h);var x=Object.getOwnPropertyDescriptor,D=(n,e,t,s)=>{for(var i=s>1?void 0:s?x(e,t):e,r=n.length-1,o;r>=0;r--)(o=n[r])&&(i=o(i)||i);return i};let w=class{path;constructor(n){this.path=n}};w=D([l.SerializableClass()],w);class R{instance;maxCost;constructor(e,t){this.instance=e,this.maxCost=t}solve(){const e=this.instance.nodes,t=this.instance.edges,s=e.length;if(s==0)return v;if(s==1)return new w([e[0]]);const i=Array.from({length:s},()=>Array(s).fill(1/0));for(const a of t){const c=e.findIndex(d=>d.id==a.from),p=e.findIndex(d=>d.id==a.to);if(c!==-1&&p!==-1){const d=a.weight??1;i[c][p]=d,i[p][c]=d}}const r=0,o=1<<s,f=Array.from({length:o},()=>Array(s).fill(1/0)),u=Array.from({length:o},()=>Array(s).fill(-1));f[1<<r][r]=0;for(let a=0;a<o;a++)for(let c=0;c<s;c++){if(!(a&1<<c))continue;const p=a^1<<c;if(p!=0)for(let d=0;d<s;d++){if(!(p&1<<d))continue;const N=f[p][d]+i[d][c];N<f[a][c]&&(f[a][c]=N,u[a][c]=d)}}let m=1/0,A=-1;const C=o-1;for(let a=0;a<s;a++){const c=f[C][a]+i[a][r];c<m&&(m=c,A=a)}if(m==1/0||m>this.maxCost)return v;const _=[];let O=C,y=A;for(;y!==-1;){_.push(y);const a=u[O][y];O^=1<<y,y=a}_.reverse(),_.push(r);const $=_.map(a=>e[a]);return new w($)}}self.onmessage=async n=>{const e=n.data.graph,t=n.data.maxCost,s=h.fromSerializedString(e),i=new R(s,t);try{const r=i.solve();postMessage(r||v)}finally{postMessage(v)}}})();
