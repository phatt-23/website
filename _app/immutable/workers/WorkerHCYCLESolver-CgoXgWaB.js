(function(){"use strict";const u="unsolvable";class a{static SerializableClass(e){return function(s){const t=e??s.name;s.prototype.__type=t,a.registerClass(t,s)}}static serialize(e){if(e==null)return e;if(Array.isArray(e))return e.map(a.serialize);if(e instanceof Set)return{__type:"Set",values:Array.from(e).map(a.serialize)};if(e instanceof Map)return{__type:"Map",entries:Array.from(e.entries()).map(([s,t])=>[a.serialize(s),a.serialize(t)])};if(typeof e=="object"){if(Array.isArray(e))return e.map(a.serialize);const s=e.constructor,r={__type:e.__type??s.name};for(const[i,o]of Object.entries(e))r[i]=a.serialize(o);return r}return e}static revive(e){if(e==null)return e;if(Array.isArray(e))return e.map(a.revive);if(e.__type==="Set")return new Set(e.values.map(a.revive));if(e.__type==="Map")return new Map(e.entries.map(([s,t])=>[a.revive(s),a.revive(t)]));if(e.__type){const s=a.getClass(e.__type);if(!s)throw new Error(`Serializer - Unknown class: ${e.__type}`);const t=Object.create(s.prototype);for(const[r,i]of Object.entries(e))r!=="__type"&&(t[r]=a.revive(i));return t}return e}static registerClass(e,s){a.classRegistry.set(e,s)}static getClass(e){return a.classRegistry.get(e)}static classRegistry=new Map}a.registerClass(Object.name,Object);var y=Object.getOwnPropertyDescriptor,v=(n,e,s,t)=>{for(var r=t>1?void 0:t?y(e,s):e,i=n.length-1,o;i>=0;i--)(o=n[i])&&(r=o(r)||r);return r};let h=class{path;constructor(n){this.path=n}};h=v([a.SerializableClass()],h);class w{instance;constructor(e){this.instance=e}async solve(){const e=this.instance.nodes,s=this.instance.edges;if(this.instance.empty())throw new Error("Graph is empty.");const t=new Map;for(const d of e)t.set(d.id,new Set);for(const d of s)t.has(d.from)&&t.has(d.to)&&t.get(d.from).add(d.to);const r=e[0].id,i=[r],o=new Set([r]);if(!this.backtrack(r,r,o,i,e.length,t))return u;const g=this.instance.copy(),p=new Array;return i.forEach(d=>{const m=g.nodes.find(N=>N.id==d);if(!m)throw new Error(`Node id in the path is not pointing to any valid node: ${d}`);p.push(m)}),new h(p)}backtrack(e,s,t,r,i,o){if(t.size===i)return o.get(e)?.has(s)?(r.push(s),!0):!1;for(const c of o.get(e)??[])if(!t.has(c)){if(t.add(c),r.push(c),this.backtrack(c,s,t,r,i,o))return!0;t.delete(c),r.pop()}return!1}}class _{}const l="n:",E="e:";function A(n,e,s){return s.indexOf(n)===e}var O=Object.getOwnPropertyDescriptor,C=(n,e,s,t)=>{for(var r=t>1?void 0:t?O(e,s):e,i=n.length-1,o;i>=0;i--)(o=n[i])&&(r=o(r)||r);return r};let f=class extends _{_nodes;_edges;constructor(){super(),this._nodes=new Set,this._edges=new Set}addNode(n){n.classes==null&&(n.classes=""),!this.nodes.find(e=>e.id==n.id)&&this._nodes.add(n)}addEdge(n){n.classes==null&&(n.classes=""),!this.edges.find(e=>e.id==n.id)&&this._edges.add(n)}get nodes(){return Array.from(this._nodes.values())}get edges(){return Array.from(this._edges.values())}removeNode(n){if(!this._nodes.has(n))return;this._nodes.delete(n),Array.from(this.edges).filter(s=>s.to===n.id||s.from===n.id).forEach(s=>this._edges.delete(s))}removeEdge(n){this._edges.delete(n)}empty(){return this.nodes.length==0}copy(){const n=new f;for(const e of this._nodes)n.addNode({id:e.id,label:e.label,position:e.position?{...e.position}:void 0,classes:e.classes});for(const e of this._edges)n.addEdge({id:e.id,from:e.from,to:e.to,weight:e.weight,classes:e.classes});return n}asString(){const n=this.nodes.map(s=>s.id.slice(l.length)).join(`
`),e=this.edges.map(s=>s.from.slice(l.length)+" "+s.to.slice(l.length)+(s.weight!=null?" "+s.weight:"")).join(`
`);return n+`
`+e+`
`}static fromString(n){const e=n.split(`
`).map(t=>t.trim()).filter(t=>t.length).filter(A);let s=new f;console.debug("LINES",e);for(let t=0;t<e.length;t++){const i=e[t].split(" ").map(o=>o.trim()).filter(o=>o.length);if(i.length==1){const o=i;s.addNode({id:l+o})}else if(i.length<=3){const o=i[0],c=i[1];let g;if(i.length==3)try{g=Number.parseFloat(i[2])}catch{return`On the line ${t}, couldn't parse the weight: '${i[2]}Please enter a number (floating allowed)`}s.addNode({id:l+o}),s.addNode({id:l+c}),s.addEdge({id:E+`${o}-${c}`,from:l+o,to:l+c,weight:g})}}return s}toSerializedString(n=!1){const e={nodes:this.nodes.map(s=>({id:s.id,label:s.label??null,position:s.position??null,classes:s.classes??""})),edges:this.edges.map(s=>({id:s.id,from:s.from,to:s.to,weight:s.weight??null,classes:s.classes??""}))};return JSON.stringify(e,null,n?2:0)}static fromSerializedString(n){const e=JSON.parse(n),s=new f;if(Array.isArray(e.nodes))for(const t of e.nodes)s.addNode({id:t.id,label:t.label??void 0,position:t.position??void 0,classes:t.classes??""});if(Array.isArray(e.edges))for(const t of e.edges)s.addEdge({id:t.id,from:t.from,to:t.to,weight:t.weight??void 0,classes:t.classes??""});return s}};f=C([a.SerializableClass()],f),self.onmessage=async n=>{const e=f.fromSerializedString(n.data),t=await new w(e).solve();postMessage(t||u)}})();
