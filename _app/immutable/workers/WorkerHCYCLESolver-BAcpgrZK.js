(function(){"use strict";const p="unsolvable";class a{static SerializableClass(){return function(e){const t=e.name;e.prototype.__type=t,a.registerClass(t,e)}}static serialize(e){if(e==null)return e;if(Array.isArray(e))return e.map(a.serialize);if(e instanceof Set)return{__type:"Set",values:Array.from(e).map(a.serialize)};if(e instanceof Map)return{__type:"Map",entries:Array.from(e.entries()).map(([t,r])=>[a.serialize(t),a.serialize(r)])};if(typeof e=="object"){if(Array.isArray(e))return e.map(a.serialize);const t=e.constructor,n={__type:e.__type??t.name};for(const[o,i]of Object.entries(e))n[o]=a.serialize(i);return n}return e}static revive(e){if(e==null)return e;if(Array.isArray(e))return e.map(a.revive);if(e.__type==="Set")return new Set(e.values.map(a.revive));if(e.__type==="Map")return new Map(e.entries.map(([t,r])=>[a.revive(t),a.revive(r)]));if(e.__type){const t=a.getClass(e.__type);if(!t)throw new Error(`Unknown class: ${e.__type}`);const r=Object.create(t.prototype);for(const[n,o]of Object.entries(e))n!=="__type"&&(r[n]=a.revive(o));return r}return e}static registerClass(e,t){a.classRegistry.set(e,t)}static getClass(e){return a.classRegistry.get(e)}static classRegistry=new Map}a.registerClass(Object.name,Object);var g=Object.getOwnPropertyDescriptor,y=(s,e,t,r)=>{for(var n=r>1?void 0:r?g(e,t):e,o=s.length-1,i;o>=0;o--)(i=s[o])&&(n=i(n)||n);return n};let f=class{path;constructor(s){this.path=s}};f=y([a.SerializableClass()],f);class v{instance;constructor(e){this.instance=e}async solve(){const e=this.instance.nodes,t=this.instance.edges;if(this.instance.empty())throw new Error("Graph is empty.");const r=new Map;for(const c of e)r.set(c.id,new Set);for(const c of t)r.has(c.from)&&r.has(c.to)&&r.get(c.from).add(c.to);const n=e[0].id,o=[n],i=new Set([n]);if(!this.backtrack(n,n,i,o,e.length,r))return p;const C=this.instance.copy(),u=new Array;return o.forEach(c=>{const h=C.nodes.find(A=>A.id==c);if(!h)throw new Error(`Node id in the path is not pointing to any valid node: ${c}`);u.push(h)}),new f(u)}backtrack(e,t,r,n,o,i){if(r.size===o)return i.get(e)?.has(t)?(n.push(t),!0):!1;for(const d of i.get(e)??[])if(!r.has(d)){if(r.add(d),n.push(d),this.backtrack(d,t,r,n,o,i))return!0;r.delete(d),n.pop()}return!1}}class m{}var _=Object.getOwnPropertyDescriptor,w=(s,e,t,r)=>{for(var n=r>1?void 0:r?_(e,t):e,o=s.length-1,i;o>=0;o--)(i=s[o])&&(n=i(n)||n);return n};let l=class extends m{_nodes;_edges;constructor(){super(),this._nodes=new Set,this._edges=new Set}addNode(s){s.classes==null&&(s.classes=""),this._nodes.add(s)}addEdge(s){s.classes==null&&(s.classes=""),this._edges.add(s)}get nodes(){return Array.from(this._nodes.values())}get edges(){return Array.from(this._edges.values())}removeNode(s){if(!this._nodes.has(s))return;this._nodes.delete(s),Array.from(this.edges).filter(t=>t.to===s.id||t.from===s.id).forEach(t=>this._edges.delete(t))}removeEdge(s){this._edges.delete(s)}empty(){return this.nodes.length==0||this.edges.length==0}copy(){const s=new l;for(const e of this._nodes)s.addNode({id:e.id,label:e.label,position:e.position?{...e.position}:void 0,classes:e.classes});for(const e of this._edges)s.addEdge({id:e.id,from:e.from,to:e.to,weight:e.weight,classes:e.classes});return s}};l=w([a.SerializableClass()],l),a.registerClass(l.name,l),self.onmessage=async s=>{console.debug("-----------"),console.debug(l.name),console.debug(l),console.debug("-----------");const e=a.revive(s.data),r=await new v(e).solve();postMessage(r||p)}})();
