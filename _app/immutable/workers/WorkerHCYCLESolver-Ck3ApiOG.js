(function(){"use strict";const _="unsolvable";class a{static SerializableClass(e){return function(n){const t=e??n.name;n.prototype.__type=t,a.registerClass(t,n)}}static serialize(e){if(e==null)return e;if(Array.isArray(e))return e.map(a.serialize);if(e instanceof Set)return{__type:"Set",values:Array.from(e).map(a.serialize)};if(e instanceof Map)return{__type:"Map",entries:Array.from(e.entries()).map(([n,t])=>[a.serialize(n),a.serialize(t)])};if(typeof e=="object"){if(Array.isArray(e))return e.map(a.serialize);const n=e.constructor,r={__type:e.__type??n.name};for(const[i,o]of Object.entries(e))r[i]=a.serialize(o);return r}return e}static revive(e){if(e==null)return e;if(Array.isArray(e))return e.map(a.revive);if(e.__type==="Set")return new Set(e.values.map(a.revive));if(e.__type==="Map")return new Map(e.entries.map(([n,t])=>[a.revive(n),a.revive(t)]));if(e.__type){const n=a.getClass(e.__type);if(!n)throw new Error(`Serializer - Unknown class: ${e.__type}`);const t=Object.create(n.prototype);for(const[r,i]of Object.entries(e))r!=="__type"&&(t[r]=a.revive(i));return t}return e}static registerClass(e,n){a.classRegistry.set(e,n)}static getClass(e){return a.classRegistry.get(e)}static classRegistry=new Map}a.registerClass(Object.name,Object);var E=Object.getOwnPropertyDescriptor,A=(s,e,n,t)=>{for(var r=t>1?void 0:t?E(e,n):e,i=s.length-1,o;i>=0;i--)(o=s[i])&&(r=o(r)||r);return r};let m=class{constructor(s){this.path=s}};m=A([a.SerializableClass()],m);class N{instance;constructor(e){this.instance=e}solve(){const e=this.instance.nodes,n=this.instance.edges;if(this.instance.isEmpty())throw new Error("Graph is empty.");const t=new Map;for(const l of e)t.set(l.id,new Set);for(const l of n)t.has(l.from)&&t.has(l.to)&&t.get(l.from).add(l.to);const r=e[0].id,i=[r],o=new Set([r]);if(!this.backtrack(r,r,o,i,e.length,t))return _;const u=this.instance.copy(),f=new Array;return i.forEach(l=>{const v=u.nodes.find(w=>w.id==l);if(!v)throw new Error(`Node id in the path is not pointing to any valid node: ${l}`);f.push(v)}),new m(f)}backtrack(e,n,t,r,i,o){if(t.size===i)return o.get(e)?.has(n)?(r.push(n),!0):!1;for(const c of o.get(e)??[])if(!t.has(c)){if(t.add(c),r.push(c),this.backtrack(c,n,t,r,i,o))return!0;t.delete(c),r.pop()}return!1}}class b{}const L=":",g="n:",y="e:";function O(s,e,n){return n.indexOf(s)===e}var S=Object.getOwnPropertyDescriptor,C=(s,e,n,t)=>{for(var r=t>1?void 0:t?S(e,n):e,i=s.length-1,o;i>=0;i--)(o=s[i])&&(r=o(r)||r);return r};let h=class extends b{_nodes;_edges;constructor(){super(),this._nodes=new Set,this._edges=new Set}addNode(s){this.nodes.find(e=>e.id==s.id)||(s.classes==null&&(s.classes=""),s.label||(s.label=s.id),s.texLabel||(s.texLabel=s.label),this._nodes.add(s))}addEdge(s){s.classes==null&&(s.classes=""),!this.edges.find(e=>e.id==s.id)&&this._edges.add(s)}assignEdgeWeight(s,e){const n=this.edges.find(t=>t.id==s);n&&(n.weight=e)}get nodes(){return Array.from(this._nodes.values())}get edges(){return Array.from(this._edges.values())}removeNode(s){if(!this._nodes.has(s))return;this._nodes.delete(s),Array.from(this.edges).filter(n=>n.to===s.id||n.from===s.id).forEach(n=>this._edges.delete(n))}removeEdge(s){this._edges.delete(s)}removeEdgeById(s){const e=this.edges.find(n=>n.id==s);e&&this._edges.delete(e)}isEmpty(){return this.nodes.length==0}copy(){const s=new h;for(const e of this._nodes)s.addNode({id:e.id,label:e.label,texLabel:e.texLabel,color:e.color,position:e.position?{...e.position}:void 0,classes:e.classes});for(const e of this._edges)s.addEdge({id:e.id,from:e.from,to:e.to,weight:e.weight,classes:e.classes,controlPointDistances:e.controlPointDistances});return s}asString(){const s=this.nodes.map(n=>n.id.slice(g.length)).join(`
`),e=this.edges.map(n=>n.from.slice(g.length)+" "+n.to.slice(g.length)+(n.weight!=null?" "+n.weight:"")).join(`
`);return s+`
`+e+`
`}static fromString(s){if(s.length==0)return"Cannot construct a graph from empty string";const e=s.split(`
`).map(t=>t.trim()).filter(t=>t.length).filter(O);let n=new h;for(let t=0;t<e.length;t++){const r=e[t],i=r.split(" ").map(o=>o.trim()).filter(o=>o.length);if(i.length==1){const o=i[0];n.addNode({id:g+o,label:o})}else if(i.length<=3){const o=i[0],c=i[1];let u;if(i.length==3){if(!function(w){for(const d of w)if(!(d=="0"||d=="1"||d=="2"||d=="3"||d=="4"||d=="5"||d=="6"||d=="7"||d=="8"||d=="9"))return!1;return!0}(i[2]))return`
                            Encountered illegal syntax on line ${t}. 
                            Couldn't parse the weight "${i[2]}".
                            Please enter an integer.
                            The line: "${r}"
                        `;u=Number.parseFloat(i[2])}const f=g+o,l=g+c;n.addNode({id:f,label:o}),n.addNode({id:l,label:c}),n.addEdge({id:y+`${f}-${l}`,from:f,to:l,weight:u})}else return`
                    Encountered illegal syntax on line ${t}. 
                    Expected of these "{x}" or "{x} {y}" or "{x} {y} {w?}" on a single line, where {x} and {y} are node labels and {w?} is optional weight. 
                    Instead got: "${r}"`}return n}toSerializedString(){const s={nodes:this.nodes.map(e=>({id:e.id,label:e.label??null,texLabel:e.texLabel??null,color:e.color??null,position:e.position??null,classes:e.classes??""})),edges:this.edges.map(e=>({id:e.id,from:e.from,to:e.to,weight:e.weight??null,classes:e.classes??"",controlPointDistances:e.controlPointDistances??[0,0]}))};return JSON.stringify(s,null)}static fromSerializedString(s){const e=JSON.parse(s),n=new h;if(Array.isArray(e.nodes))for(const t of e.nodes)n.addNode({id:t.id,label:t.label??void 0,texLabel:t.texLabel??void 0,color:t.color??void 0,position:t.position??void 0,classes:t.classes??""});if(Array.isArray(e.edges))for(const t of e.edges)n.addEdge({id:t.id,from:t.from,to:t.to,weight:t.weight??void 0,classes:t.classes??"",controlPointDistances:t.controlPointDistances??[0,0]});return n}labelSolved({path:s=[],directed:e=!1,edgeIdUsesNodeIds:n=!0}={}){const t=n?(r=>r):(r=>r.slice(r.search(L)+1));this.edges.forEach(r=>r.classes+=" solved");for(let r=0;r<s.length-1;r++){const i=t(s[r].id),o=t(s[r+1].id),c=y+`${i}-${o}`,u=y+`${o}-${i}`,f=this.edges.find(l=>l.id==c||!e&&l.id==u);f&&(f.classes+=" used")}}unlabelSolved(){this._edges.forEach(s=>{s.classes&&(s.classes=s.classes.replaceAll("used",""),s.classes=s.classes.replaceAll("solved",""))})}};h=C([a.SerializableClass()],h);var p=(s=>(s.UNSOLVABLE="unsolvable",s.RESULT="result",s.ERROR="error",s))(p||{});self.onmessage=async s=>{try{const e=h.fromSerializedString(s.data.graph),t=new N(e).solve(),r=t==_?{type:p.UNSOLVABLE}:{type:p.RESULT,path:t.path};postMessage(r)}catch(e){postMessage({type:p.ERROR,message:e instanceof Error?e.message:String(e)})}}})();
