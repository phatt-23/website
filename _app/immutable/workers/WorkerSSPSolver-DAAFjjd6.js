(function(){"use strict";const f="unsolvable";class a{static SerializableClass(e){return function(r){const n=e??r.name;r.prototype.__type=n,a.registerClass(n,r)}}static serialize(e){if(e==null)return e;if(Array.isArray(e))return e.map(a.serialize);if(e instanceof Set)return{__type:"Set",values:Array.from(e).map(a.serialize)};if(e instanceof Map)return{__type:"Map",entries:Array.from(e.entries()).map(([r,n])=>[a.serialize(r),a.serialize(n)])};if(typeof e=="object"){if(Array.isArray(e))return e.map(a.serialize);const r=e.constructor,t={__type:e.__type??r.name};for(const[u,c]of Object.entries(e))t[u]=a.serialize(c);return t}return e}static revive(e){if(e==null)return e;if(Array.isArray(e))return e.map(a.revive);if(e.__type==="Set")return new Set(e.values.map(a.revive));if(e.__type==="Map")return new Map(e.entries.map(([r,n])=>[a.revive(r),a.revive(n)]));if(e.__type){const r=a.getClass(e.__type);if(!r)throw new Error(`Serializer - Unknown class: ${e.__type}`);const n=Object.create(r.prototype);for(const[t,u]of Object.entries(e))t!=="__type"&&(n[t]=a.revive(u));return n}return e}static registerClass(e,r){a.classRegistry.set(e,r)}static getClass(e){return a.classRegistry.get(e)}static classRegistry=new Map}a.registerClass(Object.name,Object);class v{}var g=Object.getOwnPropertyDescriptor,d=(s,e,r,n)=>{for(var t=n>1?void 0:n?g(e,r):e,u=s.length-1,c;u>=0;u--)(c=s[u])&&(t=c(t)||t);return t};let l=class extends v{numbers;target;constructor(){super(),this.numbers=[],this.target=[0]}addNumber(s){this.numbers.push(s)}setNumberValue(s,e){const r=this.numbers.find(n=>n.id===s);r&&(r.value=e)}getNumber(s){return this.numbers.find(e=>e.id==s)}setTarget(s){this.target=s}isEmpty(){return this.numbers.length==0}static fromString(s,e){const r=new l;if(!s)return"SSP cannot be constructed from an empty string";const n=s.split(`
`).map(t=>t.trim()).filter(t=>t.length);try{const t=Array(e).map(u=>Number.parseInt(u));r.setTarget(t)}catch{return`Couldn't parse the target number: ${e}`}return n.forEach((t,u)=>{try{const c=Array.from(t).map(i=>Number.parseInt(i)),p={id:`${u}`,value:c,used:!1};r.addNumber(p)}catch{return`Couldn't parse the number on the line ${u}: ${t}.`}}),r}toSerializedString(){const s={numbers:this.numbers.map(e=>({id:e.id,label:e.label??null,value:e.value,used:e.used,classes:e.classes??null})),target:this.target};return JSON.stringify(s)}static fromSerializedString(s){const e=new l,r=JSON.parse(s);if(e.setTarget(r.target),Array.isArray(r.numbers))for(const n of r.numbers){const t={id:n.id,label:n.label??void 0,value:n.value,used:n.used,classes:n.classes??void 0};e.addNumber(t)}return e}copy(){const s=new l;return s.setTarget([...this.target]),this.numbers.forEach(e=>{s.addNumber({id:e.id,label:e.label,value:[...e.value],used:e.used,classes:e.classes})}),s}};l=d([a.SerializableClass("SSP")],l);var h=Object.getOwnPropertyDescriptor,b=(s,e,r,n)=>{for(var t=n>1?void 0:n?h(e,r):e,u=s.length-1,c;u>=0;u--)(c=s[u])&&(t=c(t)||t);return t};let m=class{numbers;constructor(s){this.numbers=s}};m=b([a.SerializableClass()],m);class S{instance;constructor(e){this.instance=e}solve(){const e=this.instance.numbers,r=parseInt(this.instance.target.join("")),n=e.map(i=>parseInt(i.value.join(""))),t=new Map;t.set(0,-1);for(let i=0;i<n.length;i++){const w=n[i],O=Array.from(t.keys());for(const A of O){const y=A+w;t.has(y)||t.set(y,i)}}if(!t.has(r))return f;const u=[];let c=r;const p=new Set;for(;c>0;){const i=t.get(c);if(i===void 0||i===-1)break;u.push(e[i]),p.add(i),c-=n[i]}for(let i=0;i<e.length;i++)e[i].used=p.has(i);return new m(u)}}var o=(s=>(s.UNSOLVABLE="unsolvable",s.RESULT="result",s.ERROR="error",s))(o||{});self.onmessage=async s=>{try{const e=l.fromSerializedString(s.data.ssp);if(typeof e=="string"){postMessage({type:o.ERROR,message:"SSP couldn't be parsed from string."});return}const n=new S(e).solve(),t=n==f?{type:o.UNSOLVABLE}:{type:o.RESULT,numbers:n.numbers};postMessage(t)}catch(e){postMessage({type:o.ERROR,message:e instanceof Error?e.message:String(e)})}}})();
