(function(){"use strict";const y="unsolvable";class a{static SerializableClass(e){return function(t){const n=e??t.name;t.prototype.__type=n,a.registerClass(n,t)}}static serialize(e){if(e==null)return e;if(Array.isArray(e))return e.map(a.serialize);if(e instanceof Set)return{__type:"Set",values:Array.from(e).map(a.serialize)};if(e instanceof Map)return{__type:"Map",entries:Array.from(e.entries()).map(([t,n])=>[a.serialize(t),a.serialize(n)])};if(typeof e=="object"){if(Array.isArray(e))return e.map(a.serialize);const t=e.constructor,s={__type:e.__type??t.name};for(const[c,u]of Object.entries(e))s[c]=a.serialize(u);return s}return e}static revive(e){if(e==null)return e;if(Array.isArray(e))return e.map(a.revive);if(e.__type==="Set")return new Set(e.values.map(a.revive));if(e.__type==="Map")return new Map(e.entries.map(([t,n])=>[a.revive(t),a.revive(n)]));if(e.__type){const t=a.getClass(e.__type);if(!t)throw new Error(`Serializer - Unknown class: ${e.__type}`);const n=Object.create(t.prototype);for(const[s,c]of Object.entries(e))s!=="__type"&&(n[s]=a.revive(c));return n}return e}static registerClass(e,t){a.classRegistry.set(e,t)}static getClass(e){return a.classRegistry.get(e)}static classRegistry=new Map}a.registerClass(Object.name,Object);class h{}var d=Object.getOwnPropertyDescriptor,g=(r,e,t,n)=>{for(var s=n>1?void 0:n?d(e,t):e,c=r.length-1,u;c>=0;c--)(u=r[c])&&(s=u(s)||s);return s};let l=class{id;value;used;classes;constructor(r,e,t=!1,n){this.id=r,this.value=e,this.used=t,this.classes=n}asString(){return this.value.join("")}};l=g([a.SerializableClass("SSPNumber")],l);let o=class extends h{numbers;target;constructor(){super(),this.numbers=[],this.target=[0]}addNumber(r){this.numbers.push(r)}setTarget(r){this.target=r}isEmpty(){return this.numbers.length==0}static fromString(r,e){const t=new o;if(!r)return"SSP cannot be constructed from an empty string";const n=r.split(`
`).map(s=>s.trim()).filter(s=>s.length);try{const s=Array(e).map(c=>Number.parseInt(c));t.setTarget(s)}catch(s){return console.error(s),`Couldn't parse the target number: ${e}`}return n.forEach((s,c)=>{try{const u=Array.from(s).map(m=>Number.parseInt(m));t.addNumber(new l(`${c}`,u))}catch(u){return console.error(u),`Couldn't parse the number on the line ${c}: ${s}.`}}),t}toSerializedString(){const r={numbers:this.numbers.map(e=>({id:e.id,value:e.value,used:e.used,classes:e.classes??null})),target:this.target};return JSON.stringify(r)}static fromSerializedString(r){const e=new o,t=JSON.parse(r);if(e.setTarget(t.target),Array.isArray(t.numbers))for(const n of t.numbers)e.addNumber(new l(n.id,n.value,n.used,n.classes));return e}copy(){const r=new o;return r.setTarget([...this.target]),this.numbers.forEach(e=>{const t=new l(e.id,[...e.value],e.used,e.classes);r.addNumber(t)}),r}};o=g([a.SerializableClass("SSP")],o);var S=Object.getOwnPropertyDescriptor,w=(r,e,t,n)=>{for(var s=n>1?void 0:n?S(e,t):e,c=r.length-1,u;c>=0;c--)(u=r[c])&&(s=u(s)||s);return s};let f=class{numbers;constructor(r){this.numbers=r}};f=w([a.SerializableClass()],f);class b{instance;constructor(e){this.instance=e}solve(){console.debug("SolverSSP::solve()");const e=this.instance.numbers,t=parseInt(this.instance.target.join("")),n=e.map(i=>parseInt(i.value.join(""))),s=new Map;s.set(0,-1);for(let i=0;i<n.length;i++){const O=n[i],A=Array.from(s.keys());for(const C of A){const v=C+O;s.has(v)||s.set(v,i)}}if(!s.has(t))return y;const c=[];let u=t;const m=new Set;for(;u>0;){const i=s.get(u);if(i===void 0||i===-1)break;c.push(e[i]),m.add(i),u-=n[i]}for(let i=0;i<e.length;i++)e[i].used=m.has(i);return new f(c)}}var p=(r=>(r.UNSOLVABLE="unsolvable",r.RESULT="result",r.ERROR="error",r))(p||{});self.onmessage=async r=>{console.debug("WorkerSSPSolver::onmessage");try{const e=o.fromSerializedString(r.data.ssp);if(typeof e=="string"){postMessage({type:p.ERROR,message:"SSP couldn't be parsed from string."});return}const n=new b(e).solve(),s=n==y?{type:p.UNSOLVABLE}:{type:p.RESULT,numbers:n.numbers};postMessage(s)}catch(e){postMessage({type:p.ERROR,message:e instanceof Error?e.message:String(e)})}}})();
