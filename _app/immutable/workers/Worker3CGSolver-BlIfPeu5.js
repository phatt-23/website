(function(){"use strict";const p="unsolvable";class a{static SerializableClass(e){return function(t){const r=e??t.name;t.prototype.__type=r,a.registerClass(r,t)}}static serialize(e){if(e==null)return e;if(Array.isArray(e))return e.map(a.serialize);if(e instanceof Set)return{__type:"Set",values:Array.from(e).map(a.serialize)};if(e instanceof Map)return{__type:"Map",entries:Array.from(e.entries()).map(([t,r])=>[a.serialize(t),a.serialize(r)])};if(typeof e=="object"){if(Array.isArray(e))return e.map(a.serialize);const t=e.constructor,o={__type:e.__type??t.name};for(const[n,i]of Object.entries(e))o[n]=a.serialize(i);return o}return e}static revive(e){if(e==null)return e;if(Array.isArray(e))return e.map(a.revive);if(e.__type==="Set")return new Set(e.values.map(a.revive));if(e.__type==="Map")return new Map(e.entries.map(([t,r])=>[a.revive(t),a.revive(r)]));if(e.__type){const t=a.getClass(e.__type);if(!t)throw new Error(`Serializer - Unknown class: ${e.__type}`);const r=Object.create(t.prototype);for(const[o,n]of Object.entries(e))o!=="__type"&&(r[o]=a.revive(n));return r}return e}static registerClass(e,t){a.classRegistry.set(e,t)}static getClass(e){return a.classRegistry.get(e)}static classRegistry=new Map}a.registerClass(Object.name,Object);var m=Object.getOwnPropertyDescriptor,_=(s,e,t,r)=>{for(var o=r>1?void 0:r?m(e,t):e,n=s.length-1,i;n>=0;n--)(i=s[n])&&(o=i(o)||o);return o};let h=class{constructor(s){this.coloring=s}};h=_([a.SerializableClass("Certificate3CG")],h);class v{constructor(e){this.instance=e}solve(){const e=this.instance.copy(),t=e.nodes,r=this.buildAdjacency(e),o=new Map;return t.forEach(i=>{i.color&&o.set(i.id,i.color)}),this.backtrackColor(0,t,r,o)?new h(o):p}buildAdjacency(e){const t=new Map;for(const r of e.nodes)t.set(r.id,new Set);for(const r of e.edges)t.get(r.from).add(r.to),t.get(r.to).add(r.from);return t}backtrackColor(e,t,r,o){if(e==t.length)return!0;const n=t[e],i=o.has(n.id);for(let c=0;c<3;c++)if(this.canUseColor(n.id,c,r,o)){if(i||o.set(n.id,c),this.backtrackColor(e+1,t,r,o))return!0;i||o.delete(n.id)}return!1}canUseColor(e,t,r,o){for(const n of r.get(e))if(o.get(n)==t)return!1;return!0}}class y{}class E extends Error{}function D(s,e){if(!s)throw new E("[ASSERT] "+e)}function w(s,e,t){return t.indexOf(s)===e}var I=Object.getOwnPropertyDescriptor,P=(s,e,t,r)=>{for(var o=r>1?void 0:r?I(e,t):e,n=s.length-1,i;n>=0;n--)(i=s[n])&&(o=i(o)||o);return o};let d=class extends y{_nodes;_edges;constructor(){super(),this._nodes=new Set,this._edges=new Set}addNode(s){s.classes==null&&(s.classes=""),!this.nodes.find(e=>e.id==s.id)&&this._nodes.add(s)}addEdge(s){s.classes==null&&(s.classes=""),s.controlPointDistances==null&&(s.controlPointDistances=[0,0]),D(s.controlPointDistances.length==2,"There must be 2 control points."),!this.edges.find(e=>e.id==s.id)&&this._edges.add(s)}get nodes(){return Array.from(this._nodes.values())}get edges(){return Array.from(this._edges.values())}removeNode(s){if(!this._nodes.has(s))return;this._nodes.delete(s),Array.from(this.edges).filter(t=>t.to===s.id||t.from===s.id).forEach(t=>this._edges.delete(t))}removeEdge(s){this._edges.delete(s)}removeEdgeById(s){const e=this.edges.find(t=>t.id==s);e?(console.log("deleting edge with id",s),this._edges.delete(e)):console.log("edge with id",s,"not found")}isEmpty(){return this.nodes.length==0}copy(){const s=new d;for(const e of this._nodes)s.addNode({id:e.id,label:e.label,color:e.color,position:e.position?{...e.position}:void 0,classes:e.classes});for(const e of this._edges)s.addEdge({id:e.id,from:e.from,to:e.to,weight:e.weight,classes:e.classes,controlPointDistances:e.controlPointDistances});return s}asString(){const s=this.nodes.map(t=>t.id.slice(2)).join(`
`),e=this.edges.map(t=>t.from.slice(2)+" "+t.to.slice(2)+(t.weight!=null?" "+t.weight:"")).join(`
`);return s+`
`+e+`
`}static fromString(s){if(s.length==0)return"Cannot construct a graph from empty string";const e=s.split(`
`).map(r=>r.trim()).filter(r=>r.length).filter(w);let t=new d;console.debug("LINES",e);for(let r=0;r<e.length;r++){const n=e[r].split(" ").map(i=>i.trim()).filter(i=>i.length);if(n.length==1){const i=n;t.addNode({id:"n:"+i})}else if(n.length<=3){const i=n[0],c=n[1];let g;if(n.length==3)try{g=Number.parseFloat(n[2])}catch{return`On the line ${r}, couldn't parse the weight: '${n[2]}Please enter a number (floating allowed)`}const l="n:"+i,f="n:"+c;t.addNode({id:l}),t.addNode({id:f}),t.addEdge({id:`e:${l}-${f}`,from:l,to:f,weight:g})}}return t}toSerializedString(){const s={nodes:this.nodes.map(e=>({id:e.id,label:e.label??null,color:e.color??null,position:e.position??null,classes:e.classes??""})),edges:this.edges.map(e=>({id:e.id,from:e.from,to:e.to,weight:e.weight??null,classes:e.classes??"",controlPointDistances:e.controlPointDistances??[0,0]}))};return JSON.stringify(s,null)}static fromSerializedString(s){const e=JSON.parse(s),t=new d;if(Array.isArray(e.nodes))for(const r of e.nodes)t.addNode({id:r.id,label:r.label??void 0,color:r.color??void 0,position:r.position??void 0,classes:r.classes??""});if(Array.isArray(e.edges))for(const r of e.edges)t.addEdge({id:r.id,from:r.from,to:r.to,weight:r.weight??void 0,classes:r.classes??"",controlPointDistances:r.controlPointDistances??[0,0]});return t}labelSolved({path:s=[],directed:e=!1,edgeIdUsesNodeIds:t=!0}={}){console.debug("edgeIdUsesNodeIds",t);const r=t?(o=>o):(o=>o.slice(o.search(":")+1));this.edges.forEach(o=>o.classes+=" solved");for(let o=0;o<s.length-1;o++){const n=r(s[o].id),i=r(s[o+1].id),c=`e:${n}-${i}`,g=`e:${i}-${n}`,l=this.edges.find(f=>f.id==c||!e&&f.id==g);console.debug("edgeId",c,"edgeIdMirror",g,"edge found",l!=null),l&&(l.classes+=" used")}}unlabelSolved(){this._edges.forEach(s=>{s.classes&&(s.classes=s.classes.replaceAll("used",""),s.classes=s.classes.replaceAll("solved",""))})}};d=P([a.SerializableClass()],d);var u=(s=>(s.UNSOLVABLE="unsolvable",s.RESULT="result",s.ERROR="error",s))(u||{});self.onmessage=async s=>{console.debug("Worker3CGSolver::onmessage");try{const e=d.fromSerializedString(s.data.graph),r=new v(e).solve(),o=r==p?{type:u.UNSOLVABLE}:{type:u.RESULT,coloring:Array.from(r.coloring.entries())};postMessage(o)}catch(e){const t={type:u.ERROR,message:e instanceof Error?e.message:String(e)};postMessage(t)}}})();
