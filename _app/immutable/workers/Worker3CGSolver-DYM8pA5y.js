(function(){"use strict";const _="unsolvable";class a{static SerializableClass(e){return function(t){const r=e??t.name;t.prototype.__type=r,a.registerClass(r,t)}}static serialize(e){if(e==null)return e;if(Array.isArray(e))return e.map(a.serialize);if(e instanceof Set)return{__type:"Set",values:Array.from(e).map(a.serialize)};if(e instanceof Map)return{__type:"Map",entries:Array.from(e.entries()).map(([t,r])=>[a.serialize(t),a.serialize(r)])};if(typeof e=="object"){if(Array.isArray(e))return e.map(a.serialize);const t=e.constructor,n={__type:e.__type??t.name};for(const[o,i]of Object.entries(e))n[o]=a.serialize(i);return n}return e}static revive(e){if(e==null)return e;if(Array.isArray(e))return e.map(a.revive);if(e.__type==="Set")return new Set(e.values.map(a.revive));if(e.__type==="Map")return new Map(e.entries.map(([t,r])=>[a.revive(t),a.revive(r)]));if(e.__type){const t=a.getClass(e.__type);if(!t)throw new Error(`Serializer - Unknown class: ${e.__type}`);const r=Object.create(t.prototype);for(const[n,o]of Object.entries(e))n!=="__type"&&(r[n]=a.revive(o));return r}return e}static registerClass(e,t){a.classRegistry.set(e,t)}static getClass(e){return a.classRegistry.get(e)}static classRegistry=new Map}a.registerClass(Object.name,Object);var m=Object.getOwnPropertyDescriptor,y=(s,e,t,r)=>{for(var n=r>1?void 0:r?m(e,t):e,o=s.length-1,i;o>=0;o--)(i=s[o])&&(n=i(n)||n);return n};let p=class{constructor(s){this.coloring=s}};p=y([a.SerializableClass("Certificate3CG")],p);class v{constructor(e){this.instance=e}solve(){const e=this.instance.copy(),t=e.nodes,r=this.buildAdjacency(e),n=new Map;return t.forEach(i=>{i.color&&n.set(i.id,i.color)}),this.backtrackColor(0,t,r,n)?new p(n):_}buildAdjacency(e){const t=new Map;for(const r of e.nodes)t.set(r.id,new Set);for(const r of e.edges)t.get(r.from).add(r.to),t.get(r.to).add(r.from);return t}backtrackColor(e,t,r,n){if(e==t.length)return!0;const o=t[e],i=n.has(o.id);for(let c=0;c<3;c++)if(this.canUseColor(o.id,c,r,n)){if(i||n.set(o.id,c),this.backtrackColor(e+1,t,r,n))return!0;i||n.delete(o.id)}return!1}canUseColor(e,t,r,n){for(const o of r.get(e))if(n.get(o)==t)return!1;return!0}}class E{}function D(s,e,t){return t.indexOf(s)===e}var w=Object.getOwnPropertyDescriptor,I=(s,e,t,r)=>{for(var n=r>1?void 0:r?w(e,t):e,o=s.length-1,i;o>=0;o--)(i=s[o])&&(n=i(n)||n);return n};let d=class extends E{_nodes;_edges;constructor(){super(),this._nodes=new Set,this._edges=new Set}addNode(s){this.nodes.find(e=>e.id==s.id)||(s.classes==null&&(s.classes=""),s.label||(s.label=s.id),s.texLabel||(s.texLabel=s.label),this._nodes.add(s))}addEdge(s){s.classes==null&&(s.classes=""),!this.edges.find(e=>e.id==s.id)&&this._edges.add(s)}get nodes(){return Array.from(this._nodes.values())}get edges(){return Array.from(this._edges.values())}removeNode(s){if(!this._nodes.has(s))return;this._nodes.delete(s),Array.from(this.edges).filter(t=>t.to===s.id||t.from===s.id).forEach(t=>this._edges.delete(t))}removeEdge(s){this._edges.delete(s)}removeEdgeById(s){const e=this.edges.find(t=>t.id==s);e&&this._edges.delete(e)}isEmpty(){return this.nodes.length==0}copy(){const s=new d;for(const e of this._nodes)s.addNode({id:e.id,label:e.label,texLabel:e.texLabel,color:e.color,position:e.position?{...e.position}:void 0,classes:e.classes});for(const e of this._edges)s.addEdge({id:e.id,from:e.from,to:e.to,weight:e.weight,classes:e.classes,controlPointDistances:e.controlPointDistances});return s}asString(){const s=this.nodes.map(t=>t.id.slice(2)).join(`
`),e=this.edges.map(t=>t.from.slice(2)+" "+t.to.slice(2)+(t.weight!=null?" "+t.weight:"")).join(`
`);return s+`
`+e+`
`}static fromString(s){if(s.length==0)return"Cannot construct a graph from empty string";const e=s.split(`
`).map(r=>r.trim()).filter(r=>r.length).filter(D);let t=new d;for(let r=0;r<e.length;r++){const n=e[r],o=n.split(" ").map(i=>i.trim()).filter(i=>i.length);if(o.length==1){const i=o[0];t.addNode({id:"n:"+i,label:i})}else if(o.length<=3){const i=o[0],c=o[1];let h;if(o.length==3){if(!function(N){for(const l of N)if(!(l=="0"||l=="1"||l=="2"||l=="3"||l=="4"||l=="5"||l=="6"||l=="7"||l=="8"||l=="9"))return!1;return!0}(o[2]))return`
                            Encountered illegal syntax on line ${r}. 
                            Couldn't parse the weight "${o[2]}".
                            Please enter an integer.
                            The line: "${n}"
                        `;h=Number.parseFloat(o[2])}const f="n:"+i,g="n:"+c;t.addNode({id:f,label:i}),t.addNode({id:g,label:c}),t.addEdge({id:`e:${f}-${g}`,from:f,to:g,weight:h})}else return`
                    Encountered illegal syntax on line ${r}. 
                    Expected of these "{x}" or "{x} {y}" or "{x} {y} {w?}" on a single line, where {x} and {y} are node labels and {w?} is optional weight. 
                    Instead got: "${n}"`}return t}toSerializedString(){const s={nodes:this.nodes.map(e=>({id:e.id,label:e.label??null,texLabel:e.texLabel??null,color:e.color??null,position:e.position??null,classes:e.classes??""})),edges:this.edges.map(e=>({id:e.id,from:e.from,to:e.to,weight:e.weight??null,classes:e.classes??"",controlPointDistances:e.controlPointDistances??[0,0]}))};return JSON.stringify(s,null)}static fromSerializedString(s){const e=JSON.parse(s),t=new d;if(Array.isArray(e.nodes))for(const r of e.nodes)t.addNode({id:r.id,label:r.label??void 0,texLabel:r.texLabel??void 0,color:r.color??void 0,position:r.position??void 0,classes:r.classes??""});if(Array.isArray(e.edges))for(const r of e.edges)t.addEdge({id:r.id,from:r.from,to:r.to,weight:r.weight??void 0,classes:r.classes??"",controlPointDistances:r.controlPointDistances??[0,0]});return t}labelSolved({path:s=[],directed:e=!1,edgeIdUsesNodeIds:t=!0}={}){const r=t?(n=>n):(n=>n.slice(n.search(":")+1));this.edges.forEach(n=>n.classes+=" solved");for(let n=0;n<s.length-1;n++){const o=r(s[n].id),i=r(s[n+1].id),c=`e:${o}-${i}`,h=`e:${i}-${o}`,f=this.edges.find(g=>g.id==c||!e&&g.id==h);f&&(f.classes+=" used")}}unlabelSolved(){this._edges.forEach(s=>{s.classes&&(s.classes=s.classes.replaceAll("used",""),s.classes=s.classes.replaceAll("solved",""))})}};d=I([a.SerializableClass()],d);var u=(s=>(s.UNSOLVABLE="unsolvable",s.RESULT="result",s.ERROR="error",s))(u||{});self.onmessage=async s=>{try{const e=d.fromSerializedString(s.data.graph),r=new v(e).solve(),n=r==_?{type:u.UNSOLVABLE}:{type:u.RESULT,coloring:Array.from(r.coloring.entries())};postMessage(n)}catch(e){const t={type:u.ERROR,message:e instanceof Error?e.message:String(e)};postMessage(t)}}})();
