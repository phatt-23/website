(function(){"use strict";const x="unsolvable";class O{}class l{static SerializableClass(e){return function(n){const s=e??n.name;n.prototype.__type=s,l.registerClass(s,n)}}static serialize(e){if(e==null)return e;if(Array.isArray(e))return e.map(l.serialize);if(e instanceof Set)return{__type:"Set",values:Array.from(e).map(l.serialize)};if(e instanceof Map)return{__type:"Map",entries:Array.from(e.entries()).map(([n,s])=>[l.serialize(n),l.serialize(s)])};if(typeof e=="object"){if(Array.isArray(e))return e.map(l.serialize);const n=e.constructor,r={__type:e.__type??n.name};for(const[i,o]of Object.entries(e))r[i]=l.serialize(o);return r}return e}static revive(e){if(e==null)return e;if(Array.isArray(e))return e.map(l.revive);if(e.__type==="Set")return new Set(e.values.map(l.revive));if(e.__type==="Map")return new Map(e.entries.map(([n,s])=>[l.revive(n),l.revive(s)]));if(e.__type){const n=l.getClass(e.__type);if(!n)throw new Error(`Serializer - Unknown class: ${e.__type}`);const s=Object.create(n.prototype);for(const[r,i]of Object.entries(e))r!=="__type"&&(s[r]=l.revive(i));return s}return e}static registerClass(e,n){l.classRegistry.set(e,n)}static getClass(e){return l.classRegistry.get(e)}static classRegistry=new Map}l.registerClass(Object.name,Object);const P=":",y="n:",N="e:";function S(t,e,n){return n.indexOf(t)===e}var D=Object.getOwnPropertyDescriptor,L=(t,e,n,s)=>{for(var r=s>1?void 0:s?D(e,n):e,i=t.length-1,o;i>=0;i--)(o=t[i])&&(r=o(r)||r);return r};let v=class extends O{_nodes;_edges;constructor(){super(),this._nodes=new Set,this._edges=new Set}addNode(t){this.nodes.find(e=>e.id==t.id)||(t.classes==null&&(t.classes=""),t.label||(t.label=t.id),t.texLabel||(t.texLabel=t.label),this._nodes.add(t))}addEdge(t){t.classes==null&&(t.classes=""),!this.edges.find(e=>e.id==t.id)&&this._edges.add(t)}assignEdgeWeight(t,e){const n=this.edges.find(s=>s.id==t);n&&(n.weight=e)}get nodes(){return Array.from(this._nodes.values())}get edges(){return Array.from(this._edges.values())}removeNode(t){if(!this._nodes.has(t))return;this._nodes.delete(t),Array.from(this.edges).filter(n=>n.to===t.id||n.from===t.id).forEach(n=>this._edges.delete(n))}removeEdge(t){this._edges.delete(t)}removeEdgeById(t){const e=this.edges.find(n=>n.id==t);e&&this._edges.delete(e)}isEmpty(){return this.nodes.length==0}copy(){const t=new v;for(const e of this._nodes)t.addNode({id:e.id,label:e.label,texLabel:e.texLabel,color:e.color,position:e.position?{...e.position}:void 0,classes:e.classes});for(const e of this._edges)t.addEdge({id:e.id,from:e.from,to:e.to,weight:e.weight,classes:e.classes,controlPointDistances:e.controlPointDistances});return t}asString(){const t=this.nodes.map(n=>n.id.slice(y.length)).join(`
`),e=this.edges.map(n=>n.from.slice(y.length)+" "+n.to.slice(y.length)+(n.weight!=null?" "+n.weight:"")).join(`
`);return t+`
`+e+`
`}static fromString(t){if(t.length==0)return"Cannot construct a graph from empty string";const e=t.split(`
`).map(s=>s.trim()).filter(s=>s.length).filter(S);let n=new v;for(let s=0;s<e.length;s++){const r=e[s],i=r.split(" ").map(o=>o.trim()).filter(o=>o.length);if(i.length==1){const o=i[0];n.addNode({id:y+o,label:o})}else if(i.length<=3){const o=i[0],u=i[1];let p;if(i.length==3){if(!function(w){for(const d of w)if(!(d=="0"||d=="1"||d=="2"||d=="3"||d=="4"||d=="5"||d=="6"||d=="7"||d=="8"||d=="9"))return!1;return!0}(i[2]))return`
                            Encountered illegal syntax on line ${s}. 
                            Couldn't parse the weight "${i[2]}".
                            Please enter an integer.
                            The line: "${r}"
                        `;p=Number.parseFloat(i[2])}const g=y+o,h=y+u;n.addNode({id:g,label:o}),n.addNode({id:h,label:u}),n.addEdge({id:N+`${g}-${h}`,from:g,to:h,weight:p})}else return`
                    Encountered illegal syntax on line ${s}. 
                    Expected of these "{x}" or "{x} {y}" or "{x} {y} {w?}" on a single line, where {x} and {y} are node labels and {w?} is optional weight. 
                    Instead got: "${r}"`}return n}toSerializedString(){const t={nodes:this.nodes.map(e=>({id:e.id,label:e.label??null,texLabel:e.texLabel??null,color:e.color??null,position:e.position??null,classes:e.classes??""})),edges:this.edges.map(e=>({id:e.id,from:e.from,to:e.to,weight:e.weight??null,classes:e.classes??"",controlPointDistances:e.controlPointDistances??[0,0]}))};return JSON.stringify(t,null)}static fromSerializedString(t){const e=JSON.parse(t),n=new v;if(Array.isArray(e.nodes))for(const s of e.nodes)n.addNode({id:s.id,label:s.label??void 0,texLabel:s.texLabel??void 0,color:s.color??void 0,position:s.position??void 0,classes:s.classes??""});if(Array.isArray(e.edges))for(const s of e.edges)n.addEdge({id:s.id,from:s.from,to:s.to,weight:s.weight??void 0,classes:s.classes??"",controlPointDistances:s.controlPointDistances??[0,0]});return n}labelSolved({path:t=[],directed:e=!1,edgeIdUsesNodeIds:n=!0}={}){const s=n?(r=>r):(r=>r.slice(r.search(P)+1));this.edges.forEach(r=>r.classes+=" solved");for(let r=0;r<t.length-1;r++){const i=s(t[r].id),o=s(t[r+1].id),u=N+`${i}-${o}`,p=N+`${o}-${i}`,g=this.edges.find(h=>h.id==u||!e&&h.id==p);g&&(g.classes+=" used")}}unlabelSolved(){this._edges.forEach(t=>{t.classes&&(t.classes=t.classes.replaceAll("used",""),t.classes=t.classes.replaceAll("solved",""))})}};v=L([l.SerializableClass()],v);var b=Object.getOwnPropertyDescriptor,R=(t,e,n,s)=>{for(var r=s>1?void 0:s?b(e,n):e,i=t.length-1,o;i>=0;i--)(o=t[i])&&(r=o(r)||r);return r};let E=class{constructor(t){this.path=t}};E=R([l.SerializableClass()],E);class ${instance;maxCost;constructor(e,n){this.instance=e,this.maxCost=n}solve(){const e=this.instance.nodes,n=this.instance.edges,s=e.length;if(s==0)return x;if(s==1)return new E([e[0]]);const r=Array.from({length:s},()=>Array(s).fill(1/0));for(const a of n){const c=e.findIndex(f=>f.id==a.from),m=e.findIndex(f=>f.id==a.to);if(c!==-1&&m!==-1){const f=a.weight??1;r[c][m]=f,r[m][c]=f}}const i=0,o=1<<s,u=Array.from({length:o},()=>Array(s).fill(1/0)),p=Array.from({length:o},()=>Array(s).fill(-1));u[1<<i][i]=0;for(let a=0;a<o;a++)for(let c=0;c<s;c++){if(!(a&1<<c))continue;const m=a^1<<c;if(m!=0)for(let f=0;f<s;f++){if(!(m&1<<f))continue;const I=u[m][f]+r[f][c];I<u[a][c]&&(u[a][c]=I,p[a][c]=f)}}let g=1/0,h=-1;const C=o-1;for(let a=0;a<s;a++){const c=u[C][a]+r[a][i];c<g&&(g=c,h=a)}if(g==1/0||g>this.maxCost)return x;const w=[];let d=C,_=h;for(;_!==-1;){w.push(_);const a=p[d][_];d^=1<<_,_=a}w.reverse(),w.push(i);const M=w.map(a=>e[a]);return new E(M)}}var A=(t=>(t.UNSOLVABLE="unsolvable",t.RESULT="result",t.ERROR="error",t))(A||{});self.onmessage=async t=>{try{const e=t.data.graph,n=t.data.maxCost,s=v.fromSerializedString(e),i=new $(s,n).solve(),o=i==x?{type:A.UNSOLVABLE}:{type:A.RESULT,path:i.path};postMessage(o)}catch(e){postMessage({type:A.ERROR,message:e instanceof Error?e.message:String(e)})}}})();
