(function(){"use strict";const A="unsolvable";class N{}class l{static SerializableClass(e){return function(n){const t=e??n.name;n.prototype.__type=t,l.registerClass(t,n)}}static serialize(e){if(e==null)return e;if(Array.isArray(e))return e.map(l.serialize);if(e instanceof Set)return{__type:"Set",values:Array.from(e).map(l.serialize)};if(e instanceof Map)return{__type:"Map",entries:Array.from(e.entries()).map(([n,t])=>[l.serialize(n),l.serialize(t)])};if(typeof e=="object"){if(Array.isArray(e))return e.map(l.serialize);const n=e.constructor,o={__type:e.__type??n.name};for(const[r,i]of Object.entries(e))o[r]=l.serialize(i);return o}return e}static revive(e){if(e==null)return e;if(Array.isArray(e))return e.map(l.revive);if(e.__type==="Set")return new Set(e.values.map(l.revive));if(e.__type==="Map")return new Map(e.entries.map(([n,t])=>[l.revive(n),l.revive(t)]));if(e.__type){const n=l.getClass(e.__type);if(!n)throw new Error(`Serializer - Unknown class: ${e.__type}`);const t=Object.create(n.prototype);for(const[o,r]of Object.entries(e))o!=="__type"&&(t[o]=l.revive(r));return t}return e}static registerClass(e,n){l.classRegistry.set(e,n)}static getClass(e){return l.classRegistry.get(e)}static classRegistry=new Map}l.registerClass(Object.name,Object);const O=":",m="n:",I="e:";class C extends Error{}function R(s,e){if(!s)throw new C("[ASSERT] "+e)}function M(s,e,n){return n.indexOf(s)===e}var $=Object.getOwnPropertyDescriptor,L=(s,e,n,t)=>{for(var o=t>1?void 0:t?$(e,n):e,r=s.length-1,i;r>=0;r--)(i=s[r])&&(o=i(o)||o);return o};let v=class extends N{_nodes;_edges;constructor(){super(),this._nodes=new Set,this._edges=new Set}addNode(s){s.classes==null&&(s.classes=""),!this.nodes.find(e=>e.id==s.id)&&this._nodes.add(s)}addEdge(s){s.classes==null&&(s.classes=""),s.controlPointDistances==null&&(s.controlPointDistances=[0,0]),R(s.controlPointDistances.length==2,"There must be 2 control points."),!this.edges.find(e=>e.id==s.id)&&this._edges.add(s)}get nodes(){return Array.from(this._nodes.values())}get edges(){return Array.from(this._edges.values())}removeNode(s){if(!this._nodes.has(s))return;this._nodes.delete(s),Array.from(this.edges).filter(n=>n.to===s.id||n.from===s.id).forEach(n=>this._edges.delete(n))}removeEdge(s){this._edges.delete(s)}removeEdgeById(s){const e=this.edges.find(n=>n.id==s);e?(console.log("deleting edge with id",s),this._edges.delete(e)):console.log("edge with id",s,"not found")}isEmpty(){return this.nodes.length==0}copy(){const s=new v;for(const e of this._nodes)s.addNode({id:e.id,label:e.label,color:e.color,position:e.position?{...e.position}:void 0,classes:e.classes});for(const e of this._edges)s.addEdge({id:e.id,from:e.from,to:e.to,weight:e.weight,classes:e.classes,controlPointDistances:e.controlPointDistances});return s}asString(){const s=this.nodes.map(n=>n.id.slice(m.length)).join(`
`),e=this.edges.map(n=>n.from.slice(m.length)+" "+n.to.slice(m.length)+(n.weight!=null?" "+n.weight:"")).join(`
`);return s+`
`+e+`
`}static fromString(s){if(s.length==0)return"Cannot construct a graph from empty string";const e=s.split(`
`).map(t=>t.trim()).filter(t=>t.length).filter(M);let n=new v;console.debug("LINES",e);for(let t=0;t<e.length;t++){const r=e[t].split(" ").map(i=>i.trim()).filter(i=>i.length);if(r.length==1){const i=r;n.addNode({id:m+i})}else if(r.length<=3){const i=r[0],g=r[1];let u;if(r.length==3)try{u=Number.parseFloat(r[2])}catch{return`On the line ${t}, couldn't parse the weight: '${r[2]}Please enter a number (floating allowed)`}const f=m+i,h=m+g;n.addNode({id:f}),n.addNode({id:h}),n.addEdge({id:I+`${f}-${h}`,from:f,to:h,weight:u})}}return n}toSerializedString(){const s={nodes:this.nodes.map(e=>({id:e.id,label:e.label??null,color:e.color??null,position:e.position??null,classes:e.classes??""})),edges:this.edges.map(e=>({id:e.id,from:e.from,to:e.to,weight:e.weight??null,classes:e.classes??"",controlPointDistances:e.controlPointDistances??[0,0]}))};return JSON.stringify(s,null)}static fromSerializedString(s){const e=JSON.parse(s),n=new v;if(Array.isArray(e.nodes))for(const t of e.nodes)n.addNode({id:t.id,label:t.label??void 0,color:t.color??void 0,position:t.position??void 0,classes:t.classes??""});if(Array.isArray(e.edges))for(const t of e.edges)n.addEdge({id:t.id,from:t.from,to:t.to,weight:t.weight??void 0,classes:t.classes??"",controlPointDistances:t.controlPointDistances??[0,0]});return n}labelSolved({path:s=[],directed:e=!1,edgeIdUsesNodeIds:n=!0}={}){console.debug("edgeIdUsesNodeIds",n);const t=n?(o=>o):(o=>o.slice(o.search(O)+1));this.edges.forEach(o=>o.classes+=" solved");for(let o=0;o<s.length-1;o++){const r=t(s[o].id),i=t(s[o+1].id),g=I+`${r}-${i}`,u=I+`${i}-${r}`,f=this.edges.find(h=>h.id==g||!e&&h.id==u);console.debug("edgeId",g,"edgeIdMirror",u,"edge found",f!=null),f&&(f.classes+=" used")}}unlabelSolved(){this._edges.forEach(s=>{s.classes&&(s.classes=s.classes.replaceAll("used",""),s.classes=s.classes.replaceAll("solved",""))})}};v=L([l.SerializableClass()],v);var x=Object.getOwnPropertyDescriptor,T=(s,e,n,t)=>{for(var o=t>1?void 0:t?x(e,n):e,r=s.length-1,i;r>=0;r--)(i=s[r])&&(o=i(o)||o);return o};let w=class{path;constructor(s){this.path=s}};w=T([l.SerializableClass()],w);class U{instance;maxCost;constructor(e,n){this.instance=e,this.maxCost=n}solve(){const e=this.instance.nodes,n=this.instance.edges,t=e.length;if(t==0)return A;if(t==1)return new w([e[0]]);const o=Array.from({length:t},()=>Array(t).fill(1/0));for(const a of n){const c=e.findIndex(d=>d.id==a.from),p=e.findIndex(d=>d.id==a.to);if(c!==-1&&p!==-1){const d=a.weight??1;o[c][p]=d,o[p][c]=d}}const r=0,i=1<<t,g=Array.from({length:i},()=>Array(t).fill(1/0)),u=Array.from({length:i},()=>Array(t).fill(-1));g[1<<r][r]=0;for(let a=0;a<i;a++)for(let c=0;c<t;c++){if(!(a&1<<c))continue;const p=a^1<<c;if(p!=0)for(let d=0;d<t;d++){if(!(p&1<<d))continue;const D=g[p][d]+o[d][c];D<g[a][c]&&(g[a][c]=D,u[a][c]=d)}}let f=1/0,h=-1;const P=i-1;for(let a=0;a<t;a++){const c=g[P][a]+o[a][r];c<f&&(f=c,h=a)}if(f==1/0||f>this.maxCost)return A;const E=[];let S=P,y=h;for(;y!==-1;){E.push(y);const a=u[S][y];S^=1<<y,y=a}E.reverse(),E.push(r);const k=E.map(a=>e[a]);return new w(k)}}var _=(s=>(s.UNSOLVABLE="unsolvable",s.RESULT="result",s.ERROR="error",s))(_||{});self.onmessage=async s=>{console.debug("WorkerTSPSolver::onmessage");try{const e=s.data.graph,n=s.data.maxCost,t=v.fromSerializedString(e),r=new U(t,n).solve(),i=r==A?{type:_.UNSOLVABLE}:{type:_.RESULT,path:r.path};postMessage(i)}catch(e){postMessage({type:_.ERROR,message:e instanceof Error?e.message:String(e)})}}})();
