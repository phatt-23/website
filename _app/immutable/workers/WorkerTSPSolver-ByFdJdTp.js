(function(){"use strict";const E="unsolvable";class P{}class l{static SerializableClass(e){return function(n){const t=e??n.name;n.prototype.__type=t,l.registerClass(t,n)}}static serialize(e){if(e==null)return e;if(Array.isArray(e))return e.map(l.serialize);if(e instanceof Set)return{__type:"Set",values:Array.from(e).map(l.serialize)};if(e instanceof Map)return{__type:"Map",entries:Array.from(e.entries()).map(([n,t])=>[l.serialize(n),l.serialize(t)])};if(typeof e=="object"){if(Array.isArray(e))return e.map(l.serialize);const n=e.constructor,r={__type:e.__type??n.name};for(const[o,i]of Object.entries(e))r[o]=l.serialize(i);return r}return e}static revive(e){if(e==null)return e;if(Array.isArray(e))return e.map(l.revive);if(e.__type==="Set")return new Set(e.values.map(l.revive));if(e.__type==="Map")return new Map(e.entries.map(([n,t])=>[l.revive(n),l.revive(t)]));if(e.__type){const n=l.getClass(e.__type);if(!n)throw new Error(`Serializer - Unknown class: ${e.__type}`);const t=Object.create(n.prototype);for(const[r,o]of Object.entries(e))r!=="__type"&&(t[r]=l.revive(o));return t}return e}static registerClass(e,n){l.classRegistry.set(e,n)}static getClass(e){return l.classRegistry.get(e)}static classRegistry=new Map}l.registerClass(Object.name,Object);const S=":",m="n:",I="e:";function D(s,e,n){return n.indexOf(s)===e}var R=Object.getOwnPropertyDescriptor,M=(s,e,n,t)=>{for(var r=t>1?void 0:t?R(e,n):e,o=s.length-1,i;o>=0;o--)(i=s[o])&&(r=i(r)||r);return r};let v=class extends P{_nodes;_edges;constructor(){super(),this._nodes=new Set,this._edges=new Set}addNode(s){s.classes==null&&(s.classes=""),!this.nodes.find(e=>e.id==s.id)&&this._nodes.add(s)}addEdge(s){s.classes==null&&(s.classes=""),!this.edges.find(e=>e.id==s.id)&&this._edges.add(s)}get nodes(){return Array.from(this._nodes.values())}get edges(){return Array.from(this._edges.values())}removeNode(s){if(!this._nodes.has(s))return;this._nodes.delete(s),Array.from(this.edges).filter(n=>n.to===s.id||n.from===s.id).forEach(n=>this._edges.delete(n))}removeEdge(s){this._edges.delete(s)}removeEdgeById(s){const e=this.edges.find(n=>n.id==s);e?(console.log("deleting edge with id",s),this._edges.delete(e)):console.log("edge with id",s,"not found")}isEmpty(){return this.nodes.length==0}copy(){const s=new v;for(const e of this._nodes)s.addNode({id:e.id,label:e.label,color:e.color,position:e.position?{...e.position}:void 0,classes:e.classes});for(const e of this._edges)s.addEdge({id:e.id,from:e.from,to:e.to,weight:e.weight,classes:e.classes,controlPointDistances:e.controlPointDistances});return s}asString(){const s=this.nodes.map(n=>n.id.slice(m.length)).join(`
`),e=this.edges.map(n=>n.from.slice(m.length)+" "+n.to.slice(m.length)+(n.weight!=null?" "+n.weight:"")).join(`
`);return s+`
`+e+`
`}static fromString(s){if(s.length==0)return"Cannot construct a graph from empty string";const e=s.split(`
`).map(t=>t.trim()).filter(t=>t.length).filter(D);let n=new v;console.debug("LINES",e);for(let t=0;t<e.length;t++){const o=e[t].split(" ").map(i=>i.trim()).filter(i=>i.length);if(o.length==1){const i=o;n.addNode({id:m+i})}else if(o.length<=3){const i=o[0],g=o[1];let h;if(o.length==3)try{h=Number.parseFloat(o[2])}catch{return`On the line ${t}, couldn't parse the weight: '${o[2]}Please enter a number (floating allowed)`}const f=m+i,u=m+g;n.addNode({id:f}),n.addNode({id:u}),n.addEdge({id:I+`${f}-${u}`,from:f,to:u,weight:h})}}return n}toSerializedString(){const s={nodes:this.nodes.map(e=>({id:e.id,label:e.label??null,color:e.color??null,position:e.position??null,classes:e.classes??""})),edges:this.edges.map(e=>({id:e.id,from:e.from,to:e.to,weight:e.weight??null,classes:e.classes??"",controlPointDistances:e.controlPointDistances??[0,0]}))};return JSON.stringify(s,null)}static fromSerializedString(s){const e=JSON.parse(s),n=new v;if(Array.isArray(e.nodes))for(const t of e.nodes)n.addNode({id:t.id,label:t.label??void 0,color:t.color??void 0,position:t.position??void 0,classes:t.classes??""});if(Array.isArray(e.edges))for(const t of e.edges)n.addEdge({id:t.id,from:t.from,to:t.to,weight:t.weight??void 0,classes:t.classes??"",controlPointDistances:t.controlPointDistances??[0,0]});return n}labelSolved({path:s=[],directed:e=!1,edgeIdUsesNodeIds:n=!0}={}){console.debug("edgeIdUsesNodeIds",n);const t=n?(r=>r):(r=>r.slice(r.search(S)+1));this.edges.forEach(r=>r.classes+=" solved");for(let r=0;r<s.length-1;r++){const o=t(s[r].id),i=t(s[r+1].id),g=I+`${o}-${i}`,h=I+`${i}-${o}`,f=this.edges.find(u=>u.id==g||!e&&u.id==h);console.debug("edgeId",g,"edgeIdMirror",h,"edge found",f!=null),f&&(f.classes+=" used")}}unlabelSolved(){this._edges.forEach(s=>{s.classes&&(s.classes=s.classes.replaceAll("used",""),s.classes=s.classes.replaceAll("solved",""))})}};v=M([l.SerializableClass()],v);var $=Object.getOwnPropertyDescriptor,L=(s,e,n,t)=>{for(var r=t>1?void 0:t?$(e,n):e,o=s.length-1,i;o>=0;o--)(i=s[o])&&(r=i(r)||r);return r};let w=class{path;constructor(s){this.path=s}};w=L([l.SerializableClass()],w);class x{instance;maxCost;constructor(e,n){this.instance=e,this.maxCost=n}solve(){const e=this.instance.nodes,n=this.instance.edges,t=e.length;if(t==0)return E;if(t==1)return new w([e[0]]);const r=Array.from({length:t},()=>Array(t).fill(1/0));for(const a of n){const c=e.findIndex(d=>d.id==a.from),p=e.findIndex(d=>d.id==a.to);if(c!==-1&&p!==-1){const d=a.weight??1;r[c][p]=d,r[p][c]=d}}const o=0,i=1<<t,g=Array.from({length:i},()=>Array(t).fill(1/0)),h=Array.from({length:i},()=>Array(t).fill(-1));g[1<<o][o]=0;for(let a=0;a<i;a++)for(let c=0;c<t;c++){if(!(a&1<<c))continue;const p=a^1<<c;if(p!=0)for(let d=0;d<t;d++){if(!(p&1<<d))continue;const C=g[p][d]+r[d][c];C<g[a][c]&&(g[a][c]=C,h[a][c]=d)}}let f=1/0,u=-1;const N=i-1;for(let a=0;a<t;a++){const c=g[N][a]+r[a][o];c<f&&(f=c,u=a)}if(f==1/0||f>this.maxCost)return E;const A=[];let O=N,y=u;for(;y!==-1;){A.push(y);const a=h[O][y];O^=1<<y,y=a}A.reverse(),A.push(o);const U=A.map(a=>e[a]);return new w(U)}}var _=(s=>(s.UNSOLVABLE="unsolvable",s.RESULT="result",s.ERROR="error",s))(_||{});self.onmessage=async s=>{console.debug("WorkerTSPSolver::onmessage");try{const e=s.data.graph,n=s.data.maxCost,t=v.fromSerializedString(e),o=new x(t,n).solve(),i=o==E?{type:_.UNSOLVABLE}:{type:_.RESULT,path:o.path};postMessage(i)}catch(e){postMessage({type:_.ERROR,message:e instanceof Error?e.message:String(e)})}}})();
