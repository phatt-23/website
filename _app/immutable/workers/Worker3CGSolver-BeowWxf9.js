(function(){"use strict";const p="unsolvable";class a{static SerializableClass(e){return function(s){const r=e??s.name;s.prototype.__type=r,a.registerClass(r,s)}}static serialize(e){if(e==null)return e;if(Array.isArray(e))return e.map(a.serialize);if(e instanceof Set)return{__type:"Set",values:Array.from(e).map(a.serialize)};if(e instanceof Map)return{__type:"Map",entries:Array.from(e.entries()).map(([s,r])=>[a.serialize(s),a.serialize(r)])};if(typeof e=="object"){if(Array.isArray(e))return e.map(a.serialize);const s=e.constructor,o={__type:e.__type??s.name};for(const[n,i]of Object.entries(e))o[n]=a.serialize(i);return o}return e}static revive(e){if(e==null)return e;if(Array.isArray(e))return e.map(a.revive);if(e.__type==="Set")return new Set(e.values.map(a.revive));if(e.__type==="Map")return new Map(e.entries.map(([s,r])=>[a.revive(s),a.revive(r)]));if(e.__type){const s=a.getClass(e.__type);if(!s)throw new Error(`Serializer - Unknown class: ${e.__type}`);const r=Object.create(s.prototype);for(const[o,n]of Object.entries(e))o!=="__type"&&(r[o]=a.revive(n));return r}return e}static registerClass(e,s){a.classRegistry.set(e,s)}static getClass(e){return a.classRegistry.get(e)}static classRegistry=new Map}a.registerClass(Object.name,Object);var _=Object.getOwnPropertyDescriptor,m=(t,e,s,r)=>{for(var o=r>1?void 0:r?_(e,s):e,n=t.length-1,i;n>=0;n--)(i=t[n])&&(o=i(o)||o);return o};let h=class{constructor(t){this.coloring=t}};h=m([a.SerializableClass("Certificate3CG")],h);class v{constructor(e){this.instance=e}solve(){const e=this.instance.copy(),s=e.nodes,r=this.buildAdjacency(e),o=new Map;return s.forEach(i=>{i.color&&o.set(i.id,i.color)}),this.backtrackColor(0,s,r,o)?new h(o):p}buildAdjacency(e){const s=new Map;for(const r of e.nodes)s.set(r.id,new Set);for(const r of e.edges)s.get(r.from).add(r.to),s.get(r.to).add(r.from);return s}backtrackColor(e,s,r,o){if(e==s.length)return!0;const n=s[e],i=o.has(n.id);for(let c=0;c<3;c++)if(this.canUseColor(n.id,c,r,o)){if(i||o.set(n.id,c),this.backtrackColor(e+1,s,r,o))return!0;i||o.delete(n.id)}return!1}canUseColor(e,s,r,o){for(const n of r.get(e))if(o.get(n)==s)return!1;return!0}}class y{}function E(t,e,s){return s.indexOf(t)===e}var D=Object.getOwnPropertyDescriptor,I=(t,e,s,r)=>{for(var o=r>1?void 0:r?D(e,s):e,n=t.length-1,i;n>=0;n--)(i=t[n])&&(o=i(o)||o);return o};let d=class extends y{_nodes;_edges;constructor(){super(),this._nodes=new Set,this._edges=new Set}addNode(t){t.classes==null&&(t.classes=""),!this.nodes.find(e=>e.id==t.id)&&this._nodes.add(t)}addEdge(t){t.classes==null&&(t.classes=""),!this.edges.find(e=>e.id==t.id)&&this._edges.add(t)}get nodes(){return Array.from(this._nodes.values())}get edges(){return Array.from(this._edges.values())}removeNode(t){if(!this._nodes.has(t))return;this._nodes.delete(t),Array.from(this.edges).filter(s=>s.to===t.id||s.from===t.id).forEach(s=>this._edges.delete(s))}removeEdge(t){this._edges.delete(t)}removeEdgeById(t){const e=this.edges.find(s=>s.id==t);e?(console.log("deleting edge with id",t),this._edges.delete(e)):console.log("edge with id",t,"not found")}isEmpty(){return this.nodes.length==0}copy(){const t=new d;for(const e of this._nodes)t.addNode({id:e.id,label:e.label,color:e.color,position:e.position?{...e.position}:void 0,classes:e.classes});for(const e of this._edges)t.addEdge({id:e.id,from:e.from,to:e.to,weight:e.weight,classes:e.classes,controlPointDistances:e.controlPointDistances});return t}asString(){const t=this.nodes.map(s=>s.id.slice(2)).join(`
`),e=this.edges.map(s=>s.from.slice(2)+" "+s.to.slice(2)+(s.weight!=null?" "+s.weight:"")).join(`
`);return t+`
`+e+`
`}static fromString(t){if(t.length==0)return"Cannot construct a graph from empty string";const e=t.split(`
`).map(r=>r.trim()).filter(r=>r.length).filter(E);let s=new d;console.debug("LINES",e);for(let r=0;r<e.length;r++){const n=e[r].split(" ").map(i=>i.trim()).filter(i=>i.length);if(n.length==1){const i=n;s.addNode({id:"n:"+i})}else if(n.length<=3){const i=n[0],c=n[1];let g;if(n.length==3)try{g=Number.parseFloat(n[2])}catch{return`On the line ${r}, couldn't parse the weight: '${n[2]}Please enter a number (floating allowed)`}const l="n:"+i,f="n:"+c;s.addNode({id:l}),s.addNode({id:f}),s.addEdge({id:`e:${l}-${f}`,from:l,to:f,weight:g})}}return s}toSerializedString(){const t={nodes:this.nodes.map(e=>({id:e.id,label:e.label??null,color:e.color??null,position:e.position??null,classes:e.classes??""})),edges:this.edges.map(e=>({id:e.id,from:e.from,to:e.to,weight:e.weight??null,classes:e.classes??"",controlPointDistances:e.controlPointDistances??[0,0]}))};return JSON.stringify(t,null)}static fromSerializedString(t){const e=JSON.parse(t),s=new d;if(Array.isArray(e.nodes))for(const r of e.nodes)s.addNode({id:r.id,label:r.label??void 0,color:r.color??void 0,position:r.position??void 0,classes:r.classes??""});if(Array.isArray(e.edges))for(const r of e.edges)s.addEdge({id:r.id,from:r.from,to:r.to,weight:r.weight??void 0,classes:r.classes??"",controlPointDistances:r.controlPointDistances??[0,0]});return s}labelSolved({path:t=[],directed:e=!1,edgeIdUsesNodeIds:s=!0}={}){console.debug("edgeIdUsesNodeIds",s);const r=s?(o=>o):(o=>o.slice(o.search(":")+1));this.edges.forEach(o=>o.classes+=" solved");for(let o=0;o<t.length-1;o++){const n=r(t[o].id),i=r(t[o+1].id),c=`e:${n}-${i}`,g=`e:${i}-${n}`,l=this.edges.find(f=>f.id==c||!e&&f.id==g);console.debug("edgeId",c,"edgeIdMirror",g,"edge found",l!=null),l&&(l.classes+=" used")}}unlabelSolved(){this._edges.forEach(t=>{t.classes&&(t.classes=t.classes.replaceAll("used",""),t.classes=t.classes.replaceAll("solved",""))})}};d=I([a.SerializableClass()],d);var u=(t=>(t.UNSOLVABLE="unsolvable",t.RESULT="result",t.ERROR="error",t))(u||{});self.onmessage=async t=>{console.debug("Worker3CGSolver::onmessage");try{const e=d.fromSerializedString(t.data.graph),r=new v(e).solve(),o=r==p?{type:u.UNSOLVABLE}:{type:u.RESULT,coloring:Array.from(r.coloring.entries())};postMessage(o)}catch(e){const s={type:u.ERROR,message:e instanceof Error?e.message:String(e)};postMessage(s)}}})();
