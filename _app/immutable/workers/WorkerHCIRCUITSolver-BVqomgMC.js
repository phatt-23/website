(function(){"use strict";const y="unsolvable";class w{}class a{static SerializableClass(e){return function(n){const t=e??n.name;n.prototype.__type=t,a.registerClass(t,n)}}static serialize(e){if(e==null)return e;if(Array.isArray(e))return e.map(a.serialize);if(e instanceof Set)return{__type:"Set",values:Array.from(e).map(a.serialize)};if(e instanceof Map)return{__type:"Map",entries:Array.from(e.entries()).map(([n,t])=>[a.serialize(n),a.serialize(t)])};if(typeof e=="object"){if(Array.isArray(e))return e.map(a.serialize);const n=e.constructor,o={__type:e.__type??n.name};for(const[r,i]of Object.entries(e))o[r]=a.serialize(i);return o}return e}static revive(e){if(e==null)return e;if(Array.isArray(e))return e.map(a.revive);if(e.__type==="Set")return new Set(e.values.map(a.revive));if(e.__type==="Map")return new Map(e.entries.map(([n,t])=>[a.revive(n),a.revive(t)]));if(e.__type){const n=a.getClass(e.__type);if(!n)throw new Error(`Serializer - Unknown class: ${e.__type}`);const t=Object.create(n.prototype);for(const[o,r]of Object.entries(e))o!=="__type"&&(t[o]=a.revive(r));return t}return e}static registerClass(e,n){a.classRegistry.set(e,n)}static getClass(e){return a.classRegistry.get(e)}static classRegistry=new Map}a.registerClass(Object.name,Object);const _=":",g="n:",p="e:";class E extends Error{}function A(s,e){if(!s)throw new E("[ASSERT] "+e)}function D(s,e,n){return n.indexOf(s)===e}var I=Object.getOwnPropertyDescriptor,N=(s,e,n,t)=>{for(var o=t>1?void 0:t?I(e,n):e,r=s.length-1,i;r>=0;r--)(i=s[r])&&(o=i(o)||o);return o};let h=class extends w{_nodes;_edges;constructor(){super(),this._nodes=new Set,this._edges=new Set}addNode(s){s.classes==null&&(s.classes=""),!this.nodes.find(e=>e.id==s.id)&&this._nodes.add(s)}addEdge(s){s.classes==null&&(s.classes=""),s.controlPointDistances==null&&(s.controlPointDistances=[0,0]),A(s.controlPointDistances.length==2,"There must be 2 control points."),!this.edges.find(e=>e.id==s.id)&&this._edges.add(s)}get nodes(){return Array.from(this._nodes.values())}get edges(){return Array.from(this._edges.values())}removeNode(s){if(!this._nodes.has(s))return;this._nodes.delete(s),Array.from(this.edges).filter(n=>n.to===s.id||n.from===s.id).forEach(n=>this._edges.delete(n))}removeEdge(s){this._edges.delete(s)}removeEdgeById(s){const e=this.edges.find(n=>n.id==s);e?(console.log("deleting edge with id",s),this._edges.delete(e)):console.log("edge with id",s,"not found")}isEmpty(){return this.nodes.length==0}copy(){const s=new h;for(const e of this._nodes)s.addNode({id:e.id,label:e.label,color:e.color,position:e.position?{...e.position}:void 0,classes:e.classes});for(const e of this._edges)s.addEdge({id:e.id,from:e.from,to:e.to,weight:e.weight,classes:e.classes,controlPointDistances:e.controlPointDistances});return s}asString(){const s=this.nodes.map(n=>n.id.slice(g.length)).join(`
`),e=this.edges.map(n=>n.from.slice(g.length)+" "+n.to.slice(g.length)+(n.weight!=null?" "+n.weight:"")).join(`
`);return s+`
`+e+`
`}static fromString(s){if(s.length==0)return"Cannot construct a graph from empty string";const e=s.split(`
`).map(t=>t.trim()).filter(t=>t.length).filter(D);let n=new h;console.debug("LINES",e);for(let t=0;t<e.length;t++){const r=e[t].split(" ").map(i=>i.trim()).filter(i=>i.length);if(r.length==1){const i=r;n.addNode({id:g+i})}else if(r.length<=3){const i=r[0],l=r[1];let f;if(r.length==3)try{f=Number.parseFloat(r[2])}catch{return`On the line ${t}, couldn't parse the weight: '${r[2]}Please enter a number (floating allowed)`}const d=g+i,c=g+l;n.addNode({id:d}),n.addNode({id:c}),n.addEdge({id:p+`${d}-${c}`,from:d,to:c,weight:f})}}return n}toSerializedString(){const s={nodes:this.nodes.map(e=>({id:e.id,label:e.label??null,color:e.color??null,position:e.position??null,classes:e.classes??""})),edges:this.edges.map(e=>({id:e.id,from:e.from,to:e.to,weight:e.weight??null,classes:e.classes??"",controlPointDistances:e.controlPointDistances??[0,0]}))};return JSON.stringify(s,null)}static fromSerializedString(s){const e=JSON.parse(s),n=new h;if(Array.isArray(e.nodes))for(const t of e.nodes)n.addNode({id:t.id,label:t.label??void 0,color:t.color??void 0,position:t.position??void 0,classes:t.classes??""});if(Array.isArray(e.edges))for(const t of e.edges)n.addEdge({id:t.id,from:t.from,to:t.to,weight:t.weight??void 0,classes:t.classes??"",controlPointDistances:t.controlPointDistances??[0,0]});return n}labelSolved({path:s=[],directed:e=!1,edgeIdUsesNodeIds:n=!0}={}){console.debug("edgeIdUsesNodeIds",n);const t=n?(o=>o):(o=>o.slice(o.search(_)+1));this.edges.forEach(o=>o.classes+=" solved");for(let o=0;o<s.length-1;o++){const r=t(s[o].id),i=t(s[o+1].id),l=p+`${r}-${i}`,f=p+`${i}-${r}`,d=this.edges.find(c=>c.id==l||!e&&c.id==f);console.debug("edgeId",l,"edgeIdMirror",f,"edge found",d!=null),d&&(d.classes+=" used")}}unlabelSolved(){this._edges.forEach(s=>{s.classes&&(s.classes=s.classes.replaceAll("used",""),s.classes=s.classes.replaceAll("solved",""))})}};h=N([a.SerializableClass()],h);var O=Object.getOwnPropertyDescriptor,S=(s,e,n,t)=>{for(var o=t>1?void 0:t?O(e,n):e,r=s.length-1,i;r>=0;r--)(i=s[r])&&(o=i(o)||o);return o};let m=class{path;constructor(s){this.path=s}};m=S([a.SerializableClass()],m);class C{instance;constructor(e){this.instance=e}solve(){const e=this.instance.nodes,n=this.instance.edges;if(this.instance.isEmpty())throw new Error("Graph is empty.");const t=new Map;for(const c of e)t.set(c.id,new Set);for(const c of n)t.has(c.from)&&t.has(c.to)&&(t.get(c.from).add(c.to),t.get(c.to).add(c.from));const o=e[0].id,r=[o],i=new Set([o]);if(!this.backtrack(o,o,i,r,e.length,t))return y;const f=this.instance.copy(),d=new Array;return r.forEach(c=>{const v=f.nodes.find(P=>P.id==c);if(!v)throw new Error(`Node id in the path is not pointing to any valid node: ${c}`);d.push(v)}),new m(d)}backtrack(e,n,t,o,r,i){if(t.size===r)return i.get(e)?.has(n)?(o.push(n),!0):!1;for(const l of i.get(e)??[])if(!t.has(l)){if(t.add(l),o.push(l),this.backtrack(l,n,t,o,r,i))return!0;t.delete(l),o.pop()}return!1}}var u=(s=>(s.UNSOLVABLE="unsolvable",s.RESULT="result",s.ERROR="error",s))(u||{});self.onmessage=async s=>{console.debug("WorkerHCIRCUITSolver::onmessage");try{const e=h.fromSerializedString(s.data.graph),t=new C(e).solve(),o=t==y?{type:u.UNSOLVABLE}:{type:u.RESULT,path:t.path};postMessage(o)}catch(e){postMessage({type:u.ERROR,message:e instanceof Error?e.message:String(e)})}}})();
